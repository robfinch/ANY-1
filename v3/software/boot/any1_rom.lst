                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/const.r64",1
                        	.file "../fmtk/const.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_UNDEAD   EQU   64
                        	TS_RUNNING	EQU		128
                        	
                        	AS_NONE     EQU   0
                        	AS_LIVE     EQU   1
                        	AS_DEAD     EQU   2
                        	AS_UNDEAD   EQU   4
                        	
                        	PRI_NORMAL  EQU   2
                        	PRI_LOW     EQU   3
                        	
                        	OST_WHITE   EQU   0
                        	OST_GREY    EQU   1
                        	OST_BLACK   EQU   2
                        	OST_UNDEAD  EQU   64    ; no longer alive, but not dead yet (finalizer hasn't been called)
                        	OST_DEAD    EQU   128   ; completely dead, finalizer called already
                        	
                        	TCB_MAGIC     EQU   ((' ' << 24) | ('T' << 16) | ('C' << 8) | 'B')
ACB_MAGIC     EQU   ((' ' << 24) | ('A' << 16) | ('C' << 8) | 'B')
MSG_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('S' << 8) | 'G')
MBX_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('B' << 8) | 'X')

                        	UNDEADQ     EQU   7
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_Func  =   0x02
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadDCBOffset = 0x1A
                        	E_Busy = 0x1B
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	E_BadTcbPointer = 0x27
                        	E_BadTid = 0x28
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	= 0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMoreAppIds = 0x46
                        	E_NoMem = 0x47
                        	
                        	CSR_TRACECTRL = $70A0
                        	CSR_PTA     = $1003
                        	CSR_TASKID  = $1010
                        	CSR_ASID    = $101F
                        	CSR_MSTATUS = $3000
                        	CSR_RSSTACK = $3043
                        	CSR_PMSTACK = $3040
                        	CSR_MEPC    = $3048
                        	CSR_MSEMA   = $30C1
                        	
                        	CSR_REGSET  = $5012
                        	CSR_DBAD0   = $5018
                        	CSR_DBAD1   = $5019
                        	CSR_DBAD2   = $501A
                        	CSR_DBAD3   = $501B
                        	CSR_DBCR    = $501C
                        	CSR_DBSR    = $501D
                        	
                        	TCBPTR_MASK = $FFF803FF
                        	
                        	; Message types
                        	MT_ANNOUNCE = $00000010
                        	MT_IRQ      = $FFFFFFFF
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/types.r64",1
                        	.file "../fmtk/types.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	OBJMagic    EQU   0
                        	OBJSize     EQU   8
                        	OBJTypenum  EQU   16
                        	OBJID       EQU   20
                        	OBJState    EQU   24    ; WHITE, GREY, BLACK
                        	OBJScavcnt  EQU   25    ; scavange count
                        	OBJOwningMap  EQU   26
                        	OBJPad1       EQU   27
                        	OBJCollectionIndex  EQU   28
                        	OBJUsedInMap  EQU   32    ; used in map
                        	OBJPad3       EQU   36
                        	OBJFWAddr     EQU   40    ; forwarding address
                        	OBJFinalizer  EQU   48
                        	OBJ_SIZE      EQU   64
                        	
                        	; Task Control Block
                        	TCBObject   EQU   $000    ; Object structure, state
                        	TCBIntRegs  EQU   $040    ; integer register set storage area (room for 64-bit)
                        	TCBxCR      EQU   $040
                        	TCBxRA      EQU   $048
                        	TCBxSP      EQU   $050
                        	TCBxGP      EQU   $058
                        	TCBxTP      EQU   $060
                        	TCBxT0      EQU   $068
                        	TCBxT1      EQU   $070
                        	TCBxT2      EQU   $078
                        	TCBxFP      EQU   $080
                        	TCBxS1      EQU   $088
                        	TCBxA0      EQU   $090
                        	TCBxA1      EQU   $098
                        	TCBxA2      EQU   $0A0
                        	TCBxA3      EQU   $0A8
                        	TCBxA4      EQU   $0B0
                        	TCBxA5      EQU   $0B8
                        	TCBxA6      EQU   $0C0
                        	TCBxA7      EQU   $0C8
                        	TCBxS2      EQU   $0D0
                        	TCBxS3      EQU   $0D8
                        	TCBxS4      EQU   $0E0
                        	TCBxS5      EQU   $0E8
                        	TCBxS6      EQU   $0F0
                        	TCBxS7      EQU   $0F8
                        	TCBxS8      EQU   $100
                        	TCBxS9      EQU   $108
                        	TCBxS10     EQU   $110
                        	TCBxS11     EQU   $118
                        	TCBxT3      EQU   $120
                        	TCBxT4      EQU   $128
                        	TCBxT5      EQU   $130
                        	TCBxT6      EQU   $138
                        	TCBxRA0     EQU   $140
                        	TCBxRA1     EQU   $148
                        	TCBxCN      EQU   $150
                        	TCBFltRegs  EQU   $158    ; float register set storage area
                        	TCBRegsEnd  EQU   $258
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBbases  	EQU		$258		; base register storage
                        	TCBepc  		EQU		$2D8
                        	TCBStatus		EQU		$2E0
                        	TCBPriority	EQU		$2E1
                        	TCBWaitMbx	EQU		$2E2
                        	TCBRegset   EQU   $2E3
                        	TCBHasFocus EQU   $2E4
                        	TCBStackBot	EQU		$2E8
                        	TCBMsgD1		EQU		$2F0
                        	TCBMsgD2		EQU		$2F8
                        	TCBMsgD3		EQU		$300
                        	TCBStartTick	EQU	$308
                        	TCBEndTick	EQU		$310
                        	TCBTicks		EQU		$318
                        	TCBException	EQU	$320
                        	TCBNext			EQU		$328
                        	TCBPrev			EQU		$330
                        	TCBTimeout	EQU		$338
                        	TCBtid      EQU   $340
                        	TCBmid      EQU   $342
                        	TCBappid    EQU   $344
                        	TCBOpMode   EQU   $346
                        	TCBMbxNext  EQU   $348
                        	TCBMbxPrev  EQU   $350
                        	TCBTaskNum  EQU   $358
                        	TCBName			EQU		$360
                        	
                        	; Application Control Block
                        	ACBObject     EQU   0
                        	ACBpData      EQU   64
                        	ACBDataSize   EQU   72
                        	ACBpUIData    EQU   80
                        	ACBUIDataSize EQU   88
                        	ACBGCRoots    EQU   96
                        	ACBGCRootCnt  EQU   104
                        	ACBGCNdx      EQU   112
                        	ACBGCMarkingQue EQU   120
                        	ACBGCMarkingQueFull   EQU   128
                        	ACBGCMarkingQueEmpty  EQU   129
                        	ACBGCOverflow EQU   130
                        	ACBpCode      EQU   134
                        	ACBObjectList EQU   144
                        	ACBGarbageList  EQU   152
                        	ACBHeap       EQU   160   ; 640+ bytes for heap object info
                        	ACBiofNext    EQU   824
                        	ACBiofPrev    EQU   832
                        	ACBUserName   EQU   840   ; 2 byte index of string in string area
                        	ACBPath       EQU   842   ; 2 byte index of string in string area
                        	ACBExitRunFile  EQU   844 ; 2 byte index of string in string area
                        	ACBCommandLine  EQU   846 ; 2 byte index of string in string area
                        	ACBpVidMem    EQU   848
                        	ACBpVirtVidMem  EQU 856
                        	ACBVideoRows  EQU   864
                        	ACBVideoCols  EQU   865
                        	ACBCursorRow  EQU   866
                        	ACBCursorCol  EQU   867
                        	ACBNormAttr   EQU   868
                        	ACBKeyState1  EQU   872
                        	ACBKeyState2  EQU   874
                        	ACBKeybdWaitFlag  EQU   876
                        	ACBKeybdHead  EQU   878
                        	ACBKeybdTail  EQU   879
                        	ACBKeybdBuffer  EQU   880
                        	ACBnumber     EQU   944
                        	ACBNext       EQU   952
                        	ACBTask       EQU   960
                        	ACBHasFocus   EQU   962
                        	ACBmid        EQU   964
                        	ACBStatus     EQU   966
                        	ACBTemplates  EQU   968   ; 256 * 8 bytes reserved for template pointers
                        	ACBPad        EQU   3016
                        	ACBStrings    EQU   3072  ; start of 1kB string area
                        	ACBEnd        EQU   4096
                        	
                        	; Application startup record
                        	ASRPageSize   EQU   0
                        	ASRPriority   EQU   1
                        	ASRRegset     EQU   2
                        	ASRmid        EQU   3
                        	ASRAffinity   EQU   4
                        	ASRCodeSize   EQU   8
                        	ASRDataSize   EQU   16
                        	ASRUIDataSize EQU   24
                        	ASRHeapSize   EQU   32
                        	ASRStackSize  EQU   40
                        	ASRpCode      EQU   48
                        	ASRpData      EQU   56
                        	ASRpUIData    EQU   64
                        	ASR_SIZE      EQU   72
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	;MBX_WTIDS			equ		4		; tasks waiting at mailbox
                        	MBX_LINK      equ   8
                        	MBX_TQHEAD    equ   8   ; link field for free list shared with task queue head
                        	MBX_TQTAIL    equ   16
                        	MBX_MQHEAD		equ		24		
                        	MBX_MQTAIL		equ		32
                        	MBX_SIZE			equ		40
                        	
                        	MSG_LINK	  equ		0
                        	MSG_RETADR  equ   8
                        	MSG_TGTADR  equ   10
                        	MSG_TYPE    equ   12
                        	MSG_D1		  equ		16
                        	MSG_D2		  equ		24
                        	MSG_D3		  equ		32
                        	MSG_SIZE	  equ		40
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/config.r64",1
                        	.file "../fmtk/config.r64",1
                        	MAX_TID		EQU		15
                        	NR_TCB		EQU		32
                        	NTASK     EQU   32      ; number of tasks allowed
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		12
                        	LOG_ACBSZ EQU   12
                        	OSPAGES		EQU		8		    ; pages of memory dedicated to OS
                        	MAXVPG    EQU   32767   ; maximum virtual page number
                        	PAGESZ    EQU   4096    ; size of a page of memory
                        	MEMSZ     EQU   131072  ; 4096B pages
                        	MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/device.r64",1
                        	.file "../fmtk/device.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2021  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_fUI       EQU   0x3A    ; user interface device
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x60
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	DVC_IsUI          EQU   27
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Front Panel 		FP
                        	;11
                        	;12		Hard disk				HD1
                        	;13		Hard disk				HD2
                        	;14
                        	;15   Time slice / GP	VIA
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/macro.r64",1
                        	.file "../fmtk/macro.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; disable interrupts
                        	macro mDI
  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
endm
                        	
                        	; disable interrupts
                        	macro mEI
  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
endm
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		$a0,#-1
	sto		$a0,adr
endm
                        	
                        	macro mGetCurrentTid
  csrrw $a0,#CSR_TASKID,$x0
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	brk   #240
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#tm
	brk   #240
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   a1 = device # to check
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
  mov   $t2,$a1
	
	ldi		$a0,#20
	brk   #240
tst   $a1
	bne 	.HasFocus@
	ldi   $a0,#26             ; FMTK_IO
	mov   $a1,$t2
	ldi   $a2,#9              ; peekchar function
	brk   #240
	sne		$a0,#$14						; CTRL-T
	bt		.WFF2@
	; eat up the CTRL-T
	ldi		$a0,#26							; FMTK_IO
	mov   $a1,$t2
	ldi		$a2,#8							; getchar function
	brk   #240
	ldi		$a0,#21							; switch IO Focus
	brk   #240
	jmp		.WFF1@
.WFF2@:
	
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#1
	brk   #240

	jmp		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = mailbox handle
                        	; Modifies:
                        	;   $t0
                        	; Returns:
                        	;   $a0 = mailbox pointer
                        	;------------------------------------------------------------------------------
                        	
                        	macro mMbxHandleToPointer
  lsr   $t0,$a0,#8    ; extract collection index
  asl   $t0,$t0,#2
  ldt   $t0,MbxBlockPtr[$t0]
  and   $a0,$a0,#$FF
  asl   $a0,$a0,#2
  or    $a0,$a0,$t0
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list pointer to TCB
                        	;------------------------------------------------------------------------------
                        	
                        	;macro mPopTimeoutList
                        	;	lbu		$v1,TCBStatus[$v0]		; no longer a waiting status
                        	;	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
                        	;	beqz	$t1,.noWait@
                        	;	ldbu  $a0,TCBtid[$v0]
                        	;	mMbxRemoveTask							; remove task from mailbox list
                        	.noWait@:
                        	;	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
                        	;	stb		$v1,TCBStatus[$v0]
                        	;	ldt		$v1,TCBNext[$v0]			; get next task on timeout list
                        	;	stt		$v1,TimeoutList				; update list head
                        	;	beqz	$v1,.done@
                        	;	stt		$x0,TCBPrev[$v1]			; TimeoutList->prev = 0
                        	.done@:
                        	;	stt		$x0,TCBNext[$v0]
                        	;	stt		$x0,TCBPrev[$v0]
                        	endm
                        	
                        	macro mGetAppMid
  asl   $a0,$a0,#LOG_PGSZ
  ldb   $a0,ACBmid[$a0]
endm
                        	
                        	; Macros to enable and disable time-slice interrupts
                        	macro mTimeSliceEI
	ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
	stt		$t0,VIA_IER+VIA
endm
                        	
                        	macro mTimeSliceDI
	ldi		$t0,#$100						; disable timer3 (time slice) interrupts
	stt		$t0,VIA_IER+VIA
	nop                   ; make sure disable has time for effect
	nop
endm
                        	
                        	; Inserting into the ready queue is done by both OS ecall functions and
                        	; interrupt driven scheduling. It's important to have interrupts disabled
                        	; so that there is no contention for the ready queue.
                        	
                        	macro mInsertIntoReadyQueue
	asl   $t0,$a0,#LOG_TCBSZ
	ldbu	$t1,TCBStatus[$t0]	; set status to ready
	or		$t1,$t1,#TS_READY
	stb		$t1,TCBStatus[$t0]
	ldb		$t1,TCBPriority[$t0]
	pushq	$a0,$t1
endm
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/globals.r64",1
                        	.file "../fmtk/globals.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	INBUF				equ		$0100
                        	switchflag	equ		$0200
                        	milliseconds	equ		$0208
                        	CurrentTid  equ   $210
                        	TaskNum     equ   $220
                        	__xhandler_head equ $228
                        	
                        	ACBPtrs EQU $0280
                        	APPID_POOL  EQU   $02F0
                        	NPAGES	equ		$0300
                        	QNDX		EQU		$0304
                        	READYQ	EQU		$0308
                        	TID_POOL  EQU		$0310
                        	missed_ticks	equ		$0320
                        	TimeoutList		equ		$0328
                        	Tick		EQU		$0330
                        	SysSema	EQU		$0340
                        	MEPC0   EQU   $0350
                        	MEPC1   EQU   $0358
                        	MEPC2   EQU   $0360
                        	MEPC3   EQU   $0368
                        	CURIN   EQU   $0370
                        	CUROUT  EQU   $0371
                        	CHAINA0 EQU   $0378
                        	CHAINA1 EQU   $0380
                        	CHAINA2 EQU   $0388
                        	CHAINA3 EQU   $0390
                        	CHAINA4 EQU   $0398
                        	CHAINA5 EQU   $03A0
                        	READYQ  EQU   $0400
                        	RDYQ0		EQU		$0400
                        	RDYQ1		EQU		$0500
                        	RDYQ2		EQU		$0600
                        	RDYQ3		EQU		$0700
                        	mbxs		EQU		$0800
                        	mbxs_end	EQU	$0C00
                        	FreeMsg	EQU		$0C00
                        	FreeMbx EQU   $0C08
                        	IdleTaskMbx EQU   $0C10
                        	IdleTaskMsgD1 EQU   $0C18
                        	IdleTaskMsgD2 EQU   $0C20
                        	IdleTaskMsgD3 EQU   $0C28
                        	IdleTaskId    EQU   $0C2A
                        	PAMPtr  EQU   $0FF8
                        	IOFocusNdx		EQU		$1080
                        	IOFocusTbl		EQU		$1088
                        	IRQFlag   EQU $1090
                        	IRQCause  EQU $1098
                        	MbxBlockPtr EQU   $10A0
                        	MbxBlockPtrEnd  EQU MbxBlockPtr + MBX_BLOCKPTR_BUFSZ * 4
                        	MbxBlockCounter EQU $10E0
                        	RegsetTid   EQU   $10F0
                        	SerRcvBuf		EQU		$1400
                        	SerXmitBuf	EQU		$1800
                        	SerHeadRcv	EQU		$1C00
                        	SerTailRcv	EQU		$1C04
                        	SerHeadXmit	EQU		$1C08
                        	SerTailXmit	EQU		$1C0C
                        	SerRcvXon		EQU		$1C10
                        	SerRcvXoff	EQU		$1C11
                        	; The following must be at least 128 byte aligned
                        	DVF_Base		EQU		$2000
                        	DVF_Limit		EQU		$3000
                        	DCB_Base    EQU   $3000
                        	DCB_Limit   EQU   $3C00
                        	PAM     EQU   $4000
                        	_PAM     EQU   $4000
                        	_PAMend  EQU   $C000
                        	
                        	SysHeapStart  EQU   $5000
                        	SysHeapEnd    EQU   $20000
                        	
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	
                        	TEST  equ   1
                        	
                        	CTRLC				equ		$03
                        	CTRLT       equ   $14
                        	BS					equ		$08
                        	LNFD  			equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	EOF         equ   $1A
                        	DEL					equ		$7F
                        	VIA					equ		$FFFFFFFFFF910000*2
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_T2CL    equ   $20
                        	VIA_T2CH    equ   $24
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFFFFFFFFF930000*2
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        	
                        	CSR_UIE     	equ   $004
                        	CSR_DCAUSE		equ		$4006
                        	CSR_DSCRATCH	equ		$4041
                        	FLT_WD				equ		$36
                        	
                        	ROMBASE		equ		$FFFFFFFFFFFC0000*2
                        	IOBASE		equ		$FFFFFFFFFF800000*2
                        	TEXTSCR		equ		$FFFFFFFFFF800000*2
                        	KEYBD		equ		$FFFFFFFFFF8E0000*2
                        	LEDS		equ			$FFFFFFFFFF910000*2
                        	xbLEDS		equ			$FFFFFFFFFBDC0600*2
                        	xbBridge1 equ   $FFFFFFFFFFDCF010*2
                        	BUTTONS		equ		$FFFFFFFFFF910000*2
                        	SCRATCHPAD	equ		$FFFFFFFFFF400000*2
                        	SCRATCHMEM	equ		$FFFFFFFFFF400000*2
                        	_DBGAttr  equ   SCRATCHMEM
                        	;DBGATTR   equ   $0000FFFF000F0000   ; white on blue, priority $40
                        	DBGATTR   equ   %000000_111111111111111111111_000001100000110111111_0000000000000000
                        	_cursorX  equ   _DBGAttr + 8
                        	_cursorY  equ   _cursorX + 1
                        	
                        	
                        	.file "any1_rom.r64",53
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        	{+
                        		org		ROMBASE				; user mode exception
FFFFFFFFFFFC0000.0 0007F9041 		bra		DBGRout
FFFFFFFFFFFC0004.8 000000000 		org 	ROMBASE+$60*2				; machine mode exception
FFFFFFFFFFFC0009.0 000000000 
FFFFFFFFFFFC000D.8 000000000 
FFFFFFFFFFFC0012.0 000000000 
FFFFFFFFFFFC0016.8 000000000 
FFFFFFFFFFFC001B.0 000000000 
FFFFFFFFFFFC001F.8 000000000 
FFFFFFFFFFFC0024.0 000000000 
FFFFFFFFFFFC0028.8 000000000 
FFFFFFFFFFFC002D.0 000000000 
FFFFFFFFFFFC0031.8 000000000 
FFFFFFFFFFFC0036.0 000000000 
FFFFFFFFFFFC003A.8 000000000 
FFFFFFFFFFFC003F.0 000000000 
FFFFFFFFFFFC0043.8 000000000 
FFFFFFFFFFFC0048.0 000000000 
FFFFFFFFFFFC004C.8 000000000 
FFFFFFFFFFFC0051.0 000000000 
FFFFFFFFFFFC0055.8 000000000 
FFFFFFFFFFFC005A.0 000000000 
FFFFFFFFFFFC005E.8 7C9041000 
FFFFFFFFFFFC0060.0 0007C9041 		bra		DBGRout
FFFFFFFFFFFC0064.8 000000000 		org 	ROMBASE+$80*2				; debug mode exception
FFFFFFFFFFFC0069.0 000000000 
FFFFFFFFFFFC006D.8 000000000 
FFFFFFFFFFFC0072.0 000000000 
FFFFFFFFFFFC0076.8 000000000 
FFFFFFFFFFFC007B.0 000000000 
FFFFFFFFFFFC007F.8 007B90410 
FFFFFFFFFFFC0080.0 0007B9041 		bra		DBGRout
FFFFFFFFFFFC0084.8 000000000 		org		ROMBASE+$F2*2			; non-maskable interrupt
FFFFFFFFFFFC0089.0 000000000 
FFFFFFFFFFFC008D.8 000000000 
FFFFFFFFFFFC0092.0 000000000 
FFFFFFFFFFFC0096.8 000000000 
FFFFFFFFFFFC009B.0 000000000 
FFFFFFFFFFFC009F.8 000000000 
FFFFFFFFFFFC00A4.0 000000000 
FFFFFFFFFFFC00A8.8 000000000 
FFFFFFFFFFFC00AD.0 000000000 
FFFFFFFFFFFC00B1.8 000000000 
FFFFFFFFFFFC00B6.0 000000000 
FFFFFFFFFFFC00BA.8 000000000 
FFFFFFFFFFFC00BF.0 000000000 
FFFFFFFFFFFC00C3.8 000000000 
FFFFFFFFFFFC00C8.0 000000000 
FFFFFFFFFFFC00CC.8 000000000 
FFFFFFFFFFFC00D1.0 000000000 
FFFFFFFFFFFC00D5.8 000000000 
FFFFFFFFFFFC00DA.0 000000000 
FFFFFFFFFFFC00DE.8 000000000 
FFFFFFFFFFFC00E3.0 000000000 
FFFFFFFFFFFC00E7.8 000000000 
FFFFFFFFFFFC00EC.0 000000000 
FFFFFFFFFFFC00F0.8 00707A000 
FFFFFFFFFFFC00F2.0     0707A 		bra		MachineStart    ; cannot use a jump here, takes too much room
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC00F4.8 000000000 		org		ROMBASE+$100*2
FFFFFFFFFFFC00F9.0 000000000 
FFFFFFFFFFFC00FD.8 004100000 
FFFFFFFFFFFC0100.0 0006C0041 		bra		IRQRout
FFFFFFFFFFFC0104.8 000000000 		org 	ROMBASE+$1C0*2		; machine mode exception
FFFFFFFFFFFC0109.0 000000000 
FFFFFFFFFFFC010D.8 000000000 
FFFFFFFFFFFC0112.0 000000000 
FFFFFFFFFFFC0116.8 000000000 
FFFFFFFFFFFC011B.0 000000000 
FFFFFFFFFFFC011F.8 000000000 
FFFFFFFFFFFC0124.0 000000000 
FFFFFFFFFFFC0128.8 000000000 
FFFFFFFFFFFC012D.0 000000000 
FFFFFFFFFFFC0131.8 000000000 
FFFFFFFFFFFC0136.0 000000000 
FFFFFFFFFFFC013A.8 000000000 
FFFFFFFFFFFC013F.0 000000000 
FFFFFFFFFFFC0143.8 000000000 
FFFFFFFFFFFC0148.0 000000000 
FFFFFFFFFFFC014C.8 000000000 
FFFFFFFFFFFC0151.0 000000000 
FFFFFFFFFFFC0155.8 000000000 
FFFFFFFFFFFC015A.0 000000000 
FFFFFFFFFFFC015E.8 000000000 
FFFFFFFFFFFC0163.0 000000000 
FFFFFFFFFFFC0167.8 000000000 
FFFFFFFFFFFC016C.0 000000000 
FFFFFFFFFFFC0170.8 000000000 
FFFFFFFFFFFC0175.0 000000000 
FFFFFFFFFFFC0179.8 000000000 
FFFFFFFFFFFC017E.0 000000000 
FFFFFFFFFFFC0182.8 000000000 
FFFFFFFFFFFC0187.0 000000000 
FFFFFFFFFFFC018B.8 000000000 
FFFFFFFFFFFC0190.0 000000000 
FFFFFFFFFFFC0194.8 000000000 
FFFFFFFFFFFC0199.0 000000000 
FFFFFFFFFFFC019D.8 000000000 
FFFFFFFFFFFC01A2.0 000000000 
FFFFFFFFFFFC01A6.8 000000000 
FFFFFFFFFFFC01AB.0 000000000 
FFFFFFFFFFFC01AF.8 000000000 
FFFFFFFFFFFC01B4.0 000000000 
FFFFFFFFFFFC01B8.8 000000000 
FFFFFFFFFFFC01BD.0 041000000 
FFFFFFFFFFFC01C0.0 000660041 		bra		IRQRout
FFFFFFFFFFFC01C4.8 000000000 		org		ROMBASE+$1F2*2		; non-maskable interrupt
FFFFFFFFFFFC01C9.0 000000000 
FFFFFFFFFFFC01CD.8 000000000 
FFFFFFFFFFFC01D2.0 000000000 
FFFFFFFFFFFC01D6.8 000000000 
FFFFFFFFFFFC01DB.0 000000000 
FFFFFFFFFFFC01DF.8 000000000 
FFFFFFFFFFFC01E4.0 000000000 
FFFFFFFFFFFC01E8.8 000000000 
FFFFFFFFFFFC01ED.0 000000000 
FFFFFFFFFFFC01F1.8 0008707A0 
FFFFFFFFFFFC01F2.0     8707A 		bra		MachineStart    ; cannot use a jump here, takes too much room
                        	
FFFFFFFFFFFC01F4.8 000000000 		org		ROMBASE+$200*2
FFFFFFFFFFFC01F9.0 000000000 
FFFFFFFFFFFC01FD.8 004100000 
FFFFFFFFFFFC0200.0 000640041 		bra		IRQRout
FFFFFFFFFFFC0204.8 000000000 		org 	ROMBASE+$2C0*2		; machine mode exception
FFFFFFFFFFFC0209.0 000000000 
FFFFFFFFFFFC020D.8 000000000 
FFFFFFFFFFFC0212.0 000000000 
FFFFFFFFFFFC0216.8 000000000 
FFFFFFFFFFFC021B.0 000000000 
FFFFFFFFFFFC021F.8 000000000 
FFFFFFFFFFFC0224.0 000000000 
FFFFFFFFFFFC0228.8 000000000 
FFFFFFFFFFFC022D.0 000000000 
FFFFFFFFFFFC0231.8 000000000 
FFFFFFFFFFFC0236.0 000000000 
FFFFFFFFFFFC023A.8 000000000 
FFFFFFFFFFFC023F.0 000000000 
FFFFFFFFFFFC0243.8 000000000 
FFFFFFFFFFFC0248.0 000000000 
FFFFFFFFFFFC024C.8 000000000 
FFFFFFFFFFFC0251.0 000000000 
FFFFFFFFFFFC0255.8 000000000 
FFFFFFFFFFFC025A.0 000000000 
FFFFFFFFFFFC025E.8 000000000 
FFFFFFFFFFFC0263.0 000000000 
FFFFFFFFFFFC0267.8 000000000 
FFFFFFFFFFFC026C.0 000000000 
FFFFFFFFFFFC0270.8 000000000 
FFFFFFFFFFFC0275.0 000000000 
FFFFFFFFFFFC0279.8 000000000 
FFFFFFFFFFFC027E.0 000000000 
FFFFFFFFFFFC0282.8 000000000 
FFFFFFFFFFFC0287.0 000000000 
FFFFFFFFFFFC028B.8 000000000 
FFFFFFFFFFFC0290.0 000000000 
FFFFFFFFFFFC0294.8 000000000 
FFFFFFFFFFFC0299.0 000000000 
FFFFFFFFFFFC029D.8 000000000 
FFFFFFFFFFFC02A2.0 000000000 
FFFFFFFFFFFC02A6.8 000000000 
FFFFFFFFFFFC02AB.0 000000000 
FFFFFFFFFFFC02AF.8 000000000 
FFFFFFFFFFFC02B4.0 000000000 
FFFFFFFFFFFC02B8.8 000000000 
FFFFFFFFFFFC02BD.0 041000000 
FFFFFFFFFFFC02C0.0 0005E0041 		bra		IRQRout
FFFFFFFFFFFC02C4.8 000000000 		org		ROMBASE+$2F2*2		; non-maskable interrupt
FFFFFFFFFFFC02C9.0 000000000 
FFFFFFFFFFFC02CD.8 000000000 
FFFFFFFFFFFC02D2.0 000000000 
FFFFFFFFFFFC02D6.8 000000000 
FFFFFFFFFFFC02DB.0 000000000 
FFFFFFFFFFFC02DF.8 000000000 
FFFFFFFFFFFC02E4.0 000000000 
FFFFFFFFFFFC02E8.8 000000000 
FFFFFFFFFFFC02ED.0 000000000 
FFFFFFFFFFFC02F1.8 0000707A0 
FFFFFFFFFFFC02F2.0     0707A 		bra		MachineStart    ; cannot use a jump here, takes too much room
                        	
                        	;------------------------------------------------------------------------------
                        	; Reset starting address.
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC02F4.8 000000000 		org		ROMBASE+$300*2
FFFFFFFFFFFC02F9.0 000000000 
FFFFFFFFFFFC02FD.8 040400000 
                        	MachineStart:
                        	;  ldi   $t1,#$81
                        	;  sto   $t1,xbBridge1
FFFFFFFFFFFC0300.0 00AA00404 	  ldi   $t0,#$AA
FFFFFFFFFFFC0304.8 00AA01404 	  ldi   $a0,#$AA
FFFFFFFFFFFC0309.0 FFFD00050 		ldi		$x29,#SCRATCHMEM
FFFFFFFFFFFC030D.8 000001D04 
FFFFFFFFFFFC0312.0 FFFFFFF5F 		stm		[$x29],#%111111111111111111111111111111
FFFFFFFFFFFC0316.8 D00074068 
FFFFFFFFFFFC031B.0 FFFE44050 	  stb   $t0,LEDS
FFFFFFFFFFFC031F.8 000400068 
FFFFFFFFFFFC0324.0 FFFE44050 	  stb   $a0,LEDS
FFFFFFFFFFFC0328.8 001400068 
FFFFFFFFFFFC032D.0 FFFFFFF5F 		ldm		[$x29],#%111111111111111111111111111111
FFFFFFFFFFFC0331.8 D00074060 
                        	
FFFFFFFFFFFC0336.0 FFFD03350 		ldi		$sp,#SCRATCHMEM+$CDF8*2		  ; setup debug mode stack pointer
FFFFFFFFFFFC033A.8 9BF001E04 
FFFFFFFFFFFC033F.0     FDE75 		sub 	$sp,$sp,#16
FFFFFFFFFFFC0341.8 FFFD02050 		ldi		$t0,#SCRATCHMEM+$8000*2
FFFFFFFFFFFC0346.0 000000404 
FFFFFFFFFFFC034A.8 019D1200F 		csrrw	$x0,#CSR_DTCBPTR,$t0				; set TCB pointer
FFFFFFFFFFFC034F.0     1547B 		ldi   $a0,#10
FFFFFFFFFFFC0351.8     0157B 		ldi   $a1,#0
FFFFFFFFFFFC0354.0 F5404E141 		bal   $x1,_Delay2s
FFFFFFFFFFFC0356.8 E0502F541 		bal   $x1,dbg_HomeCursor
FFFFFFFFFFFC0359.0 C1837E050 		ldi		$a1,#DBGATTR		  ; set zorder $40, white text, blue background
FFFFFFFFFFFC035D.8 007FFFF51 
FFFFFFFFFFFC0362.0 000001504 
FFFFFFFFFFFC0366.8 FFFD00050 		sto		$a1,_DBGAttr
FFFFFFFFFFFC036B.0 301500068 
                        	  ; clear debug screen
FFFFFFFFFFFC036F.8 FFFD00050 	  ldo   $a0,_DBGAttr
FFFFFFFFFFFC0374.0 300001460 
FFFFFFFFFFFC0378.8 FFFE00050 	  ldi   $t0,#TEXTSCR
FFFFFFFFFFFC037D.0 000000404 
                        	ifdef TEST
FFFFFFFFFFFC0381.8     0C57B 	  ldi   $t1,#6
                        	else
                        	  ldi   $t1,#56*29
                        	endif
                        	.0001:
FFFFFFFFFFFC0384.0     FE575 	  sub   $t1,$t1,#1
FFFFFFFFFFFC0386.8 000014058 	  sto   $a0,[$t0+$t1*16]
FFFFFFFFFFFC038B.0 381410069 
FFFFFFFFFFFC038F.8     D2579 	  bne   $t1,$x0,.0001
FFFFFFFFFFFC0392.0 C1837E050 		ldi		$a1,#DBGATTR|$41
FFFFFFFFFFFC0396.8 007FFFF51 
FFFFFFFFFFFC039B.0 004101504 
FFFFFFFFFFFC039F.8 FFFE00050 		sto		$a1,TEXTSCR
FFFFFFFFFFFC03A4.0 301500068 
FFFFFFFFFFFC03A8.8 FFFE00050 		sto		$a1,TEXTSCR+8*2
FFFFFFFFFFFC03AD.0 301501068 
FFFFFFFFFFFC03B1.8 FFFE00050 		sto		$a1,TEXTSCR+16*2
FFFFFFFFFFFC03B6.0 301502068 
FFFFFFFFFFFC03BA.8 FFFE00050 		sto		$a1,TEXTSCR+24*2
FFFFFFFFFFFC03BF.0 301503068 
                        	
                        	;  ldi   $a0,#msgStart
                        	  ;call  PutHexTetra
FFFFFFFFFFFC03C3.8 FFFFF1050 	  ldi   $a0,#msgStart
FFFFFFFFFFFC03C8.0 823001404 
FFFFFFFFFFFC03CC.8 0004EB141 	  bal   $x1,PutString
                        	
                        	;  call  _ramtest2
                        	;	csrrs $x0,#CSR_TRACECTRL,#1 ; turn on tracing
FFFFFFFFFFFC03D1.0 01FE80541 	  bal   $x1,_pti_init
FFFFFFFFFFFC03D5.8 000010050 	  ldi   $a1,#$80000
FFFFFFFFFFFC03DA.0 000001504 
FFFFFFFFFFFC03DE.8 000040050 	  ldi   $a0,#$200000
FFFFFFFFFFFC03E3.0 000001404 
FFFFFFFFFFFC03E7.8 01FE75541 	  bal   $x1,_pti_read_block
                        	
FFFFFFFFFFFC03EC.0 01FE73541 		bal   $x1,MMUInit					; initialize MMU for address space zero.
FFFFFFFFFFFC03F0.8 01FE71541 		bal   $x1,_FMTKInit
                        		;call  ViaSetup
                        	;	call  _SerialInit
FFFFFFFFFFFC03F5.0 01FE6F541 		bal   $x1,_InitPIC
FFFFFFFFFFFC03F9.8     0A47B 		ldi   $t0,#5          ; set current input and output to serial port
FFFFFFFFFFFC03FC.0 068403068 		stb   $t0,CURIN
FFFFFFFFFFFC0400.8 068403168 		stb   $t0,CUROUT
FFFFFFFFFFFC0405.0     0047B 		ldi		$t0,#0
FFFFFFFFFFFC0407.8 30C11200F 		csrrw $x0,#CSR_MSEMA,$t0  ; turn off semaphores
FFFFFFFFFFFC040C.0 01811200F 		csrrw	$x0,#$181,$t0		    ; set ASID
FFFFFFFFFFFC0410.8 10101200F 		csrrw $x0,#CSR_TASKID,$t0 ; clear task id
FFFFFFFFFFFC0415.0 FFFFF0050 		ldi		$t0,#$FFFFFFFFFFFC0000*2
FFFFFFFFFFFC0419.8 000000404 
FFFFFFFFFFFC041E.0 40341200F 		csrrw $x0,#$4034,$t0		; set tvec for debug mode
FFFFFFFFFFFC0422.8 FFFFF0050 		ldi		$t0,#$FFFFFFFFFFFC0200*2
FFFFFFFFFFFC0427.0 040000404 
FFFFFFFFFFFC042B.8 40331200F 		csrrw $x0,#$4033,$t0		; set tvec for machine mode
FFFFFFFFFFFC0430.0 FFFFF0150 		ldi		$t0,#UserStart
FFFFFFFFFFFC0434.8 08DC00404 
FFFFFFFFFFFC0439.0 40481200F 		csrrw	$x0,#$4048,$t0	  ; set mepc
FFFFFFFFFFFC043D.8 368401868 		sto   $t0,MEPC1
FFFFFFFFFFFC0442.0     0347B 	  ldi   $a0,#1            ; start task
FFFFFFFFFFFC0444.8     0157B 	  ldi   $a1,#0
FFFFFFFFFFFC0447.0     0167B 	  ldi   $a2,#0
FFFFFFFFFFFC0449.8 FFFFF0150 	  ldi   $a3,#UserStart2
FFFFFFFFFFFC044E.0 08EA01704 
FFFFFFFFFFFC0452.8     0187B 	  ldi   $a4,#$00
FFFFFFFFFFFC0455.0 01FE40141 	  bal   $x1,OSOCall
FFFFFFFFFFFC0459.8 10105600F 	  csrrw $x0,#CSR_TASKID,$a1
FFFFFFFFFFFC045E.0     2027B 	  csrrs $x0,#CSR_PMSTACK,#16 ; enable interrupts on return
FFFFFFFFFFFC0462.8 00100800F 
FFFFFFFFFFFC0465.0 10280000F 		csrrc $x0,#CSR_TRACECTRL,#0 ; turn off tracing
FFFFFFFFFFFC0469.8 000000045 		rte                       ; switch to user mode
;------------------------------------------------------------------------------
                        	; User mode code staret here
                        	; First thing to do is start a task so that the startup code may run on the
                        	; first task switch.
                        	;------------------------------------------------------------------------------
                        	;  align 	code
                        	UserStart:
FFFFFFFFFFFC046E.0     AE07C 	  call  DumpTraceQueue
FFFFFFFFFFFC0472.8 000000004 
FFFFFFFFFFFC0472.8 947B00007 	  wai                   ; wait for task switch
                        	UserStart2:
FFFFFFFFFFFC0475.0     1947B 	  ldi   $a0,#12         ; start app
FFFFFFFFFFFC0477.8 FFFFF1050 	  ldi   $a1,#SystemASR
FFFFFFFFFFFC047C.0 800001504 
FFFFFFFFFFFC0480.8 0003C0000 	  brk   #240
                        	.appBad:
FFFFFFFFFFFC0485.0     01479 	  bne   $a0,#0,.appBad
FFFFFFFFFFFC0487.8     6AB74 	  mov   $s1,$a1
FFFFFFFFFFFC048A.0     1D47B 	  ldi   $a0,#14         ; get current tid
FFFFFFFFFFFC048C.8 0003C0000 	  brk   #240            ; $a1 = task id
FFFFFFFFFFFC0491.0     3D47B 	  ldi   $a0,#30         ; set task's app id
FFFFFFFFFFFC0493.8     57674 	  mov   $a2,$s1         ; $a2 = app id
FFFFFFFFFFFC0496.0 0003C0000 	  brk   #240
                        	
FFFFFFFFFFFC049A.8     6AB74 	  mov   $s1,$a1         ; s1 = app id
FFFFFFFFFFFC049D.0 02801FF50 		ldi		$sp,#$A0080000*2-8*2  ; setup user mode stack pointer
FFFFFFFFFFFC04A1.8 FFF001E04 
                        	
FFFFFFFFFFFC04A6.0     1947B 	  ldi   $a0,#12         ; start app
FFFFFFFFFFFC04A8.8 FFFFF1050 	  ldi   $a1,#TinyBasicASR
FFFFFFFFFFFC04AD.0 811801504 
FFFFFFFFFFFC04B1.8 0003C0000 	  brk   #240
FFFFFFFFFFFC04B6.0     0347B 		ldi		$a0,#1          ; Start finalizer task, task #1
FFFFFFFFFFFC04B8.8     57574 		mov   $a1,$s1
FFFFFFFFFFFC04BB.0     0167B 		ldi		$a2,#0
FFFFFFFFFFFC04BD.8 000000050 		ldi		$a3,#Finalizer
FFFFFFFFFFFC04C2.0 F00000051 
FFFFFFFFFFFC04C6.8 01AF01704 
FFFFFFFFFFFC04CB.0     1787B 		ldi   $a4,#$0B        ; user mode, regset 11
FFFFFFFFFFFC04CD.8 0003C0000 		brk   #240
FFFFFFFFFFFC04D2.0     0347B 		ldi		$a0,#1          ; Start task for monitor, task #2
FFFFFFFFFFFC04D4.8     57574 		mov   $a1,$s1
FFFFFFFFFFFC04D7.0     0167B 		ldi		$a2,#0
FFFFFFFFFFFC04D9.8 FFFFF0250 		ldi		$a3,#MonEntry
FFFFFFFFFFFC04DE.0 10BA01704 
FFFFFFFFFFFC04E2.8     1587B 		ldi   $a4,#$0A        ; user mode, regset 10
FFFFFFFFFFFC04E5.0 0003C0000 		brk   #240
FFFFFFFFFFFC04E9.8     3347B 	  ldi   $a0,#25         ; map OS vars
FFFFFFFFFFFC04EC.0 0003C0000 	  brk   #240
FFFFFFFFFFFC04F0.8     6BC74 	  mov   $gp,$a1
                        	
                        	UserStart3:
FFFFFFFFFFFC04F3.0 02801FF50 		ldi		$sp,#$A0080000*2-8*2  	; setup user mode stack pointer
FFFFFFFFFFFC04F7.8 FFF001E04 
FFFFFFFFFFFC04FC.0     3147B 		ldi		$a0,#24							; RequestIOFocus
FFFFFFFFFFFC04FE.8     57574 		mov   $a1,$s1
FFFFFFFFFFFC0501.0 0003C0000 		brk   #240
                        	;	ldi		$sp,#$70000		      ; setup temporary user mode stack pointer
                        	;	mov   $a0,$a1             ; $a0 = tid
                        	;	call AllocStack
                        	;	add   $sp,$v1,#1020       ; place stack pointer at top of allocated region
FFFFFFFFFFFC0505.8     1047B 		ldi		$t0,#$08						; turn on the LED
FFFFFFFFFFFC0508.0 FFFE44050 		stt		$t0,VIA+VIA_PARAW
FFFFFFFFFFFC050C.8 200403C68 
FFFFFFFFFFFC0511.0     2067B 		ldi		$t2,#16							; send an XON just in case
FFFFFFFFFFFC0513.8     2377B 		ldi		$a3,#XON
                        	.0004:
FFFFFFFFFFFC0516.0 E6708D141 		bal   $x1,Putch ;SerialPutChar
FFFFFFFFFFFC0518.8     FE675 		sub		$t2,$t2,#1
FFFFFFFFFFFC051B.0     EC679 		bne	  $t2,#0,.0004
                        	.0002:
                        	;  ldi   $a0,#25             ; Map OS vars
                        	;  brk #240
                        	;  mov   $gp,$a1
                        	  ; Request that the idle task announce itself.
                        	;  ldi   $a0,#9              ; SendMsg
                        	;  ldwu  $a1,IdleTaskMbx[$gp]
                        	;  beqz  $a1,.noMbx
                        	;  ldi   $a2,#MT_ANNOUNCE
                        	;  ldi   $a3,#0
                        	;  ldi   $a4,#0
                        	;  brk #240
                        	.noMbx:
FFFFFFFFFFFC051D.8 FFFFF1050 		ldi		$a0,#msgStart				; spit out a startup message
FFFFFFFFFFFC0522.0 823001404 
FFFFFFFFFFFC0526.8 00043E141 		bal   $x1,PutString
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		brk #240
FFFFFFFFFFFC052B.0 01FDD8141 		bal   $x1,DumpReadyQueue
FFFFFFFFFFFC052F.8     96C7A 		bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#9							; peekchar function
                        	;	brk #240
                        	;	mov   $v0,$v1
                        	;	bltz	$v1,.0003
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#8							; getchar function
                        	;	brk #240
                        	;	mov		$a3,$v1
                        	;	mov   $a0,$a3
                        	;	call PutHexByte
                        	;	bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	; This task runs only if nothing else can run. It must run at the machine
                        	; operating mode.
                        	; Search for ready tasks and add them back into the ready queue.
                        	;------------------------------------------------------------------------------
                        	;  align 	code
                        	IdleTask:
FFFFFFFFFFFC0532.0     0D47B 	  ldi   $a0,#6                ; alloc mailbox
FFFFFFFFFFFC0534.8     0157B 	  ldi   $a1,#0                ; app #0
FFFFFFFFFFFC0537.0 0003C0000 	  brk   #240
FFFFFFFFFFFC053B.8 000000150 	  stw   $a1,IdleTaskMbx[$gp]  ; save mailbox handle off
FFFFFFFFFFFC0540.0 181571068 
                        	.loop2:
FFFFFFFFFFFC0544.8 400000404 	  ldi   $t0,#$4000
FFFFFFFFFFFC0549.0     0257B 	  ldi   $t1,#1
                        	.loop:
FFFFFFFFFFFC054B.8     1747B 	  ldi   $a0,#11               ; PeekMsg
FFFFFFFFFFFC054E.0 000000150 	  ldwu  $a1,IdleTaskMbx[$gp]
FFFFFFFFFFFC0552.8 1C1071564 
FFFFFFFFFFFC0557.0 0C1801604 	  ldi   $a2,#IdleTaskMsgD1
FFFFFFFFFFFC055B.8 0C2001704 	  ldi   $a3,#IdleTaskMsgD2
FFFFFFFFFFFC0560.0 0C2801804 	  ldi   $a4,#IdleTaskMsgD3
FFFFFFFFFFFC0564.8     0397B 	  ldi   $a5,#1                ; remove from queue if present
                        	;  brk #240
                        	;  bnez  $a0,.noMsg
                        	;  ldt   $a0,IdleTaskMsgD1
                        	;  xor   $t1,$a0,#MT_ANNOUNCE
                        	;  bnez  $t1,.noAnnounce
                        	;  ldi   $a0,#msgIdleAnnounce
                        	;  call PutString
                        	.noAnnounce:
                        	.noMsg:
FFFFFFFFFFFC0567.0     2347B 	  ldi   $a0,#17               ; run as OS
FFFFFFFFFFFC0569.8 FFFFF0150 	  ldi   $a1,#.IdleCode
FFFFFFFFFFFC056E.0 0B1801504 
FFFFFFFFFFFC0572.8     49674 	  mov   $a2,$t0
FFFFFFFFFFFC0575.0 0003C0000 	  brk   #240
FFFFFFFFFFFC0579.8 100010404 	  add   $t0,$t0,#PAGESZ
FFFFFFFFFFFC057E.0 072700050 	  sne   $t3,$t0,#MEMSZ*PAGESZ
FFFFFFFFFFFC0582.8 CD4F00001 
FFFFFFFFFFFC0585.0 FFC01CD4F 	  bne   $t3,#0,.loop
FFFFFFFFFFFC0589.8     DD87A 		bra		.loop2
                        	  ; This section of code runs as part of the OS
                        	  ; Don't callany functions though as there's no stack available
                        	.IdleCode:
FFFFFFFFFFFC058C.0 200058460 	  ldt   $t0,OBJMagic[$a2]
FFFFFFFFFFFC0590.8 0727A8850 	  sne   $t3,$t0,#TCB_MAGIC
FFFFFFFFFFFC0595.0 ED4043421 
FFFFFFFFFFFC0597.8 00409ED4F 	  bne   $t3,#0,.nxtObj
FFFFFFFFFFFC059C.0 02E018764 	  ldbu  $t3,TCBStatus[$t2]    ; get status
FFFFFFFFFFFC05A0.8     02776 	  and  	$t3,$t3,#TS_READY
FFFFFFFFFFFC05A3.0 00409D64F 	  bne   $t3,#0,.nxtObj
                        	  ; The task was ready, but not found in the ready queue. So add it
FFFFFFFFFFFC05A7.8 440C59402 	  srl   $a0,$a2,#LOG_PGSZ
                        	  
FFFFFFFFFFFC05AC.0 00100400F 	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	
FFFFFFFFFFFC05B0.8 020A50402 		asl   $t0,$a0,#LOG_TCBSZ
FFFFFFFFFFFC05B5.0 02E010564 		ldbu	$t1,TCBStatus[$t0]	; set status to ready
FFFFFFFFFFFC05B9.8     02577 		or		$t1,$t1,#TS_READY
FFFFFFFFFFFC05BC.0 058512068 		stb		$t1,TCBStatus[$t0]
FFFFFFFFFFFC05C0.8 02E110560 		ldb		$t1,TCBPriority[$t0]
FFFFFFFFFFFC05C5.0 100550007 		pushq	$a0,$t1
                        	
FFFFFFFFFFFC05C9.8 00100400F 	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
                        	.nxtObj:
FFFFFFFFFFFC05CE.0     0147B 	  ldi   $a0,#E_Ok
FFFFFFFFFFFC05D0.8 01FD87841 	  bra   OSExit
                        	
                        		align	1
                        	msgIdleAnnounce:
FFFFFFFFFFFC05D5.0 0656C6449 	  db  "Idle task running.",CR,0
FFFFFFFFFFFC05D9.8 6B7361742 
FFFFFFFFFFFC05DE.0 E6E757220 
FFFFFFFFFFFC05E2.8 2E676E696 
FFFFFFFFFFFC05E7.0 00000000D 
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	;  align 	code
FFFFFFFFFFFC05E9.0 000000000 		align		16
FFFFFFFFFFFC05ED.8 557B00000 
                        	_Delay2s:
                        	ifdef TEST
FFFFFFFFFFFC05F0.0     1557B 	  ldi     $a1,#10
                        	else
                        		ldi			$a1,#3000000
                        	endif
                        	.0001:
FFFFFFFFFFFC05F2.8 441055602 		srl			$a2,$a1,#16
FFFFFFFFFFFC05F7.0 FFFE44050 		stb			$a2,LEDS
FFFFFFFFFFFC05FB.8 001600068 
FFFFFFFFFFFC0600.0     FF575 		sub 		$a1,$a1,#1
FFFFFFFFFFFC0602.8 FFC1D604B 		bgeu	  $a1,#1,.0001
FFFFFFFFFFFC0607.0     02074 		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		$a0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC0609.8 000000000 		align		16
FFFFFFFFFFFC060E.0 FDE750000 
                        	Getch:
FFFFFFFFFFFC0610.0     FDE75 		sub		$sp,$sp,#16
FFFFFFFFFFFC0612.8     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0615.0     03E73 		sto		$a1,8[$sp]
FFFFFFFFFFFC0617.8     0B57B 		ldi   $a1,#5  ;CURIN
FFFFFFFFFFFC061A.0 3E70FF941 		bal		$x1,fgetc
FFFFFFFFFFFC061C.8     03E71 		ldo		$a1,8[$sp]
FFFFFFFFFFFC061F.0     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC0621.8     05E75 		add   $sp,$sp,#16
FFFFFFFFFFFC0624.0     02074 		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = character to put
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	_putch:
FFFFFFFFFFFC0626.8     6CC7A 	  bra   dbg_Putch
FFFFFFFFFFFC0629.0 000000000 		align		16
FFFFFFFFFFFC062D.8 807A00000 
                        	Putch:
FFFFFFFFFFFC0630.0     6807A 	  bra   dbg_Putch
FFFFFFFFFFFC0632.8     FBE75 		sub		$sp,$sp,#24
FFFFFFFFFFFC0635.0     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0637.8     03E73 		sto		$a3,8[$sp]
FFFFFFFFFFFC063A.0     05E73 		sto		$a1,16[$sp]
FFFFFFFFFFFC063C.8     69774 		mov		$a3,$a0
FFFFFFFFFFFC063F.0     0B57B 		ldi		$a1,#5  ;CUROUT    ; serial port
FFFFFFFFFFFC0641.8 1E71C4141 		bal		$x1,fputc
FFFFFFFFFFFC0644.0     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC0646.8     03E71 		ldo		$a3,8[$sp]
FFFFFFFFFFFC0649.0     05E71 		ldo		$a1,16[$sp]
FFFFFFFFFFFC064B.8     07E75 		add   $sp,$sp,#24
FFFFFFFFFFFC064E.0     02074 		ret
                        	
FFFFFFFFFFFC0650.8 000000000 		align		16
FFFFFFFFFFFC0655.0 000000000 
FFFFFFFFFFFC0659.8 000000000 
FFFFFFFFFFFC065E.0 000500000 
                        	calcScreenPos:
FFFFFFFFFFFC0660.0 FFFD00050 	  ldbu  $t0,_cursorY
FFFFFFFFFFFC0664.8 000900464 
FFFFFFFFFFFC0669.0 005D9CA4B 	  bgeu  $t3,#29,.0001
                        	.0002:
FFFFFFFFFFFC066D.8 007010515 	  mulf  $t1,$t0,#56*2
FFFFFFFFFFFC0672.0 FFFD00050 	  ldbu  $t0,_cursorX
FFFFFFFFFFFC0676.8 000800464 
FFFFFFFFFFFC067B.0 00789024B 	  bgeu  $t0,#56,.0003
                        	.0004:
FFFFFFFFFFFC067F.8     88574 	  add   $t1,$t1,$t0
FFFFFFFFFFFC0682.0     0857C 	  sll   $t1,$t1,#4			; 16 nybbles
FFFFFFFFFFFC0684.8 460400050 	  add   $t2,$t1,#TEXTSCR
FFFFFFFFFFFC0689.0 207000001 
FFFFFFFFFFFC068B.8     02074 	  ret
                        	; This is cool in ANY1. Storing a smalll constant to memory does not require
                        	; the use of a source register. This allows the LDI and the STB to proceed
                        	; in parallel. The store does not need to wait for a register.
                        	.0001:
FFFFFFFFFFFC068E.0     3847B 	  ldi   $t0,#28
FFFFFFFFFFFC0690.8 FFFD00050 	  stb   #28,_cursorY
FFFFFFFFFFFC0695.0 005C00968 
FFFFFFFFFFFC0699.8     EA07A 	  bra   .0002
                        	.0003:
FFFFFFFFFFFC069C.0     6E47B 	  ldi   $t0,#55
FFFFFFFFFFFC069E.8 FFFD00050 	  stb   $t0,_cursorX
FFFFFFFFFFFC06A3.0 000400868 
FFFFFFFFFFFC06A7.8     EC07A 	  bra   .0004
                        	
FFFFFFFFFFFC06AA.0 000000000 		align		16
FFFFFFFFFFFC06AE.8 D00050000 
                        	incScreenPos:
FFFFFFFFFFFC06B0.0 FFFD00050 	  ldbu  $t0,_cursorX
FFFFFFFFFFFC06B4.8 000800464 
FFFFFFFFFFFC06B9.0     02475 	  add   $t0,$t0,#1
FFFFFFFFFFFC06BB.8 00789304A 	  bltu  $t0,#56,.0001
FFFFFFFFFFFC06C0.0 FFFD00050 	  stb   #0,_cursorX
FFFFFFFFFFFC06C4.8 004000868 
FFFFFFFFFFFC06C9.0 FFFD00050 	  ldbu  $t0,_cursorY
FFFFFFFFFFFC06CD.8 000900464 
FFFFFFFFFFFC06D2.0     02475 	  add   $t0,$t0,#1
FFFFFFFFFFFC06D4.8 005D1274A 	  bltu  $t0,#29,.0002
FFFFFFFFFFFC06D9.0     FFE75 	  sub		$sp,$sp,#8
FFFFFFFFFFFC06DB.8     01E73 	  sto		$x1,[$sp]
FFFFFFFFFFFC06DE.0 1E7041141 	  bal		$x1,dbg_ScrollUp
FFFFFFFFFFFC06E0.8     01E71 	  ldo		$x1,[$sp]
FFFFFFFFFFFC06E3.0     03E75 	  add		$sp,$sp,#8
FFFFFFFFFFFC06E5.8     02074 	  ret
                        	.0002:
FFFFFFFFFFFC06E8.0 FFFD00050 	  stb   $t0,_cursorY
FFFFFFFFFFFC06EC.8 000400968 
FFFFFFFFFFFC06F1.0     02074 	  ret
                        	.0001:
FFFFFFFFFFFC06F3.8 FFFD00050 	  stb   $t0,_cursorX
FFFFFFFFFFFC06F8.0 000400868 
FFFFFFFFFFFC06FC.8     02074 	  ret
                        	  
FFFFFFFFFFFC06FF.0 73FFE7500 		align		16
                        	dbg_Putch:
FFFFFFFFFFFC0700.0     FFE75 		sub		$sp,$sp,#8
FFFFFFFFFFFC0702.8     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0705.0 00CD5184E 	  beq  	$a0,#CR,.cr
FFFFFFFFFFFC0709.8 004AD064E 	  beq  	$a0,#LNFD,.lf
FFFFFFFFFFFC070E.0 FFFD00050 	  ldo   $t3,_DBGAttr
FFFFFFFFFFFC0712.8 300000760 
FFFFFFFFFFFC0717.0 020750702 	  or    $t3,$a0,$t3
FFFFFFFFFFFC071B.8 8068A2541 	  bal		$x1,calcScreenPos
FFFFFFFFFFFC071E.0 300718068 	  sto   $t3,[$t2]
FFFFFFFFFFFC0722.8 1E71C6D41 	  bal		$x1,incScreenPos
                        	.xit:
FFFFFFFFFFFC0725.0     01E71 	  ldo		$x1,[$sp]
FFFFFFFFFFFC0727.8     03E75 		add		$sp,$sp,#8
FFFFFFFFFFFC072A.0     02074 	  ret
                        	 .lf:
FFFFFFFFFFFC072C.8 FFFD00050 	  stb   #0,_cursorX
FFFFFFFFFFFC0731.0 004000868 
FFFFFFFFFFFC0735.8 FFFD00050 	  ldbu  $a0,_cursorY
FFFFFFFFFFFC073A.0 000901464 
FFFFFFFFFFFC073E.8     03475 	  add   $a0,$a0,#1
FFFFFFFFFFFC0741.0 005D53E4B 	  bgeu  $a0,#29,dbg_ScrollUp
FFFFFFFFFFFC0745.8 FFFD00050 	  stb   $a0,_cursorY
FFFFFFFFFFFC074A.0 001400968 
FFFFFFFFFFFC074E.8     EB47A 	  bra		.xit
                        	.cr:
FFFFFFFFFFFC0751.0 FFFD00050 	  stb   #0,_cursorX
FFFFFFFFFFFC0755.8 004000868 
FFFFFFFFFFFC075A.0     E587A 	  bra		.xit
                        	
FFFFFFFFFFFC075C.8 750000000 		align		16
                        	dbg_ScrollUp:
FFFFFFFFFFFC0760.0     FFE75 		sub		$sp,$sp,#8
FFFFFFFFFFFC0762.8     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0765.0 FFFE00050 	  ldi   $t0,#TEXTSCR
FFFFFFFFFFFC0769.8 000000404 
                        	ifdef TEST
FFFFFFFFFFFC076E.0     0C57B 	  ldi   $t1,#6
                        	else
                        	  ldi   $t1,#56*28*2
                        	endif
                        	.0001:
FFFFFFFFFFFC0770.8 338010660 	  ldo   $t2,56*8*2[$t0]
FFFFFFFFFFFC0775.0     FE575 	  sub  	$t1,$t1,#1      ; placed here eliminates pipeline bubble
FFFFFFFFFFFC0777.8 300610068 	  sto   $t2,[$t0]
FFFFFFFFFFFC077C.0     20475 	  add   $t0,$t0,#16
FFFFFFFFFFFC077E.8     C8579 	  bne   $t1,#0,.0001
FFFFFFFFFFFC0781.0 1E7007941 	  bal		$x1,dbg_BlankLastLine
FFFFFFFFFFFC0783.8     01E71 	  ldo		$x1,[$sp]
FFFFFFFFFFFC0786.0     03E75 		add		$sp,$sp,#8
FFFFFFFFFFFC0788.8     02074 		ret
                        	
FFFFFFFFFFFC078B.0 000000000 		align		16
FFFFFFFFFFFC078F.8 FFE001500 
                        	dbg_BlankLastLine:
FFFFFFFFFFFC0790.0 FFFE00150 	  ldi   $t0,#TEXTSCR+56*28*2
FFFFFFFFFFFC0794.8 0C4000404 
FFFFFFFFFFFC0799.0 006E00504 	  ldi   $t1,#55*2
FFFFFFFFFFFC079D.8     0067B 	  ldi   $t2,_DBGAttr
  or    $t2,$t2,#' '
FFFFFFFFFFFC07A2.0     40677 
                        	.0001:
FFFFFFFFFFFC07A2.8 000014058 	  sto   $t2,[$t0+$t1*8]
FFFFFFFFFFFC07A7.0 360610069 
FFFFFFFFFFFC07AB.8     FC575 	  sub  	$t1,$t1,#2
FFFFFFFFFFFC07AE.0 FFC29694B 	  bgeu  $t1,#2,.0001
FFFFFFFFFFFC07B2.8     02074 	  ret
                        	
                        	  ; align cache
                        	dbg_HomeCursor:
FFFFFFFFFFFC07B5.0 FFFD00050 	  stb   #0,_cursorX
FFFFFFFFFFFC07B9.8 004000868 
FFFFFFFFFFFC07BE.0 FFFD00050 	  stb   #0,_cursorY
FFFFFFFFFFFC07C2.8 004000968 
FFFFFFFFFFFC07C7.0     02074 	  ret
                        	  
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   EOF if error occurred, otherwise character to put
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	fputc:
FFFFFFFFFFFC07C9.8     F9E75 		sub		$sp,$sp,#32
FFFFFFFFFFFC07CC.0     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC07CE.8     05E73 		sto		$a1,16[$sp]
FFFFFFFFFFFC07D1.0     07E73 		sto		$a2,24[$sp]
FFFFFFFFFFFC07D3.8 004268400 		seq   $t0,$a6,#'B'
FFFFFFFFFFFC07D8.0     26478 		beq   $t0,#0,.noBypass
FFFFFFFFFFFC07DA.8 01FC88941 		bal		$x1,SerialPutChar
FFFFFFFFFFFC07DF.0     1447A 		bra   .xit
                        	.noBypass:
                        		; If the device is a UI device there may be multiple owning jobs. It doesn't
                        		; do any good to check for ownership. Instead the I/O focus is checked to
                        		; see if it's present.
FFFFFFFFFFFC07E1.8 01FC85941 		bal		$x1,GetUIFlag
FFFFFFFFFFFC07E6.0     31579 		bne   $a1,#0,.checkOwner
FFFFFFFFFFFC07E8.8     05E71 	  ldo   $a1,16[$sp]
FFFFFFFFFFFC07EB.0 01FC81541 		bal		$x1,WaitForIOFocus
FFFFFFFFFFFC07EF.8     04C7A 		bra   .0001
                        	.checkOwner:
FFFFFFFFFFFC07F2.0 01FC7E541 	  bal		$x1,CheckDevOwner
FFFFFFFFFFFC07F6.8     77479 	  bne   $a0,#0,.notOwner
                        	.0001:
FFFFFFFFFFFC07F9.0     05E71 	  ldo   $a1,16[$sp]
FFFFFFFFFFFC07FB.8     3547B 		ldi		$a0,#26							; FMTK_IO
FFFFFFFFFFFC07FE.0     1B67B 		ldi		$a2,#13							; putchar function
FFFFFFFFFFFC0800.8 0003C0000 		brk   #240
FFFFFFFFFFFC0805.0     6F474 		mov   $a0,$a3
                        	.xit:
FFFFFFFFFFFC0807.8     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC080A.0     05E71 		ldo		$a1,16[$sp]
FFFFFFFFFFFC080C.8     07E71 		ldo		$a2,24[$sp]
FFFFFFFFFFFC080F.0     09E75 		add   $sp,$sp,#32
FFFFFFFFFFFC0811.8     02074 		ret
                        	.notOwner:
FFFFFFFFFFFC0814.0     3547B 	  ldi   $a0,#EOF
FFFFFFFFFFFC0816.8     F887A 	  bra   .xit
                        	 
                        	;------------------------------------------------------------------------------
                        	; fgetc - get a character from an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		4 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device getchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		a0 character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	fgetc:
FFFFFFFFFFFC0819.0     F9E75 		sub		$sp,$sp,#32
FFFFFFFFFFFC081B.8     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC081E.0     05E73 		sto		$a1,16[$sp]
FFFFFFFFFFFC0820.8     07E73 		sto		$a2,24[$sp]
FFFFFFFFFFFC0823.0 01FC64D41 		bal		$x1,GetUIFlag
FFFFFFFFFFFC0827.8     31578 		beq   $a1,#0,.checkOwner
FFFFFFFFFFFC082A.0     05E71 		ldt		$a1,16[$sp]
FFFFFFFFFFFC082C.8 01FC60941 		bal		$x1,WaitForIOFocus
FFFFFFFFFFFC0831.0     0607A 		bra   .0001
                        	.checkOwner:
FFFFFFFFFFFC0833.8     05E71 		ldt		$a1,16[$sp]
FFFFFFFFFFFC0836.0 01FC5C541 	  bal		$x1,CheckDevOwner
FFFFFFFFFFFC083A.8     77479 	  bne   $a0,#0,.notOwner
                        	.0001:
FFFFFFFFFFFC083D.0     3547B 		ldi		$a0,#26							; FMTK_IO
FFFFFFFFFFFC083F.8     05E71 		ldt		$a1,16[$sp]
FFFFFFFFFFFC0842.0     1167B 		ldi		$a2,#8							; getchar function
FFFFFFFFFFFC0844.8 0003C0000 		brk   #240
FFFFFFFFFFFC0849.0     6B474 		mov   $a0,$a1
                        	.0002:
FFFFFFFFFFFC084B.8     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC084E.0     05E71 		ldo		$a1,16[$sp]
FFFFFFFFFFFC0850.8     07E71 		ldo		$a2,24[$sp]
FFFFFFFFFFFC0853.0     09E75 		add   $sp,$sp,#32
FFFFFFFFFFFC0855.8     02074 		ret
                        	.notOwner:
FFFFFFFFFFFC0858.0     FF47B 	  ldi   $a0,#-1
FFFFFFFFFFFC085A.8     F887A 	  bra   .0002
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFFFFFFFFFC085D.0     1547B 			ldi		$a0,#10
FFFFFFFFFFFC085F.8     0D67B 			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	  ; align cache
                        	Monitor:
                        	.getFocus:
                        	;	ldi   $a0,#20       ; has IO focus
                        	;	brk #240
                        	;	bnez  $v1,.hasFocus
                        	;	ldi   $a0,#21       ; switch focus
                        	;	brk #240
                        	;	bra   .getFocus
                        	.hasFocus:
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFFFFFFFFFC0862.0     00B7B 		ldi		  $s1,#0					; s1 = input pointer
FFFFFFFFFFFC0864.8 FFFFF1050 		ldi			$a0,#msgPrompt
FFFFFFFFFFFC0869.0 846801404 
FFFFFFFFFFFC086D.8 01419A941 		bal   	$x1,PutString
                        	.0001:
FFFFFFFFFFFC0870.0 3B40D0141 		bal   	$x1,Getch						; wait until character pressed
FFFFFFFFFFFC0872.8 FFC0D3B48 		blt	    $a0,#0,.0001	; test return value
FFFFFFFFFFFC0877.0 00CAD1F4E 		beq			$a0,#LNFD,.procLine	; process line feed
FFFFFFFFFFFC087B.8 00CDD164E 		beq			$a0,#CR,.procLine	; and carriage return
FFFFFFFFFFFC0880.0 0048D394E 		beq	    $a0,#BS,.doBackspace
FFFFFFFFFFFC0884.8 007F00404 		ldi			$t0,#DEL
FFFFFFFFFFFC0889.0 00045214E 		beq		  $a0,$t0,.doDelete
FFFFFFFFFFFC088D.8 02142C068 		stb		  $a0,INBUF[$s1]
FFFFFFFFFFFC0892.0     04B75 		add		  $s1,$s1,#2
FFFFFFFFFFFC0894.8 C87ACDD41 		bal  		$x1,Putch
FFFFFFFFFFFC0897.0     EC87A 		bra		  .0001
                        	.doDelete:
FFFFFFFFFFFC0899.8     56C74 		mov		  $s2,$s1
FFFFFFFFFFFC089C.0     04C75 		add		  $s2,$s2,#2
                        	.0002:
FFFFFFFFFFFC089E.8 010030460 		ldb		  $t0,INBUF[$s2]
FFFFFFFFFFFC08A3.0 018433E68 		stb		  $t0,INBUF-2[$s2]
FFFFFFFFFFFC08A7.8     04C75 		add		  $s2,$s2,#2
FFFFFFFFFFFC08AA.0 010030404 		add		  $t0,$s2,#INBUF
FFFFFFFFFFFC08AE.8 01FE10528 		slt		  $t1,$t0,#INBUF+$7F*2
FFFFFFFFFFFC08B3.0     AE579 		bne		  $t1,#0,.0002
FFFFFFFFFFFC08B5.8 024030068 		stb		  #0,INBUF[$s2]
FFFFFFFFFFFC08BA.0     DB07A 		bra		  .0001
                        	.doBackspace:
FFFFFFFFFFFC08BC.8 FF40AE74E 		beq		  $s1,#0,.0001    ; can't backspace anymore
FFFFFFFFFFFC08C1.0 CB70B7941 		bal   	$x1,Putch       ; show the backspace
FFFFFFFFFFFC08C3.8     FCB75 		sub		  $s1,$s1,#2
FFFFFFFFFFFC08C6.0     56C74 		mov		  $s2,$s1
                        	.0003:
FFFFFFFFFFFC08C8.8 010230460 		ldb		  $t0,INBUF+2[$s2]
FFFFFFFFFFFC08CD.0 020430068 		stb		  $t0,INBUF[$s2]
FFFFFFFFFFFC08D1.8     04C75 		add		  $s2,$s2,#2
FFFFFFFFFFFC08D4.0 010030404 		add		  $t0,$s2,#INBUF
FFFFFFFFFFFC08D8.8 01FE10528 		slt		  $t1,$t0,#INBUF+$7F*2
FFFFFFFFFFFC08DD.0     AE579 		bne		  $t1,#0,.0003
FFFFFFFFFFFC08DF.8 024030068 		stb		  #0,INBUF[$s2]
FFFFFFFFFFFC08E4.0     C607A 		bra		  .0001
                        	.procLine:
FFFFFFFFFFFC08E6.8 02402C068 		stb		  #0,INBUF[$s1]
FFFFFFFFFFFC08EB.0     00B7B 		ldi		  $s1,#0
                        	.skip:
FFFFFFFFFFFC08ED.8 01002C460 		ldb	  	$t0,INBUF[$s1]
FFFFFFFFFFFC08F2.0 02C010E4E 		beq		  $t0,#0,.0005
FFFFFFFFFFFC08F6.8     7C57B 		ldi			$t1,#'>'
FFFFFFFFFFFC08F9.0 00051134F 		bne		  $t0,$t1,.0004
                        	.skip2:
FFFFFFFFFFFC08FD.8     04B75 		add		  $s1,$s1,#2
FFFFFFFFFFFC0900.0     F6C7A 		bra		  .skip
                        	.0004:
FFFFFFFFFFFC0902.8     4057B 		ldi			$t1,#' '
FFFFFFFFFFFC0905.0 FF859314E 		beq			$t0,$t1,.skip2
FFFFFFFFFFFC0909.8     1257B 		ldi			$t1,#'\t'
FFFFFFFFFFFC090C.0 FF859234E 		beq			$t0,$t1,.skip2
FFFFFFFFFFFC0910.8 007800504 		ldi			$t1,#'x'
FFFFFFFFFFFC0915.0 00051174F 		bne     $t0,$t1,.notX
FFFFFFFFFFFC0919.8     0147B 		ldi     $a0,#E_Ok
FFFFFFFFFFFC091C.0 01FBE1C41 		bra     OSExit
                        	.notX:
FFFFFFFFFFFC0920.8 004D00504 		ldi			$t1,#'M'
FFFFFFFFFFFC0925.0 020512D4E 		beq			$t0,$t1,doMem
FFFFFFFFFFFC0929.8 005600504 		ldi			$t1,#'V'
FFFFFFFFFFFC092E.0 03851034E 		beq     $t0,$t1,doVMem
FFFFFFFFFFFC0932.8 005000504 		ldi			$t1,#'P'
FFFFFFFFFFFC0937.0 00007DC5A 		beq     $t0,$t1,doPState
FFFFFFFFFFFC093B.8 EF851064E 
FFFFFFFFFFFC0940.0 004200504 		ldi			$t1,#'B'
FFFFFFFFFFFC0944.8 008590F4E 		beq		  $t0,$t1,.0006
FFFFFFFFFFFC0949.0 D47093541 		bal   	$x1,GetDecNum
FFFFFFFFFFFC094B.8     1D479 		bne     $a0,#0,.basSize
FFFFFFFFFFFC094E.0 7D0001404 		ldi     $a0,#32000
                        	.basSize:
FFFFFFFFFFFC0952.8     1947B 		ldi		  $a0,#12					; Start App
FFFFFFFFFFFC0955.0 000000050 		ldi     $a1,#TBASR
FFFFFFFFFFFC0959.8 F00000051 
FFFFFFFFFFFC095E.0 01F801504 
FFFFFFFFFFFC0962.8 0003C0000 		brk     #240
FFFFFFFFFFFC0967.0     6AB74 		mov		  $s1,$a1					; save v1
FFFFFFFFFFFC0969.8 747411541 		bal   	$x1,PutCRLF
FFFFFFFFFFFC096C.0     57474 		mov		  $a0,$s1					; get back v1
FFFFFFFFFFFC096E.8 1050BA141 		bal   	$x1,PutHexByte
FFFFFFFFFFFC0971.0 FFFFF1050 		ldi		  $a0,#msgTaskStart
FFFFFFFFFFFC0975.8 844601404 
FFFFFFFFFFFC097A.0 F54014541 		bal   	$x1,PutString
FFFFFFFFFFFC097C.8 01FBAF541 		bal   	$x1,DumpReadyQueue
                        		; The monitor is running in machine mode. A return instruction is used to
                        		; switch to user mode. The return address must be set to the desired user
                        		; code address.
                        		
FFFFFFFFFFFC0981.0 00100400F 	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	; disable interrupts
FFFFFFFFFFFC0985.8 000000050 		ldi     $t0,#CSTART       ; pick start of Tiny Basic
FFFFFFFFFFFC098A.0 F00000051 
FFFFFFFFFFFC098E.8 01FC00404 
FFFFFFFFFFFC0993.0 03411200F 		csrrw   $x0,#$341,$t0     ; set as return address
FFFFFFFFFFFC0997.8 000002250 		ldi     $t0,#$00011111    ; bits to select register set #1
FFFFFFFFFFFC099C.0 111100404 
FFFFFFFFFFFC09A0.8 50121200F 		csrrw   $x0,#CSR_REGSET,$t0     ; select register set #1 (will decrement to zero then on mret)
FFFFFFFFFFFC09A5.0 000000045 		rte                     ; will begin running Tiny Basic in user mode
	;ldi		$a0,#5					; Reschedule task
                        		;ldi		$a1,#1					; sleep(0)
                        		;brk #240
FFFFFFFFFFFC09A9.8     5C47A 		bra		  Monitor
                        	.0006:
FFFFFFFFFFFC09AC.0 004400504 		ldi			$t1,#'D'
FFFFFFFFFFFC09B0.8 00059004F 		bne		  $t0,$t1,.0007
FFFFFFFFFFFC09B5.0 01022C460 		ldb		  $t0,INBUF+2[$s1]
FFFFFFFFFFFC09B9.8 005400504 		ldi			$t1,#'T'
FFFFFFFFFFFC09BE.0 00051174F 		bne		  $t0,$t1,.noT
FFFFFFFFFFFC09C2.8 01FB9E941 		bal   	$x1,DumpTimeoutList
FFFFFFFFFFFC09C7.0     4D87A 		bra		  Monitor
                        	.noT:
FFFFFFFFFFFC09C9.8 01FB88D41 		bal   	$x1,DumpReadyQueue
                        		;ldi		$a0,#15
                        		;brk #240
FFFFFFFFFFFC09CE.0     4A07A 		bra		  Monitor
                        	.0007:
FFFFFFFFFFFC09D0.8 004500504 		ldi			$t1,#'E'
FFFFFFFFFFFC09D5.0 02051134E 		beq		  $t0,$t1,EditMem
FFFFFFFFFFFC09D9.8 004600504 		ldi			$t1,#'F'
FFFFFFFFFFFC09DE.0 00051334F 		bne		  $t0,$t1,.0009
FFFFFFFFFFFC09E2.8 01022C460 		ldb     $t0,INBUF+2[$s1]
FFFFFFFFFFFC09E7.0 004900504 		ldi			$t1,#'I'
FFFFFFFFFFFC09EB.8 00051134F 		bne			$t0,$t1,.notFind
FFFFFFFFFFFC09F0.0     04B75 		add     $s1,$s1,#2
FFFFFFFFFFFC09F2.8     BF07A 		bra     Find
                        	.notFind:
FFFFFFFFFFFC09F5.0     ABC7A 		bra		  FillMem
                        	.0009:
FFFFFFFFFFFC09F7.8 005300504 		ldi			$t1,#'S'
FFFFFFFFFFFC09FC.0 00051214F 		bne		  $t0,$t1,.0010
FFFFFFFFFFFC0A00.8     0B47B 		ldi		  $a0,#5					; sleep(0)
FFFFFFFFFFFC0A03.0     0357B 		ldi		  $a1,#1
FFFFFFFFFFFC0A05.8 0003C0000 		brk     #240
FFFFFFFFFFFC0A0A.0     2C07A 		bra		  Monitor
                        	.0010:
FFFFFFFFFFFC0A0C.8 004B00504 		ldi			$t1,#'K'
FFFFFFFFFFFC0A11.0 00051264F 		bne		  $t0,$t1,.0011
FFFFFFFFFFFC0A15.8 9574F8D41 		bal     $x1,GetHexNum
FFFFFFFFFFFC0A18.0     69574 		mov		  $a1,$a0					; a0 = pid
FFFFFFFFFFFC0A1A.8     0747B 		ldi		  $a0,#3					; kill task
FFFFFFFFFFFC0A1D.0 0003C0000 		brk     #240
FFFFFFFFFFFC0A21.8     2047A 		bra		  Monitor
                        	.0011:
FFFFFFFFFFFC0A24.0     7E57B 		ldi			$t1,#'?'
FFFFFFFFFFFC0A26.8 00051254F 		bne		  $t0,$t1,.0012
FFFFFFFFFFFC0A2B.0 FFFFF1050 		ldi		  $a0,#msgMonHelp
FFFFFFFFFFFC0A2F.8 826201404 
FFFFFFFFFFFC0A34.0 5C70B7541 		bal    	$x1,PutString
FFFFFFFFFFFC0A36.8     15C7A 		bra		  Monitor
                        	.0012:
                        	.0005:
FFFFFFFFFFFC0A39.0     1487A 		bra		  Monitor
                        	
                        	  ; align cache
                        	doMem:
FFFFFFFFFFFC0A3B.8     FFE75 		sub		$sp,$sp,#8
FFFFFFFFFFFC0A3E.0     04B75 		add		$s1,$s1,#2
FFFFFFFFFFFC0A40.8 01002C460 		ldb		$t0,INBUF[$s1]
FFFFFFFFFFFC0A45.0 00003C427 		sne   $t0,#'O'
                        		bt    .0001
FFFFFFFFFFFC0A49.8     04B75 		add		$s1,$s1,#2
                        	.0001:
FFFFFFFFFFFC0A4C.0     01E73 		sto		$s1,[$sp]
FFFFFFFFFFFC0A4E.8     1B47B 		ldi		$a0,#CR
FFFFFFFFFFFC0A51.0 1400EF941 		bal   $x1,Putch
FFFFFFFFFFFC0A53.8 010001404 		ldi		$a0,#INBUF
FFFFFFFFFFFC0A58.0 1E70A5541 		bal   $x1,PutString
FFFFFFFFFFFC0A5A.8     01E71 		ldo		$s1,[$sp]
FFFFFFFFFFFC0A5D.0     03E75 		add		$sp,$sp,#8
FFFFFFFFFFFC0A5F.8 8D74D3D41 		bal   $x1,GetHexNum
FFFFFFFFFFFC0A62.0     68D74 		mov		$s3,$a0
FFFFFFFFFFFC0A64.8     68F74 		mov   $s5,$a0
FFFFFFFFFFFC0A67.0     04B75 		add		$s1,$s1,#2
FFFFFFFFFFFC0A69.8 0E02CED41 		bal   $x1,GetHexNum
FFFFFFFFFFFC0A6C.0 080D50E02 		add		$s4,$a0,$s3
                        	.loop2:
FFFFFFFFFFFC0A70.8 1E4ECFD41 		bal   $x1,Getch						; check for ctrl-c
FFFFFFFFFFFC0A73.0 FBC3D1E4E 		beq		$a0,#3,Monitor
FFFFFFFFFFFC0A77.8     1B47B 		ldi		$a0,#CR
FFFFFFFFFFFC0A7A.0 B470DB141 		bal   $x1,Putch
FFFFFFFFFFFC0A7C.8     5B474 		mov		$a0,$s3
FFFFFFFFFFFC0A7F.0 01FB43941 		bal   $x1,PutHexWord
FFFFFFFFFFFC0A83.8     7547B 		ldi		$a0,#':'
FFFFFFFFFFFC0A86.0 EC70D5141 		bal   $x1,Putch
FFFFFFFFFFFC0A88.8     0EC7B 		ldi		$s2,#7
                        	.loop:
FFFFFFFFFFFC0A8B.0     4147B 		ldi		$a0,#' '
FFFFFFFFFFFC0A8D.8 4479D1541 		bal   $x1,Putch
FFFFFFFFFFFC0A90.0     44479 		bne   $t0,$x0,.userMem
FFFFFFFFFFFC0A92.8     4347B 		ldi   $a0,#33         ; Fetch memory word
FFFFFFFFFFFC0A95.0     5B574 		mov   $a1,$s3
FFFFFFFFFFFC0A97.8 0003C0000 		brk   #240
FFFFFFFFFFFC0A9C.0     6B474 		mov   $a0,$a1
FFFFFFFFFFFC0A9E.8     0387A 		bra   .0002
                        	.userMem
FFFFFFFFFFFC0AA1.0 000035460 		ldb		$a0,[$s3]
                        	.0002:
FFFFFFFFFFFC0AA5.8 4D751E941 		bal   $x1,PutHexByte
FFFFFFFFFFFC0AA8.0     04D75 		add		$s3,$s3,#2
FFFFFFFFFFFC0AAA.8     FEC75 		sub		$s2,$s2,#1
FFFFFFFFFFFC0AAD.0 FF8033C49 		bge		$s2,$x0,.loop
FFFFFFFFFFFC0AB1.8 00007DC5A 		bltu  $s3,$s4,loop2
FFFFFFFFFFFC0AB6.0 EC8E36D4A 
                        	;	call  PutInlineString
                        	;	db    ' ',' ',0
FFFFFFFFFFFC0ABA.8     5ED74 		mov   $s3,$s5
                        	.0004:
FFFFFFFFFFFC0ABD.0 000035464 		ldbu  $a0,[$s3]
FFFFFFFFFFFC0AC1.8 00605134A 		bltu  $a0,#$20,.unprintable
FFFFFFFFFFFC0AC6.0 3C70B5141 		bal   $x1,Putch
FFFFFFFFFFFC0AC8.8     03C7A 		bra   .0003
                        	.unprintable:
FFFFFFFFFFFC0ACB.0     5D47B 	  ldi   $a0,#'.'
FFFFFFFFFFFC0ACD.8 4D75B1541 	  bal   $x1,Putch
                        	.0003:
FFFFFFFFFFFC0AD0.0     04D75 	  add   $s3,$s3,#2
FFFFFFFFFFFC0AD2.8 FF8EB554A 	  bltu  $s3,$s4,.0004
FFFFFFFFFFFC0AD7.0     1B47B 	  ldi   $a0,#CR
FFFFFFFFFFFC0AD9.8 307AAB541 	  bal   $x1,Putch
FFFFFFFFFFFC0ADC.0     C307A 		bra		Monitor		
                        	
                        	  ; align cache
                        	EditMem:
                        	;	csrrs $x0,#CSR_UIE,#1        ; enable gc interrupt
FFFFFFFFFFFC0ADE.8 8D7494541 		bal   $x1,GetHexNum			; get address to edit
FFFFFFFFFFFC0AE1.0     68D74 		mov		$s3,$a0
FFFFFFFFFFFC0AE3.8     04B75 		add		$s1,$s1,#2
FFFFFFFFFFFC0AE6.0 006090941 		bal   $x1,GetHexNum			; get value to set
FFFFFFFFFFFC0AE8.8 000D50068 		stb		$s3,[$a0]			; update mem
FFFFFFFFFFFC0AED.0     BA87A 		bra		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >V 0
                        	; Displays the virtual memory map for the specified app.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	doVMem:
FFFFFFFFFFFC0AEF.8     02B75 	  add   $s1,$s1,#1
FFFFFFFFFFFC0AF2.0 0570BED41 	  bal   $x1,GetDecNum
FFFFFFFFFFFC0AF4.8     0057B 	  ldi   $t1,#0
FFFFFFFFFFFC0AF7.0 341050402 	  sll   $t0,$a0,#16
                        	.0001:
R2 operation needs two source operands. (2311)
R2 operation needs two source operandsFFFFFFFFFFFC0AFB.8     C1F74 	  and.  $a0,$t1,#3
Register value required. (2313)
FFFFFFFFFFFC0AFE.0 007FFCE4F 	  bne   .notLF
FFFFFFFFFFFC0B02.8 947444D41 	  bal   $x1,PutCRLF
                        	.notLF:
FFFFFFFFFFFC0B05.0     49474 	  mov   $a0,$t0
FFFFFFFFFFFC0B07.8 01FAFF541 	  bal   $x1,PutHexWord
FFFFFFFFFFFC0B0C.0     7547B 	  ldi   $a0,#':'
FFFFFFFFFFFC0B0E.8 140290D41 	  bal   $x1,Putch
FFFFFFFFFFFC0B11.0 380401402 	  mvmap $a0,$x0,$t0
FFFFFFFFFFFC0B15.8 01FAFAD41 	  bal   $x1,PutHexHalf
FFFFFFFFFFFC0B1A.0     4147B 	  ldi   $a0,#' '
FFFFFFFFFFFC0B1C.8 247589D41 	  bal   $x1,Putch
FFFFFFFFFFFC0B1F.0     02475 	  add   $t0,$t0,#1
FFFFFFFFFFFC0B21.8     02575 	  add   $t1,$t1,#1
FFFFFFFFFFFC0B24.0 000000528 	  slt   $t1,#256
                        	  bt    .0001
FFFFFFFFFFFC0B28.8     9CC7A 	  bra   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >P
                        	; Display the PAM bits status.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	doPStat:
FFFFFFFFFFFC0B2B.0 057030941 	  bal   $x1,PutCRLF
FFFFFFFFFFFC0B2D.8     0057B 	  ldi   $t1,#0        ; $a1 = bit number
                        	.0001:
FFFFFFFFFFFC0B30.0     4147B 	  ldi   $a0,#32       ; Get PAM bit pair
FFFFFFFFFFFC0B32.8 0003C0000 	  brk   #240
FFFFFFFFFFFC0B37.0 003055404 	  add   $a0,$a1,#'0'
FFFFFFFFFFFC0B3B.8 25757A541 	  bal   $x1,Putch
FFFFFFFFFFFC0B3E.0     02575 	  add   $t1,$t1,#1
FFFFFFFFFFFC0B40.8 542804050 	  slt   $a0,$t1,#MEMSZ
FFFFFFFFFFFC0B45.0 347000001 
FFFFFFFFFFFC0B47.8     A3479 	  bne   $a0,#0,.0001
FFFFFFFFFFFC0B4A.0     8C07A 	  bra   Monitor
                        	 
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	FillMem:
FFFFFFFFFFFC0B4C.8 8D745D541 		bal   $x1,GetHexNum			; get address
FFFFFFFFFFFC0B4F.0     68D74 		mov		$s3,$a0
FFFFFFFFFFFC0B51.8     04B75 		add		$s1,$s1,#2
FFFFFFFFFFFC0B54.0 8E7059941 		bal   $x1,GetHexNum			; get length
FFFFFFFFFFFC0B56.8     68E74 		mov		$s4,$a0
FFFFFFFFFFFC0B59.0     04B75 		add		$s1,$s1,#2
FFFFFFFFFFFC0B5B.8 CE7555D41 		bal   $x1,GetHexNum			; get byte to use
                        	.0001:
FFFFFFFFFFFC0B5E.0     FCE75 		sub		$s4,$s4,#2
FFFFFFFFFFFC0B60.8 000038058 		stb		$a0,[$s3+$s4]
FFFFFFFFFFFC0B65.0 001434069 
FFFFFFFFFFFC0B69.8 FFC2BA94B 		bgeu	$s4,#2,.0001
FFFFFFFFFFFC0B6E.0     7A07A 		bra		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; FI Hello
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	Find:
FFFFFFFFFFFC0B70.8 C1410DD41 	  bal   $x1,PutCRLF
FFFFFFFFFFFC0B73.0 6C703C141 	  bal   $x1,SkipSpaces
FFFFFFFFFFFC0B75.8     56C74 	  mov   $s2,$s1
                        	.fwe:
FFFFFFFFFFFC0B78.0 010030464 	  ldbu  $t0,INBUF[$s2]
FFFFFFFFFFFC0B7C.8 002010500 	  seq		$t1,$t0,#' '
FFFFFFFFFFFC0B81.0 007D1060D 	  seq		$t2,$t0,#CR
FFFFFFFFFFFC0B85.8 020614502 	  or		$t1,$t1,$t2
FFFFFFFFFFFC0B8A.0     1E579 	  bne		$t1,$x0,.endOfWord
FFFFFFFFFFFC0B8C.8     04C75 	  add   $s2,$s2,#2
FFFFFFFFFFFC0B8F.0     F487A 	  bra   .fwe
                        	.endOfWord:
FFFFFFFFFFFC0B91.8 020030068 	  stb   $x0,INBUF[$s2]
FFFFFFFFFFFC0B96.0     56C74 	  mov   $s2,$s1
FFFFFFFFFFFC0B98.8     0147B 	  ldi   $a0,#0
FFFFFFFFFFFC0B9B.0     0157B 	  ldi   $a1,#0
                        	.loop:
FFFFFFFFFFFC0B9D.8 044E39541 		bal		$x1,Getch						; check for ctrl-c
FFFFFFFFFFFC0BA0.0 F9C35044E 		beq	  $a0,#3,Monitor
                        	.0001:
FFFFFFFFFFFC0BA4.8 000050464 	  ldbu  $t0,[$a0]
FFFFFFFFFFFC0BA9.0 010030564 	  ldbu 	$t1,INBUF[$s2]
FFFFFFFFFFFC0BAD.8 00009624E 	  beq   $t1,$x0,.found
FFFFFFFFFFFC0BB2.0 00051050D 	  seq   $t1,$t0,$t1
FFFFFFFFFFFC0BB6.8     28578 	  beq   $t1,$x0,.next
FFFFFFFFFFFC0BB9.0     05475 	  add   $a0,$a0,#2
FFFFFFFFFFFC0BBB.8     04C75 	  add   $s2,$s2,#2
FFFFFFFFFFFC0BBE.0     EFC7A 	  bra   .loop
                        	.next:
FFFFFFFFFFFC0BC0.8     56C74 	  mov   $s2,$s1         ; start over again with $s2
FFFFFFFFFFFC0BC3.0 000255404 	  add   $a0,$a1,#2      ; start over again with $a0, but increment by one byte
FFFFFFFFFFFC0BC7.8 000010050 	  ldi   $t2,#$80000     ; 512k
FFFFFFFFFFFC0BCC.0 000000604 
FFFFFFFFFFFC0BD0.8     69574 	  mov   $a1,$a0         ; remember new starting pos.
FFFFFFFFFFFC0BD3.0 08065050D 	  slt   $t1,$a0,$t2
FFFFFFFFFFFC0BD7.8 FF8414C4F 	  bne   $t1,$t0,.loop
FFFFFFFFFFFC0BDC.0     0507A 	  bra   .notFound
                        	.found:
FFFFFFFFFFFC0BDE.8 59416C941 	  bal   $x1,PutHexTetra
FFFFFFFFFFFC0BE1.0 E870D5941 	  bal   $x1,PutCRLF
FFFFFFFFFFFC0BE3.8     EE87A 	  bra   .next
                        	.notFound:
FFFFFFFFFFFC0BE6.0 CC70D3141 	  bal   $x1,PutCRLF
FFFFFFFFFFFC0BE8.8     3CC7A 	  bra   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	SkipSpaces:
                        	.skip2:
FFFFFFFFFFFC0BEB.0 01002C460 		ldb		  $t0,INBUF[$s1]
FFFFFFFFFFFC0BEF.8 002010500 		seq		  $t1,$t0,#' '  ; space or
FFFFFFFFFFFC0BF4.0 000910600 		seq			$t2,$t0,#'\t'	; tab
FFFFFFFFFFFC0BF8.8 020614502 		or			$t1,$t1,$t2
FFFFFFFFFFFC0BFD.0     1E578 		beq			$t1,$x0,.done
FFFFFFFFFFFC0BFF.8     04B75 		add 		$s1,$s1,#2
FFFFFFFFFFFC0C02.0     F487A 		bra	  	.skip2
                        	.done
FFFFFFFFFFFC0C04.8     02074 	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	GetHexNum:
FFFFFFFFFFFC0C07.0     FFE75 		sub		$sp,$sp,#8
FFFFFFFFFFFC0C09.8     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0C0C.0     0147B 		ldi		$a0,#0							; a0 = num
FFFFFFFFFFFC0C0E.8 C460EE541 		bal   $x1,SkipSpaces
                        	.next:
FFFFFFFFFFFC0C11.0 01002C460 		ldb		$t0,INBUF[$s1]
FFFFFFFFFFFC0C15.8 00709084A 		bltu	$t0,#'0',.0001
FFFFFFFFFFFC0C1A.0 00FA1124A 		bltu	$t0,#'9'+1,.isDigit
FFFFFFFFFFFC0C1E.8 00411364A 		bltu	$t0,#'A',.0001
FFFFFFFFFFFC0C23.0 004713C4A 		bltu	$t0,#'F'+1,.isHexUpper
FFFFFFFFFFFC0C27.8 006100504 		ldi		$t1,#'a'
FFFFFFFFFFFC0C2C.0 000511B4A 		bltu	$t0,$t1,.0001
FFFFFFFFFFFC0C30.8 006700504 		ldi		$t1,#'f'+1
FFFFFFFFFFFC0C35.0 000513A4A 		bltu	$t0,$t1,.isHexLower
                        	.0001:
FFFFFFFFFFFC0C39.8     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC0C3C.0     03E75 		add		$sp,$sp,#8
FFFFFFFFFFFC0C3E.8     02074 		ret
                        	.isHexUpper:
FFFFFFFFFFFC0C41.0     0947C 		sll		$a0,$a0,#4
FFFFFFFFFFFC0C43.8 FFBF10404 		sub		$t0,$t0,#'A'
FFFFFFFFFFFC0C48.0     14475 		add		$t0,$t0,#10
FFFFFFFFFFFC0C4A.8     C277C 		or		$a0,$a0,$t0
FFFFFFFFFFFC0C4D.0     04B75 		add		$s1,$s1,#2
FFFFFFFFFFFC0C4F.8     E0C7A 		bra		.next
                        	.isHexLower:
FFFFFFFFFFFC0C52.0     0947C 		sll		$a0,$a0,#4
FFFFFFFFFFFC0C54.8 FF9F10404 		sub		$t0,$t0,#'a'
FFFFFFFFFFFC0C59.0     14475 		add		$t0,$t0,#10
FFFFFFFFFFFC0C5B.8     C277C 		or		$a0,$a0,$t0
FFFFFFFFFFFC0C5E.0     04B75 		add		$s1,$s1,#2
FFFFFFFFFFFC0C60.8     D847A 		bra		.next
                        	.isDigit:
FFFFFFFFFFFC0C63.0     0947C 		sll		$a0,$a0,#4
FFFFFFFFFFFC0C65.8     A0475 		sub		$t0,$t0,#'0'
FFFFFFFFFFFC0C68.0     C277C 		or		$a0,$a0,$t0
FFFFFFFFFFFC0C6A.8     04B75 		add		$s1,$s1,#2
FFFFFFFFFFFC0C6D.0     D207A 		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a decimal number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	GetDecNum:
FFFFFFFFFFFC0C6F.8     FFE75 		sub			$sp,$sp,#8
FFFFFFFFFFFC0C72.0     01E73 		sto			$x1,[$sp]
FFFFFFFFFFFC0C74.8     0147B 		ldi			$a0,#0							; a0 = num
FFFFFFFFFFFC0C77.0 C460BA141 		bal 	  $x1,SkipSpaces
                        	.next:
FFFFFFFFFFFC0C79.8 01002C460 		ldb		  $t0,INBUF[$s1]
FFFFFFFFFFFC0C7E.0 00701124A 		bltu		$t0,#'0',.0001
FFFFFFFFFFFC0C82.8 007A1184A 		bltu		$t0,#'9'+1,.isDigit
                        	.0001:
FFFFFFFFFFFC0C87.0     01E71 		ldo			$x1,[$sp]
FFFFFFFFFFFC0C89.8     03E75 		add			$sp,$sp,#8
FFFFFFFFFFFC0C8C.0     02074 		ret
                        	.isDigit:
                        		; mulf is not used to allow the number to be larger than 40 bits
FFFFFFFFFFFC0C8E.8 340150602 		sll		$t2,$a0,#1    ; multiply by 10
FFFFFFFFFFFC0C93.0     0747C 		sll   $a0,$a0,#3    ; * 8
FFFFFFFFFFFC0C95.8     8D474 		add   $a0,$a0,$t2   ; + *2
FFFFFFFFFFFC0C98.0     A0475 		sub		$t0,$t0,#'0'
FFFFFFFFFFFC0C9A.8     89474 		add		$a0,$a0,$t0
FFFFFFFFFFFC0C9D.0     04B75 		add		$s1,$s1,#2
FFFFFFFFFFFC0C9F.8     ED07A 		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output an octabyte as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains octabyte value to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	PutHexOcta:
FFFFFFFFFFFC0CA2.0     FFE75 		sub		$sp,$sp,#8
FFFFFFFFFFFC0CA4.8     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0CA7.0 082051402 		ror		$a0,$a0,#32
FFFFFFFFFFFC0CAB.8 140206141 		bal		$x1,PutHexTetra
FFFFFFFFFFFC0CAE.0 062051402 		rol   $a0,$a0,#32
FFFFFFFFFFFC0CB2.8     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC0CB5.0     03E75 		add		$sp,$sp,#8
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains word to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexTetra:
FFFFFFFFFFFC0CB7.8     FFE75 		sub		$sp,$sp,#8
FFFFFFFFFFFC0CBA.0     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0CBC.8 081051402 		ror		$a0,$a0,#16
FFFFFFFFFFFC0CC1.0 140006141 		bal		$x1,PutHexWyde
FFFFFFFFFFFC0CC3.8 061051402 		rol		$a0,$a0,#16
FFFFFFFFFFFC0CC8.0     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC0CCA.8     03E75 		add		$sp,$sp,#8
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexWyde:
FFFFFFFFFFFC0CCD.0     FFE75 		sub		$sp,$sp,#8
FFFFFFFFFFFC0CCF.8     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0CD2.0 080851402 		ror		$a0,$a0,#8
FFFFFFFFFFFC0CD6.8 140206141 		bal		$x1,PutHexByte
FFFFFFFFFFFC0CD9.0 060851402 		rol		$a0,$a0,#8
FFFFFFFFFFFC0CDD.8     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC0CE0.0     03E75 		add		$sp,$sp,#8
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexByte:
FFFFFFFFFFFC0CE2.8     FFE75 		sub		$sp,$sp,#8
FFFFFFFFFFFC0CE5.0     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0CE7.8 080451402 		ror		$a0,$a0,#4		; put the high order nybble first
FFFFFFFFFFFC0CEC.0 140006141 		bal		$x1,PutHexNybble
FFFFFFFFFFFC0CEE.8 060451402 		rol		$a0,$a0,#4		; restore a0
FFFFFFFFFFFC0CF3.0     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC0CF5.8     03E75 		add		$sp,$sp,#8
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains nybble to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexNybble:
FFFFFFFFFFFC0CF8.0     FBE75 		sub		$sp,$sp,#24
FFFFFFFFFFFC0CFA.8     01E73 		sto		$a0,0[$sp]
FFFFFFFFFFFC0CFD.0     03E73 		sto   $t0,8[$sp]
FFFFFFFFFFFC0CFF.8     05E73 		sto		$x1,16[$sp]
FFFFFFFFFFFC0D02.0     1F476 		and		$a0,$a0,#15		; strip off high order bits
FFFFFFFFFFFC0D04.8 004A51348 		blt		$a0,#10,.lt10
FFFFFFFFFFFC0D09.0     ED475 		sub		$a0,$a0,#10
FFFFFFFFFFFC0D0B.8     23475 		add		$a0,$a0,#'A'-'0'
                        	.lt10:
FFFFFFFFFFFC0D0E.0     61475 		add		$a0,$a0,#'0'
FFFFFFFFFFFC0D10.8 1E718FD41 		bal		$x1,Putch
                        	.0001:
FFFFFFFFFFFC0D13.0     01E71 		ldo		$a0,0[$sp]
FFFFFFFFFFFC0D15.8     03E71 		ldo   $t0,8[$sp]
FFFFFFFFFFFC0D18.0     05E71 		ldo		$x1,16[$sp]
FFFFFFFFFFFC0D1A.8     07E75 		add   $sp,$sp,#24
FFFFFFFFFFFC0D1D.0     02074 		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutInlineString
                        	;   Put a string of characters to output device. The string parameter is
                        	; located as an inline parameter.
                        	;------------------------------------------------------------------------------
                        	
                        	PutInlineStringCA:				; chunk addressing
FFFFFFFFFFFC0D1F.8     01E71 	  ldo   $t1,[$sp]         ; pop return address
FFFFFFFFFFFC0D22.0     FDE75 	  sub		$sp,$sp,#16				; make room for save area
FFFFFFFFFFFC0D24.8     01E73 		sto		$a0,[$sp]				  ; save a0
FFFFFFFFFFFC0D27.0     03E73 		sto		$s1,8[$sp]				; and s1
FFFFFFFFFFFC0D29.8     05E73 		sto		$s2,16[$sp]
FFFFFFFFFFFC0D2C.0     4AB74 		mov		$s1,$t1						; s1 = pointer to string
FFFFFFFFFFFC0D2E.8     4AC74 		mov		$s2,$t1						; s2 = pointer to string
                        	.0001:
FFFFFFFFFFFC0D31.0 00002D460 		ldb		$a0,[$s1]
FFFFFFFFFFFC0D35.8     04B75 		add		$s1,$s1,#2				; advance pointer to next byte
FFFFFFFFFFFC0D38.0     1F478 		beq 	$a0,#0,.done      ; branch if done
FFFFFFFFFFFC0D3A.8 A07A7AC41 		call	Putch							; output character, assume $tx destroyed
FFFFFFFFFFFC0D3D.0     FA07A 		bra		.0001
                        	.done:
FFFFFFFFFFFC0D3F.8 0A0C2CC02 		sub		$s2,$s1,$s2				; get count of nybbles
FFFFFFFFFFFC0D44.0 000930C18 		rem		$s2,$s2,#9				; figure mod 9
FFFFFFFFFFFC0D48.8     1CC78 		beq		$s2,#0,.remz
FFFFFFFFFFFC0D4B.0 000930C05 		subf	$s2,$s2,#9				; number of nybbles to add 9-mod
                        	.remz:
FFFFFFFFFFFC0D4F.8 080C2C502 		add		$t1,$s1,$s2				; $t1 = return address
FFFFFFFFFFFC0D54.0     01E71 		ldo		$a0,[$sp]				  ; restore a0
FFFFFFFFFFFC0D56.8     03E71 		ldo		$s1,8[$sp]				; restore $s1,$s2
FFFFFFFFFFFC0D59.0     05E71 		ldo		$s2,16[$sp]
FFFFFFFFFFFC0D5B.8     07E75 		add   $sp,$sp,#24				; pop save area and return address
FFFFFFFFFFFC0D5E.0 000014040 	  jmp   [$t1]
                        	
                        	PutInlineString:
FFFFFFFFFFFC0D62.8     01E71 	  ldo   $t1,[$sp]         ; pop return address
FFFFFFFFFFFC0D65.0     FFE75 	  sub		$sp,$sp,#8				; make room for save area
FFFFFFFFFFFC0D67.8     01E73 		sto		$a0,[$sp]				  ; save a0
FFFFFFFFFFFC0D6A.0     03E73 		sto		$s1,8[$sp]				; and s1
FFFFFFFFFFFC0D6C.8     4AB74 		mov		$s1,$t1						; s1 = pointer to string
                        	.0001:
FFFFFFFFFFFC0D6F.0 00002D460 		ldb		$a0,[$s1]
FFFFFFFFFFFC0D73.8     04B75 		add		$s1,$s1,#2				; advance pointer to next byte
FFFFFFFFFFFC0D76.0     1F478 		beq 	$a0,#0,.done      ; branch if done
FFFFFFFFFFFC0D78.8 A07A5BC41 		call	Putch							; output character, assume $tx destroyed
FFFFFFFFFFFC0D7B.0     FA07A 		bra		.0001
                        	.done:
FFFFFFFFFFFC0D7D.8     56574 		mov		$t1,$s1						; $t1 = return address
FFFFFFFFFFFC0D80.0     01E71 		ldo		$a0,[$sp]				  ; restore a0
FFFFFFFFFFFC0D82.8     03E71 		ldo		$s1,8[$sp]				; restore $s1
FFFFFFFFFFFC0D85.0     05E75 		add   $sp,$sp,#16				; pop save area and return address
FFFFFFFFFFFC0D87.8 000014040 	  jmp   [$t1]
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	PutCRLF:
FFFFFFFFFFFC0D8C.0     FFE75 		sub		$sp,$sp,#8
FFFFFFFFFFFC0D8E.8     01E73 		sto		$x1,[$sp]
FFFFFFFFFFFC0D91.0     1B47B 		ldi		$a0,#CR
FFFFFFFFFFFC0D93.8 547B4E541 		bal		$x1,Putch
FFFFFFFFFFFC0D96.0     1547B 		ldi		$a0,#LNFD
FFFFFFFFFFFC0D98.8 1E714BD41 		bal		$x1,Putch
FFFFFFFFFFFC0D9B.0     01E71 		ldo		$x1,[$sp]
FFFFFFFFFFFC0D9D.8     03E75 		add		$sp,$sp,#8
FFFFFFFFFFFC0DA0.0     02074 		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	PutString:
FFFFFFFFFFFC0DA2.8     FBE75 		sub		$sp,$sp,#24
FFFFFFFFFFFC0DA5.0     01E73 		sto		$a0,[$sp]				  ; save argument
FFFFFFFFFFFC0DA7.8     03E73 		sto   $s1,8[$sp]        ; and reg var
FFFFFFFFFFFC0DAA.0     05E73 		sto		$x1,16[$sp]
FFFFFFFFFFFC0DAC.8     68B74 		mov		$s1,$a0						; t1 = pointer to string
                        	.0001:
FFFFFFFFFFFC0DAF.0 00002D460 		ldb		$a0,[$s1]
FFFFFFFFFFFC0DB3.8     04B75 		add		$s1,$s1,#2				; advance pointer to next byte
FFFFFFFFFFFC0DB6.0     1F478 		beq 	$a0,#0,.done     	; branch if done
FFFFFFFFFFFC0DB8.8 A07A3BD41 		bal		$x1,Putch							; output character
FFFFFFFFFFFC0DBB.0     FA07A 		bra		.0001
                        	.done:
FFFFFFFFFFFC0DBD.8     01E71 		ldo		$a0,[$sp]				  ; restore argument
FFFFFFFFFFFC0DC0.0     03E71 		ldo   $s1,8[$sp]
FFFFFFFFFFFC0DC2.8     05E71 		ldo		$x1,16[$sp]
FFFFFFFFFFFC0DC5.0     07E75 		add   $sp,$sp,#24
FFFFFFFFFFFC0DC7.8     02074 		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	DumpTraceQueue:
FFFFFFFFFFFC0DCA.0 005801A04 		ldi     $a6,#'X'        ; bypass='B' in fputc routine
                        	.dmpTrace:
FFFFFFFFFFFC0DCE.8     1B47B 		ldi     $a0,#CR
FFFFFFFFFFFC0DD1.0 D5702F941 		bal			$x1,Putch
FFFFFFFFFFFC0DD3.8     1D57B 		ldi     $a1,#14         ; processor trace queue status
FFFFFFFFFFFC0DD6.0 140055407 		peekq  	$a0,$a1
FFFFFFFFFFFC0DDA.8 000052148 		blt     $a0,$x0,.dmpTraceEmpty  ; emptied out?
FFFFFFFFFFFC0DDF.0     1F57B 		ldi     $a1,#15         ; processor trace queue data
FFFFFFFFFFFC0DE1.8 120055407 		popq   	$a0,$a1
FFFFFFFFFFFC0DE6.0 30705E141 		bal			$x1,PutHexOcta
FFFFFFFFFFFC0DE8.8     F307A 		bra     .dmpTrace
                        	.dmpTraceEmpty:
FFFFFFFFFFFC0DEB.0     1B47B 		ldi     $a0,#CR
FFFFFFFFFFFC0DED.8 007A21541 		bal			$x1,Putch
                        	.inf:
FFFFFFFFFFFC0DF0.0     0007A 	  bra     .inf
FFFFFFFFFFFC0DF2.8     02074 	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code staret here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;
                        	; On incoming the register file has been set to the interrupt register file
                        	; or the machine mode register file.
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC0DF5.0 000000000 	  align 16
FFFFFFFFFFFC0DF9.8 000000000 
FFFFFFFFFFFC0DFE.0 000000000 
                        	; Top of stack for different register sets
                        	StackTbl:
FFFFFFFFFFFC0E00.0 000000000 	  dw    $0
FFFFFFFFFFFC0E04.8 000000000 
FFFFFFFFFFFC0E08.0 000000000 	  dw    $0
FFFFFFFFFFFC0E0C.8 000000000 
FFFFFFFFFFFC0E10.0 000000000 	  dw    $0
FFFFFFFFFFFC0E14.8 000000000 
FFFFFFFFFFFC0E18.0 000000000 	  dw    $0
FFFFFFFFFFFC0E1C.8 000000000 
FFFFFFFFFFFC0E20.0 000000000 	  dw    $0
FFFFFFFFFFFC0E24.8 000000000 
FFFFFFFFFFFC0E28.0 000000000 	  dw    $0
FFFFFFFFFFFC0E2C.8 000000000 
FFFFFFFFFFFC0E30.0 000000000 	  dw    $0
FFFFFFFFFFFC0E34.8 000000000 
FFFFFFFFFFFC0E38.0 000000000 	  dw    $0
FFFFFFFFFFFC0E3C.8 000000000 
FFFFFFFFFFFC0E40.0 000000000 	  dw    $0
FFFFFFFFFFFC0E44.8 000000000 
FFFFFFFFFFFC0E48.0 000000000 	  dw    $0
FFFFFFFFFFFC0E4C.8 000000000 
FFFFFFFFFFFC0E50.0 000000000 	  dw    $0
FFFFFFFFFFFC0E54.8 000000000 
FFFFFFFFFFFC0E58.0 000000000 	  dw    $0
FFFFFFFFFFFC0E5C.8 FC0000000 
FFFFFFFFFFFC0E60.0 00007F3FC 	  dw    $7F400-4
FFFFFFFFFFFC0E64.8 FC0000000 
FFFFFFFFFFFC0E68.0 00007F7FC 	  dw    $7F800-4
FFFFFFFFFFFC0E6C.8 FC0000000 
FFFFFFFFFFFC0E70.0 00007FBFC 	  dw    $7FC00-4
FFFFFFFFFFFC0E74.8 FC0000000 
FFFFFFFFFFFC0E78.0 00007FFFC 	  dw    $80000-4
FFFFFFFFFFFC0E7C.8 0F0000000 
                        	
                        	.file "any1_rom.r64",1313
                        		code
                        		align	16
                        	IRQRout:
FFFFFFFFFFFC0E80.0 40060240F 		csrrw	$t0,#CSR_DCAUSE,$x0		; get cause code
FFFFFFFFFFFC0E84.8 008013048 		blt	  $t0,$x0,.isIRQ	      ; irq or brk #240?
FFFFFFFFFFFC0E89.0 004211B4E 		beq		$t0,#2,.unimp					; unimplemented instruction?
FFFFFFFFFFFC0E8D.8 FFFC10608 		and   $t2,$t0,#-4
FFFFFFFFFFFC0E92.0 00489914E 		beq		$t2,#8,.brk
                        		; Some other cause
                        	.unimp:
FFFFFFFFFFFC0E96.8 000000850 	  sto   $t0,$4018
FFFFFFFFFFFC0E9B.0 300401868 
FFFFFFFFFFFC0E9F.8 10280400F 		csrrc $x0,#CSR_TRACECTRL,#1 ; turn off tracing
FFFFFFFFFFFC0EA4.0 FFFFF0350 		ldi   $t0,#DumpTraceQueue
FFFFFFFFFFFC0EA8.8 1B9400404 
FFFFFFFFFFFC0EAD.0 30481200F 		csrrw $x0,#CSR_MEPC,$t0
FFFFFFFFFFFC0EB1.8 01F937C41 		bra		DBGxit
                        	.soc:
FFFFFFFFFFFC0EB6.0 FE075B040 	  jmp   .soc
                        	.brk:
                        	  ; We reset the stack pointer at each callto the OS in case an error causes
                        	  ; it to be messed up.
FFFFFFFFFFFC0EBA.8 30400240F 	  csrrw $t0,#CSR_PMSTACK,$x0   ; get operating mode
FFFFFFFFFFFC0EBF.0     1C476 	  and   $t0,$t0,#14       ; extract register set selection (will be 13,14, or 15)
FFFFFFFFFFFC0EC1.8 340310602 	  sll   $t2,$t0,#3        ; $t2 = table index
FFFFFFFFFFFC0EC6.0 FFFFF0350 		ldo		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFFFFFFFFFC0ECA.8 3C0019E60 
FFFFFFFFFFFC0ECF.0 000000050 		jmp		OSECALL					  ; goto operating system calldispatcher
FFFFFFFFFFFC0ED3.8 F00000051 
FFFFFFFFFFFC0ED8.0 000091040 
                        	.isIRQ:
FFFFFFFFFFFC0EDC.8 30400240F 	  csrrw $t0,#CSR_PMSTACK,$x0   ; get operating mode
FFFFFFFFFFFC0EE1.0     1C476 	  and   $t0,$t0,#14       ; extract register set selection (will be 13,14, or 15)
FFFFFFFFFFFC0EE3.8 340310602 	  sll   $t2,$t0,#3        ; $t2 = table index
FFFFFFFFFFFC0EE8.0 FFFFF0350 		ldo		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFFFFFFFFFC0EEC.8 3C0019E60 
FFFFFFFFFFFC0EF1.0 40060240F 		csrrw	$t0,#CSR_DCAUSE,$x0			; get cause code
                        	
FFFFFFFFFFFC0EF5.8 000000250 	  ldt   $t1,IRQFlag     ; update IRQ flag for Tiny Basic
FFFFFFFFFFFC0EFA.0 209000560 
FFFFFFFFFFFC0EFE.8     02575 	  add   $t1,$t1,#1
FFFFFFFFFFFC0F01.0 000000250 	  stt   $t1,IRQFlag
FFFFFFFFFFFC0F05.8 210501068 
FFFFFFFFFFFC0F0A.0 00FF10408 	  and   $t0,$t0,#$FF
FFFFFFFFFFFC0F0E.8 000000250 	  stt   $t0,IRQCause    ; update cause code for Tiny Basic
FFFFFFFFFFFC0F13.0 210401868 
FFFFFFFFFFFC0F17.8 FFFF10504 	  sub  	$t1,$t0,#1
FFFFFFFFFFFC0F1C.0 00009674E 	  beq   $t1,$x0,.softwareIrq
FFFFFFFFFFFC0F20.8     FE575 	  sub  	$t1,$t1,#1
FFFFFFFFFFFC0F23.0 00009594E 	  beq   $t1,$x0,.timerIrq
FFFFFFFFFFFC0F27.8     FE575 	  sub  	$t1,$t1,#1      ; garbage collect interrupt?
FFFFFFFFFFFC0F2A.0 010016A4E 	  beq   $t1,$x0,.gcIrq
FFFFFFFFFFFC0F2E.8 001F10808 		and		$t4,$t0,#31			; interrupting device # is low order 5 bits of cause code
FFFFFFFFFFFC0F33.0     0A77B 		ldi   $t3,#5          ; try 5 times
                        	.devAgain:
FFFFFFFFFFFC0F35.8     50974 		mov   $t5,$t4
FFFFFFFFFFFC0F38.0     1097C 		sll		$t5,$t5,#8				; 128 bytes per device func table
FFFFFFFFFFFC0F3A.8 20B024904 		add		$t5,$t5,#DVF_Base+22*8	; load IRQ routine vector from device func table
FFFFFFFFFFFC0F3F.0 300024960 		ldo		$t5,[$t5]
FFFFFFFFFFFC0F43.8     1C978 		beq	  $t5,$x0,.noIRQ	    ; make sure there's an address to go to
FFFFFFFFFFFC0F46.0 000024040 		jmp		[$t5]						; jump to the IRQ routine
                        	.noIRQ:
FFFFFFFFFFFC0F4A.8     FE775 	  sub  	$t3,$t3,#1
FFFFFFFFFFFC0F4D.0     40779 	  bne   $t3,$x0,.InitDev
                        	.softwareIrq:
                        	.timerIrq:
FFFFFFFFFFFC0F4F.8 000000050 	  jmp   DBGxit							; ERETx2
FFFFFFFFFFFC0F54.0 F00000051 
FFFFFFFFFFFC0F58.8 000090840 
                        		; The device function tables may have been zeroed out, try initializing them.
                        		; The following uses $a0-$a1, $t0-$t2
                        	.InitDev:
FFFFFFFFFFFC0F5D.0 0045A204F 		bne		$t4,#5,.notSerial
FFFFFFFFFFFC0F61.8     0B47B 		ldi		$a0,#5							; serial device
FFFFFFFFFFFC0F64.0 000000050 		ldi		$a1,#SerialFuncTbl
FFFFFFFFFFFC0F68.8 F00000051 
FFFFFFFFFFFC0F6D.0 024C01504 
FFFFFFFFFFFC0F71.8 01F8DA941 		bal	  $x1,CopyDevFuncTbl
FFFFFFFFFFFC0F76.0     0B47B 		ldi		$a0,#5							; serial device
FFFFFFFFFFFC0F78.8 000000050 		ldi   $a1,#SerialDCB
FFFFFFFFFFFC0F7D.0 F00000051 
FFFFFFFFFFFC0F81.8 024E01504 
FFFFFFFFFFFC0F86.0 01F8D0D41 		bal   $x1,CopyDevDCB
FFFFFFFFFFFC0F8A.8     D587A 		bra   .devAgain
                        	.notSerial:
FFFFFFFFFFFC0F8D.0 004FA1B4F 		bne		$t4,#15,.notVia		; VIA device?
FFFFFFFFFFFC0F91.8 000000050 		ldi		$a1,#ViaFuncTbl
FFFFFFFFFFFC0F96.0 F00000051 
FFFFFFFFFFFC0F9A.8 025101504 
FFFFFFFFFFFC0F9F.0 01F8C3D41 		bal	  $x1,CopyDevFuncTbl
FFFFFFFFFFFC0FA3.8     1F47B 		ldi		$a0,#15							; VIA device
FFFFFFFFFFFC0FA6.0 000000050 		ldi		$a1,#ViaDCB
FFFFFFFFFFFC0FAA.8 F00000051 
FFFFFFFFFFFC0FAF.0 025201504 
FFFFFFFFFFFC0FB3.8 01F8BA141 		bal	  $x1,CopyDevDCB
FFFFFFFFFFFC0FB8.0     BEC7A 		bra   .devAgain
                        	.notVia:
FFFFFFFFFFFC0FBA.8 01F8B3441 	  bra   DBGxit					; ERETx2
                        	.gcIrq:
                        	;	ldi		$sp,#$7F800-4		; setup interrupt mode stack pointer
FFFFFFFFFFFC0FBF.0 01F8B5541 	  bal 	$x1,gcIncrement
FFFFFFFFFFFC0FC3.8 01F8AEC41 	  bra		DBGxit
                        	ERETx2:
                        	;  mDI
                        	;  csrrc $x0,#$7C0,#31   ; select machine regs only
                        	;  csrrw $t0,#$7C0,$x0   ; get register sets
                        	;  srl   $t0,$t0,#5      ; extract register set selection
                        	;  sll   $t0,$t0,#3
                        	;  ldt   $t1,MEPC0[$t0]  ; get it
                        	;  csrrw $x0,#$341,$t1   ; set mepc
                        	  
FFFFFFFFFFFC0FC8.0 00100400F 	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFFFFFFFFFC0FCC.8 003F0003F 	nop
FFFFFFFFFFFC0FCF.0 24000003F 	  nop
FFFFFFFFFFFC0FD1.8 30430240F 	  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
FFFFFFFFFFFC0FD6.0     1E476 	  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
FFFFFFFFFFFC0FD8.8 020210602 	  asl   $t2,$t0,#2        ; $t2 = table index
FFFFFFFFFFFC0FDD.0 FFFFF0350 		ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFFFFFFFFFC0FE1.8 2C0019E60 
FFFFFFFFFFFC0FE6.0 000000045 		rte

                        		; In case the pipeline runs ahead into the following table which will
                        		; result in illegal instructions.
FFFFFFFFFFFC0FEA.8 003F0003F 		nop
FFFFFFFFFFFC0FED.0 00300003F 		nop
FFFFFFFFFFFC0FEF.8 A00F0003F 	  nop
                        	
                        	  ; align cache
                        	DBGRout:
FFFFFFFFFFFC0FF2.0 40417A00F 		csrrw	$x0,#CSR_DSCRATCH,$x30		; save x30 inscratch
FFFFFFFFFFFC0FF6.8 019D01E0F 		csrrd	$x30,#CSR_DTCBPTR					; get pointer to TCB
FFFFFFFFFFFC0FFB.0 7FFFFFF5F 		stm		16[$x30],#%011111111111111111111111111111	; save registers
FFFFFFFFFFFC0FFF.8     05E73 
FFFFFFFFFFFC1002.0 40410040F 		csrrd	$t0,#CSR_DSCRATCH					; get back original x30
FFFFFFFFFFFC1006.8     79E73 		sto		$t0,480[$x30]							; and save it too
                        		; Free up some working registers
                        	;	sto		$x1,16[$x29]
                        	;	sto		$x2,32[$x29]
                        	;	sto		$x3,48[$x29]
                        	;	sto		$x4,64[$x29]
                        	;	sto		$x5,80[$x29]
                        	;	sto		$x6,96[$x29]
                        	;	sto		$x7,112[$x29]
                        	;	sto		$x8,128[$x29]
                        	;	sto		$x9,144[$x29]
                        	;	sto		$x10,160[$x29]
                        	;	sto		$x11,176[$x29]
                        	;	sto		$x12,192[$x29]
                        	;	sto		$x13,208[$x29]
                        	;	sto		$x14,224[$x29]
                        	;	sto		$x15,240[$x29]
                        	;	sto		$x16,256[$x29]
                        	;	sto		$x17,272[$x29]
                        	;	sto		$x18,288[$x29]
                        	;	sto   $x19,304[$x29]
                        	;	sto		$x20,320[$x29]
                        	;	sto		$x21,336[$x29]
                        	;	sto		$x22,352[$x29]
                        	;	sto		$x23,368[$x29]
                        	;	sto		$x24,384[$x29]
                        	;	sto		$x25,400[$x29]
                        	;	sto		$x26,416[$x29]
                        	;	sto		$x27,432[$x29]
                        	;	sto		$x28,448[$x29]
                        	;	sto		$x30,480[$x29]
FFFFFFFFFFFC1009.0 40060010F 		csrrd	$x1,#CSR_DCAUSE
FFFFFFFFFFFC100D.8 003604200 		seq		$x2,$x1,#FLT_WD
FFFFFFFFFFFC1012.0 00007DC5A 		bne		$x2,$x0,DBGxit
FFFFFFFFFFFC1016.8 E20009E4F 
FFFFFFFFFFFC101B.0     3287A 	  bra		IRQRout
FFFFFFFFFFFC101D.8 218000007 	  rex   #3,$x0
DBGxit:
FFFFFFFFFFFC1022.0 019D01E0F 		csrrd	$x30,#CSR_DTCBPTR
FFFFFFFFFFFC1026.8 FFFFFFF5F 		ldm		16[$x30],#%111111111111111111111111111111
FFFFFFFFFFFC102B.0     05E71 
                        	;	ldo		$x1,16[$x29]
                        	;	ldo		$x2,32[$x29]
                        	;	ldo		$x3,48[$x29]
                        	;	ldo		$x4,64[$x29]
                        	;	ldo		$x5,80[$x29]
                        	;	ldo		$x6,96[$x29]
                        	;	ldo		$x7,112[$x29]
                        	;	ldo		$x8,128[$x29]
                        	;	ldo		$x9,144[$x29]
                        	;	ldo		$x10,160[$x29]
                        	;	ldo		$x11,176[$x29]
                        	;	ldo		$x12,192[$x29]
                        	;	ldo		$x13,208[$x29]
                        	;	ldo		$x14,224[$x29]
                        	;	ldo		$x15,240[$x29]
                        	;	ldo		$x16,256[$x29]
                        	;	ldo		$x17,272[$x29]
                        	;	ldo		$x18,288[$x29]
                        	;	ldo   $x19,304[$x29]
                        	;	ldo		$x20,320[$x29]
                        	;	ldo		$x21,336[$x29]
                        	;	ldo		$x22,352[$x29]
                        	;	ldo		$x23,368[$x29]
                        	;	ldo		$x24,384[$x29]
                        	;	ldo		$x25,400[$x29]
                        	;	ldo		$x26,416[$x29]
                        	;	ldo		$x27,432[$x29]
                        	;	ldo		$x28,448[$x29]
                        	;	ldo		$x30,480[$x29]
FFFFFFFFFFFC102D.8 000000045 	  rte
	nop
FFFFFFFFFFFC1032.0 00300003F 
FFFFFFFFFFFC1034.8 003F0003F 		nop
FFFFFFFFFFFC1037.0 00000003F 	  nop
                        	END_OF_BOOT:
                        	
                        	.file "bios-pam.r64",25
                        		code	19 bits
                        	;------------------------------------------------------------------------------
                        	; PAM
                        	; 0 = unallocated
                        	; 1 = reserved
                        	; 2 = end of run of pages
                        	; 3 = allocated
                        	;------------------------------------------------------------------------------
                        	
                        	;------------------------------------------------------------------------------
                        	; PAMFindRun
                        	;    Find a run of unallocated pages.
                        	;
                        	; Parameters:
                        	;   $a0 = number of consecutive pages required
                        	; Returns:
                        	;   $a0 = page starting run, -1 if not enough memory
                        	;   $cr0 = N set if not enough memory
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC1039.8 000000000 	  align 16
FFFFFFFFFFFC103E.0 EDE750000 
                        	PAMFindRun:
FFFFFFFFFFFC1040.0     EDE75 	  sub 	$sp,$sp,#80
FFFFFFFFFFFC1042.8     01E73 	  sto		$ra,[$sp]
FFFFFFFFFFFC1045.0     05E73 	  sto   $s1,16[$sp]
FFFFFFFFFFFC1047.8     09E73 	  sto   $s2,32[$sp]
FFFFFFFFFFFC104A.0     0DE73 	  sto   $s3,48[$sp]
FFFFFFFFFFFC104C.8     11E73 	  sto   $s4,64[$sp]
FFFFFFFFFFFC104F.0     68B74 	  mov   $s1,$a0             ; save argument value
FFFFFFFFFFFC1051.8 000000850 	  stt   $a0,$4010
FFFFFFFFFFFC1056.0 201401068 
FFFFFFFFFFFC105A.8     1147B 	  ldi   $a0,#OSPAGES
                        	.nextPage:
FFFFFFFFFFFC105D.0     68E74 	  mov   $s4,$a0
FFFFFFFFFFFC105F.8 344FE8541 	  bal   $x1,PAMGetbitPair
FFFFFFFFFFFC1062.0 00148344F 	  bne   $x0,$a0,.notAvailable
FFFFFFFFFFFC1066.8     5CD74 	  mov   $s3,$s4             ; remember start of run
FFFFFFFFFFFC1069.0     56C74 	  mov   $s2,$s1             ; $s2 = run length
                        	.runInc:
FFFFFFFFFFFC106B.8     FEC75 	  sub  	$s2,$s2,#1
FFFFFFFFFFFC106E.0 008C0064E 	  beq   $x0,$s2,.foundRun
FFFFFFFFFFFC1072.8 000139404 	  add   $a0,$s4,#1          ; increment run start
FFFFFFFFFFFC1077.0 022804050 	  slt   $x2,$a0,#MEMSZ
FFFFFFFFFFFC107B.8 1C4E00005 
FFFFFFFFFFFC107E.0 000281C4E 	  beq   $x0,$x2,.outOfMem
FFFFFFFFFFFC1082.8     68E74 	  mov   $s4,$a0             ; remember $a0
FFFFFFFFFFFC1085.0 000000850 	  stt   $s4,$4020
FFFFFFFFFFFC1089.8 200E02068 
FFFFFFFFFFFC108E.0 3640D1141 	  bal		$x1,PAMGetbitPair
FFFFFFFFFFFC1090.8 FF940364E 	  beq   $x0,$a0,.runInc
FFFFFFFFFFFC1095.0 000135404 	  add   $a0,$s3,#1          ; increment run start pos
FFFFFFFFFFFC1099.8     E1C7A 	  bra   .nextPage
                        	.notAvailable:
FFFFFFFFFFFC109C.0 000139404 	  add   $a0,$s4,#1
FFFFFFFFFFFC10A0.8 022804050 	  slt   $x2,$a0,#MEMSZ
FFFFFFFFFFFC10A5.0 2B4000005 
FFFFFFFFFFFC10A7.8 FF0282B4F 	  bne   $x0,$x2,.nextPage
                        	.outOfMem:
FFFFFFFFFFFC10AC.0     FF47B 	  ldi	  $a0,#-1
FFFFFFFFFFFC10AE.8     0287A 	  bra   .xit
                        	.foundRun:
FFFFFFFFFFFC10B1.0     5B474 	  mov  	$a0,$s3
                        	.xit
FFFFFFFFFFFC10B3.8     01E71 		ldo		$ra,[$sp]
FFFFFFFFFFFC10B6.0     05E71 	  ldo   $s1,16[$sp]
FFFFFFFFFFFC10B8.8     09E71 	  ldo   $s2,32[$sp]
FFFFFFFFFFFC10BB.0     0DE71 	  ldo   $s3,48[$sp]
FFFFFFFFFFFC10BD.8     11E71 	  ldo   $s4,64[$sp]
FFFFFFFFFFFC10C0.0     15E75 	  add   $sp,$sp,#80
FFFFFFFFFFFC10C2.8     02074 	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of pages and mark them all allocated.
                        	;
                        	; Parameters:
                        	;   $a0 = amount of memory to allocate
                        	; Returns:
                        	;   $a0 = pointer to memory, -1 if insufficient memory
                        	;   $cr0 = N flag set if insufficient memory
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC10C5.0 000000000 	  align 16
FFFFFFFFFFFC10C9.8 000000000 
FFFFFFFFFFFC10CE.0 F1E750000 
                        	_PAMAlloc:
FFFFFFFFFFFC10D0.0     F1E75 	  sub 	$sp,$sp,#64
FFFFFFFFFFFC10D2.8     01E73 	  sto		$ra,[$sp]
FFFFFFFFFFFC10D5.0     05E73 	  sto   $s1,16[$sp]
FFFFFFFFFFFC10D7.8     09E73 	  sto   $s4,32[$sp]
FFFFFFFFFFFC10DA.0     0DE73 	  sto   $s5,48[$sp]
FFFFFFFFFFFC10DC.8 00805344E 	  beq   $a0,$x0,.outOfMem           ; request sensible?
FFFFFFFFFFFC10E1.0 0FFF50404 	  add   $t0,$a0,#PAGESZ-1   ; round allocation up
FFFFFFFFFFFC10E5.8 440C11402 	  srl   $a0,$t0,#LOG_PGSZ   ; convert size to pages
FFFFFFFFFFFC10EA.0     68E74 	  mov   $s4,$a0             ; $s4 = length of run in pages
FFFFFFFFFFFC10EC.8 230000460 	  ldt   $t0,NPAGES          ; check number of pages of memory available
FFFFFFFFFFFC10F1.0     CA17C 	  sub  	$t0,$t0,$a0
FFFFFFFFFFFC10F3.8 008010648 	  blt		$t0,$x0,.outOfMem
FFFFFFFFFFFC10F8.0 260400068 	  stt   $t0,NPAGES          ; update the number of available pages
FFFFFFFFFFFC10FC.8 1148A1D41 	  bal   $x1,PAMFindRun
FFFFFFFFFFFC10FF.0 0000D1148 	  blt		$a0,$x0,.xit
FFFFFFFFFFFC1103.8     68B74 	  mov   $s1,$a0
FFFFFFFFFFFC1106.0     69774 	  mov   $a3,$a0
FFFFFFFFFFFC1108.8     68F74 	  mov   $s5,$a0             ; $s5 = start of run
                        	.markNext:
FFFFFFFFFFFC110B.0     6F474 	  mov   $a0,$a3
FFFFFFFFFFFC110D.8 000239528 	  slt   $a1,$s4,#2          ; if $s4 <= 1
FFFFFFFFFFFC1112.0 00035550A 	  xor   $a1,$a1,#3          ; $a1 = 3, 2 if end of run
FFFFFFFFFFFC1116.8 37756F541 	  bal  	$x1,PAMSetbitPair
FFFFFFFFFFFC1119.0     03775 	  add   $a3,$a3,#1          ; increment page number
FFFFFFFFFFFC111B.8     FEE75 	  sub   $s4,$s4,#1          ; decrement length
FFFFFFFFFFFC111E.0 FF8E81A48 	  bgt		$s4,$x0,.markNext
FFFFFFFFFFFC1122.8     5F474 	  mov   $a0,$s5             ; $a0 = start of run
FFFFFFFFFFFC1125.0     1947C 	  sll  	$a0,$a0,#LOG_PGSZ   ; $a0 = physical address of page
                        	.xit:
FFFFFFFFFFFC1127.8     01E71 		ldo		$ra,[$sp]
FFFFFFFFFFFC112A.0     05E71 	  ldo   $s1,16[$sp]
FFFFFFFFFFFC112C.8     09E71 	  ldo   $s4,32[$sp]
FFFFFFFFFFFC112F.0     0DE71 	  ldo   $s5,48[$sp]
FFFFFFFFFFFC1131.8     11E75 	  add   $sp,$sp,#64
FFFFFFFFFFFC1134.0     02074 	  ret
                        	.outOfMem:
FFFFFFFFFFFC1136.8     FF47B 	  ldi  	$a0,#-1
FFFFFFFFFFFC1139.0 FE0893C40 	  jmp   .xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Free memory previously allocated with PAMAlloc.
                        	;
                        	; Parameters:
                        	;   $a0 = pointer to start of memory
                        	; Modifies:
                        	;   $a0,$t0,$t1,$t2,$t3,$t4
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC113D.8 9E7500000 	  align 16
                        	_PAMFree:
FFFFFFFFFFFC1140.0     F9E75 	  sub   	$sp,$sp,#32
FFFFFFFFFFFC1142.8     01E73 	  sto			$ra,[$sp]
FFFFFFFFFFFC1145.0     05E73 	  sto     $s1,16[$sp]
FFFFFFFFFFFC1147.8     68B74 	  mov     $s1,$a0
FFFFFFFFFFFC114A.0 140800F50 	  and    	$a0,$a0,#$F8007FFE  ; check page 16kB aligned
FFFFFFFFFFFC114E.8 054F7FFE5 
FFFFFFFFFFFC1151.0 00805054F 	  bne			$a0,$x0,.xit
FFFFFFFFFFFC1155.8 440C2D402 	  srl     $a0,$s1,#LOG_PGSZ   ; convert to page number
FFFFFFFFFFFC115A.0     0287B 	  ldi     $t4,#1
                        	.nextPage:
FFFFFFFFFFFC115C.8     68B74 	  mov     $s1,$a0
FFFFFFFFFFFC115F.0 0D4068941 	  bal    	$x1,PAMGetbitPair
FFFFFFFFFFFC1161.8 0000D0D4E 	  beq			$a0,$x0,.endOfRun
FFFFFFFFFFFC1166.0 000350428 	  slt     $t0,$a0,#3
FFFFFFFFFFFC116A.8     4E479 	  bne			$t0,$x0,.lastPage
FFFFFFFFFFFC116D.0     57474 	  mov     $a0,$s1
FFFFFFFFFFFC116F.8     0157B 	  ldi     $a1,#0
FFFFFFFFFFFC1172.0 0B0041941 	  bal    	$x1,PAMSetbitPair
FFFFFFFFFFFC1174.8 000150B04 	  add     $s1,$a0,#1
FFFFFFFFFFFC1179.0     02875 	  add     $t4,$t4,#1
FFFFFFFFFFFC117B.8     F087A 	  bra     .nextPage  
                        	.lastPage:
FFFFFFFFFFFC117E.0     57474 	  mov     $a0,$s1
FFFFFFFFFFFC1180.8     0157B 	  ldi     $a1,#0
FFFFFFFFFFFC1183.0 287039141 	  bal     $x1,PAMSetbitPair
FFFFFFFFFFFC1185.8     02875 	  add     $t4,$t4,#1
                        	.endOfRun:
FFFFFFFFFFFC1188.0 230001560 	  ldt     $a1,NPAGES
FFFFFFFFFFFC118C.8     91574 	  add     $a1,$a1,$t4
FFFFFFFFFFFC118F.0 261500068 	  stt     $a1,NPAGES
                        	.xit:
FFFFFFFFFFFC1193.8     01E71 		ldo			$ra,[$sp]
FFFFFFFFFFFC1196.0     05E71 	  ldo     $s1,16[$sp]
FFFFFFFFFFFC1198.8     09E75 	  add     $sp,$sp,#32
FFFFFFFFFFFC119B.0     02074 	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a single page of memory. Available memory is indicated by a bitmmap
                        	; called the PAM for page allocation map.
                        	;
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	; Returns:
                        	;		$a0 = page allocated
                        	;   $cr0 = Z flag if can not allocate
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC119D.8 9E7500000 	  align 16
                        	_PAMMarkPage:
FFFFFFFFFFFC11A0.0     F9E75 		sub		$sp,$sp,#32
FFFFFFFFFFFC11A2.8     01E73 		sto		$ra,[$sp]
FFFFFFFFFFFC11A5.0     05E73 		sto   $s1,16[$sp]
FFFFFFFFFFFC11A7.8     1147B 		ldi   $a0,#OSPAGES
FFFFFFFFFFFC11AA.0     68B74 	  mov   $s1,$a0
                        	.0001:
FFFFFFFFFFFC11AC.8     57474 	  mov   $a0,$s1
FFFFFFFFFFFC11AF.0 F47040941 		bal   $x1,PAMGetbitPair
FFFFFFFFFFFC11B1.8     4F478 		beq   $a0,$x0,.gotFree
FFFFFFFFFFFC11B4.0     02B75 		add   $s1,$s1,#1
FFFFFFFFFFFC11B6.8 C42804050 		slt   $t0,$s1,#MEMSZ
FFFFFFFFFFFC11BB.0 C47000002 
FFFFFFFFFFFC11BD.8     BC479 		bne		$t0,$x0,.0001
FFFFFFFFFFFC11C0.0     0147B 		ldi  	$a0,#0
FFFFFFFFFFFC11C2.8     0507A 		bra   .xit
                        	.gotFree:
FFFFFFFFFFFC11C5.0     57474 	  mov  	$a0,$s1
FFFFFFFFFFFC11C7.8     0557B 	  ldi   $a1,#2          ; end of run bits
FFFFFFFFFFFC11CA.0 1E7015941 	  bal  	$x1,PAMSetbitPair
                        	.xit:
FFFFFFFFFFFC11CC.8     01E71 		ldo		$ra,[$sp]
FFFFFFFFFFFC11CF.0     05E71 		ldo   $s1,16[$sp]
FFFFFFFFFFFC11D1.8     09E75 		add   $sp,$sp,#32
FFFFFFFFFFFC11D4.0     02074 	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = page number to free
                        	; Modifies:
                        	;		$a1,$t0,$t1,$t2,$t3
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC11D6.8 000000000 	  align   16
FFFFFFFFFFFC11DB.0 000000000 
FFFFFFFFFFFC11DF.8 42D03F500 
                        	PAMUnmarkPage:
FFFFFFFFFFFC11E0.0 042D03F50 		sgeu    $t0,$a0,#MEMSZ-1   ; last page is permanently allocated to system stack
FFFFFFFFFFFC11E4.8 052CFFFF5 
FFFFFFFFFFFC11E7.0 00085052C 		sltu 		$t1,$a0,#OSPAGES
FFFFFFFFFFFC11EB.8     C437C 		or			$t0,$t0,$t1
FFFFFFFFFFFC11EE.0 00009384F 		bne	    $t0,$x0,PAMxit			    ; first 64 pages (64kB) allocated permanently to system
FFFFFFFFFFFC11F2.8     0157B 		ldi     $a1,#0
                        	; Tail recursion here
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = bit number to set
                        	;   $a1 = value to set 0,1,2 or 3
                        	; Does not modify:
                        	;   $a0, $a1
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	;------------------------------------------------------------------------------
                        	
                        	;  align   4                 ; Minimum alignment for target address of a call
                        	PAMSetbitPair:
FFFFFFFFFFFC11F5.0 440550602 	  srl   $t2,$a0,#5          ; t2 = word
FFFFFFFFFFFC11F9.8     0867C 	  sll   $t2,$t2,#4          ; t2 = word index
FFFFFFFFFFFC11FC.0 001F50708 	  and   $t3,$a0,#31         ; t3 = bit pair no
FFFFFFFFFFFC1200.8     0277C 	  sll   $t3,$t3,#1          ; t3 = bit pair index
FFFFFFFFFFFC1203.0 000000850 		ldo		$t1,PAM[$t2]        ; get word
FFFFFFFFFFFC1207.8 300018560 
FFFFFFFFFFFC120C.0 320755502 		sll		$a1,$a1,$t3					; shift $a1 into position
	ldi		$t4,#~3							; mask off bits in $t1
FFFFFFFFFFFC1210.8     F887B 
FFFFFFFFFFFC1213.0 040720802 		rol		$t4,$t4,$t3
	and		$t1,$t1,$t4
FFFFFFFFFFFC1217.8     D0574 
FFFFFFFFFFFC121A.0     CC27C 		or		$t1,$t1,$a1
                        		;dep   $t1,$a1,$t3,#1
FFFFFFFFFFFC121C.8 000000850 		sto		$t1,PAM[$t2]        ; store word
FFFFFFFFFFFC1221.0 300518068 
FFFFFFFFFFFC1225.8 420755502 		srl		$a1,$a1,$t3					; restore $a1
PAMxit:
FFFFFFFFFFFC122A.0     02074 		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = bit number to get
                        	; Modifies:
                        	;		$t0,$t2,$t3
                        	; Returns:
                        	;   $a0 = value of bit (0, 1, 2, or 3)
                        	;   $cr0 = Z flag set if bit = 0
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC122C.8 020000000 	  align 16
                        	PAMGetbitPair:
FFFFFFFFFFFC1230.0 440550602 	  srl   $t2,$a0,#5          ; $t2 = word
FFFFFFFFFFFC1234.8     0867C 	  sll   $t2,$t2,#4          ; $t2 = word index
FFFFFFFFFFFC1237.0 001F50708 	  and   $t3,$a0,#31         ; $t3 = bit pair no
FFFFFFFFFFFC123B.8     0277C 	  sll   $t3,$t3,#1          ; $t3 = bit pair index
FFFFFFFFFFFC123E.0 000000850 		ldo		$t0,PAM[$t2]        ; get word
FFFFFFFFFFFC1242.8 300018460 
FFFFFFFFFFFC1247.0 420711402 		srl		$a0,$t0,$t3
	and		$a0,$a0,#3
FFFFFFFFFFFC124B.8     07476 
                        	;	extu 	$a0,$t0,$t3,#1     	; extract bits (0, 1, 2, or 3)
FFFFFFFFFFFC124E.0     02074 		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC1250.8 000000000 	  align 16
FFFFFFFFFFFC1255.0 000000000 
FFFFFFFFFFFC1259.8 000000000 
FFFFFFFFFFFC125E.0 FDE750000 
                        	_PAMInit:
FFFFFFFFFFFC1260.0     FDE75 		sub		$sp,$sp,#16
FFFFFFFFFFFC1262.8     01E73 		sto		$ra,[$sp]
                        	  ; First zero out the entire PAM using word stores
FFFFFFFFFFFC1265.0     0147B 	  ldi   $a0,#0
                        	.0002:
FFFFFFFFFFFC1267.8 000000850 	  sto   $x0,PAM[$a0]
FFFFFFFFFFFC126C.0 300050068 
FFFFFFFFFFFC1270.8     21475 	  add   $a0,$a0,#16
FFFFFFFFFFFC1273.0 042802050 	  slt   $t0,$a0,#65536      ; 131072 bit pair = 32,768 bytes
FFFFFFFFFFFC1277.8 647900005 
FFFFFFFFFFFC127A.0     B6479 	  bne  	$t0,$x0,.0002
                        	
                        	  ; Now set bits for preallocated memory pages
FFFFFFFFFFFC127C.8     0F47B 	  ldi   $a0,#OSPAGES-1  ; OS pages
FFFFFFFFFFFC127F.0     0757B 	  ldi   $a1,#3
                        	.0001:
FFFFFFFFFFFC1281.8 F475B9D41 	  bal  	$x1,PAMSetbitPair
FFFFFFFFFFFC1284.0     FF475 	  sub   $a0,$a0,#1
FFFFFFFFFFFC1286.8 FF80D3649 	  bge		$a0,$x0,.0001
FFFFFFFFFFFC128B.0     0F47B 	  ldi   $a0,#OSPAGES-1  ; Last OS page
FFFFFFFFFFFC128D.8     0557B 	  ldi   $a1,#2          ; set mark end of run
FFFFFFFFFFFC1290.0 5570B2941 	  bal  	$x1,PAMSetbitPair
FFFFFFFFFFFC1292.8     0557B 	  ldi   $a1,#2          ; end of run
FFFFFFFFFFFC1295.0 000003F50 	  ldi   $a0,#MEMSZ-1    ; OS stack page
FFFFFFFFFFFC1299.8 FFFF01404 
FFFFFFFFFFFC129E.0 3F50AB941 	  bal  	$x1,PAMSetbitPair
FFFFFFFFFFFC12A0.8 000003F50 	  ldi   $a0,#MEMSZ-2    ; OS stack page
FFFFFFFFFFFC12A5.0 FFFE01404 
FFFFFFFFFFFC12A9.8     0757B 	  ldi   $a1,#3          ; mid run
FFFFFFFFFFFC12AC.0 3F50A4941 	  bal  	$x1,PAMSetbitPair
FFFFFFFFFFFC12AE.8 000003F50 	  ldi   $a0,#MEMSZ-3    ; OS stack page
FFFFFFFFFFFC12B3.0 FFFD01404 
FFFFFFFFFFFC12B7.8 3F509ED41 	  bal  	$x1,PAMSetbitPair
FFFFFFFFFFFC12BA.0 000003F50 	  ldi   $a0,#MEMSZ-4    ; OS stack page
FFFFFFFFFFFC12BE.8 FFFC01404 
FFFFFFFFFFFC12C3.0 1E7099141 	  bal  	$x1,PAMSetbitPair
FFFFFFFFFFFC12C5.8     01E71 	  ldo		$ra,[$sp]
FFFFFFFFFFFC12C8.0     05E75 	  add		$sp,$sp,#16
FFFFFFFFFFFC12CA.8     02074 	  ret
                        	
FFFFFFFFFFFC12CD.0 E75000000 	  align 16
                        	GetPamBit:
FFFFFFFFFFFC12D0.0     FDE75 		sub		$sp,$sp,#16
FFFFFFFFFFFC12D2.8     01E73 		sto		$ra,[$sp]
FFFFFFFFFFFC12D5.0     6B474 	  mov   $a0,$a1
FFFFFFFFFFFC12D7.8 9574AC541 	  bal  	$x1,PAMGetbitPair
FFFFFFFFFFFC12DA.0     69574 	  mov   $a1,$a0
FFFFFFFFFFFC12DC.8     0147B 	  ldi   $a0,#E_Ok
FFFFFFFFFFFC12DF.0     01E71 	  ldo		$ra,[$sp]
FFFFFFFFFFFC12E1.8     05E75 	  add		$sp,$sp,#16
FFFFFFFFFFFC12E4.0 01F6FDC41 	  bra   OSExit
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	;.include "bios-tlb.r64"
                        	;.include "ramtest.r64"
                        	
                        	;.include "../fmtk/msg.r64"
                        	;.include "../fmtk/tcb.r64"
                        	;.include "../fmtk/task.r64"
                        	;.include "../fmtk/io.r64"
                        	;.include "../fmtk/iofocus.r64"
                        	;.include "../fmtk/serial.r64"
                        	;.include "../fmtk/source/drivers/pti_driver.r64"
                        	;.include "../fmtk/app.r64"
                        	;.include "../fmtk/Finalizer.r64"
                        	;.include "../fmtk/gcIncremental.r64"
                        	;.include "../fmtk/source/kernel/fmtk.r64"
                        	;.include "../fmtk/source/kernel/FMTKc.r64"
                        	;.include "../fmtk/source/kernel/SetupDevices.r64"
                        	;.include "../fmtk/source/kernel/pic.r64"
                        	;.include "../fmtk/source/kernel/DBGConsole.r64"
                        	;.include "../fmtk/source/fmtk.l64"
                        	;.include "../fmtk/finalizer.r64"
                        	;.include "../fmtk/gcIncremental.r64"
                        	;.include "TinyBasic.r64"
                        	;.include "../cc64libc/source/rtf64/io.r64"
                        	;.include "../cc64libc/source/cc64libc.l64"
                        	;.include "../c_standard_lib-master/c_standard_lib-master/c_standard_lib.l64"
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	
                        		rodata
                        		align 8
                        	__rodata_start:
                        		rodata
                        		align	2
                        	; Application startup record for system
                        	SystemASR:
FFFFFFFFFFFC4000.0 00                                	  db    0     ; page size (can't change on this system)
FFFFFFFFFFFC4001.0 02                                	  db    2     ; priority normal
FFFFFFFFFFFC4002.0 0C                                	  db    12    ; register set for startup task
FFFFFFFFFFFC4003.0 00                                	  db    0     ; memory map #0
FFFFFFFFFFFC4004.0 00 00 00 00 00 00 00 00           	  dw    0     ; processor affinity
FFFFFFFFFFFC400C.0 00 00 00 00 00 00 00 00           	  dw    0     ; code size (0 = in ROM, don't move)
FFFFFFFFFFFC4014.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC401C.0 00 00 00 00 00 00 00 00           	  dw    0     ; data size (preinitialized data)
FFFFFFFFFFFC4024.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC402C.0 00 00 00 00 00 00 00 00           	  dw    0     ; uninitialized data size
FFFFFFFFFFFC4034.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC403C.0 00 00 00 00 00 00 00 00           	  dw    0     ; Heap size
FFFFFFFFFFFC4044.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC404C.0 00 04 00 00 00 00 00 00           	  dw    1024  ; stack size
FFFFFFFFFFFC4054.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC405C.0 64 0A F8 FF FF FF FF FF           	  dw    IdleTask  ; pointer to code
FFFFFFFFFFFC4064.0 00 00 00 00 00 00 00 00           	  dw    0       ; reserved
FFFFFFFFFFFC406C.0 00 00 00 00 00 00 00 00           	  dw    0     ; pointer to data
FFFFFFFFFFFC4074.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC407C.0 00 00 00 00 00 00 00 00           	  dw    0     ; ui data
FFFFFFFFFFFC4084.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
                        	
                        	; Application startup record for Tiny Basic
                        	TinyBasicASR:
FFFFFFFFFFFC408C.0 00                                	  db    0     ; page size (can't change on this system)
FFFFFFFFFFFC408D.0 02                                	  db    2     ; priority normal
FFFFFFFFFFFC408E.0 00                                	  db    0     ; register set
FFFFFFFFFFFC408F.0 01                                	  db    1     ; memory map
FFFFFFFFFFFC4090.0 00 00 00 00 00 00 00 00           	  dw    0     ; processor affinity
FFFFFFFFFFFC4098.0 00 00 00 00 00 00 00 00           	  dw    0     ; code size (0 = in ROM, don't move)
FFFFFFFFFFFC40A0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40A8.0 00 00 00 00 00 00 00 00           	  dw    0     ; data size (preinitialized data)
FFFFFFFFFFFC40B0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40B8.0 00 80 00 00 00 00 00 00           	  dw    32768 ; uninitialized data size
FFFFFFFFFFFC40C0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40C8.0 00 00 00 00 00 00 00 00           	  dw    0     ; Heap size
FFFFFFFFFFFC40D0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40D8.0 00 08 00 00 00 00 00 00           	  dw    2048  ; stack size
FFFFFFFFFFFC40E0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40E8.0 FC 01 00 00 00 00 00 80           	  dw    CSTART  ; pointer to code
FFFFFFFFFFFC40F0.0 00 00 00 00 00 00 00 00           	  dw    0       ; reserved
FFFFFFFFFFFC40F8.0 00 00 00 00 00 00 00 00           	  dw    0     ; pointer to data
FFFFFFFFFFFC4100.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC4108.0 00 00 00 00 00 00 00 00           	  dw    0     ; ui data
FFFFFFFFFFFC4110.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
                        	    
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFFFFFFFFFC4118.0 46 65 6D 74 69 6B 69 20 53 79     			db		"Femtiki System Starting.",10
FFFFFFFFFFFC4122.0 73 74 65 6D 20 53 74 61 72 74  
FFFFFFFFFFFC412C.0 69 6E 67 2E 0A  
                        	msgMonHelp:
FFFFFFFFFFFC4131.0 4D 6F 6E 69 74 6F 72 20 43 6F     			db		"Monitor Commands",10
FFFFFFFFFFFC413B.0 6D 6D 61 6E 64 73 0A  
FFFFFFFFFFFC4142.0 42 20 2D 20 73 74 61 72 74 20     			db		"B - start tiny basic",10
FFFFFFFFFFFC414C.0 74 69 6E 79 20 62 61 73 69 63  
FFFFFFFFFFFC4156.0 0A  
FFFFFFFFFFFC4157.0 44 20 2D 20 64 75 6D 70 20 72     			db		"D - dump ready que",10
FFFFFFFFFFFC4161.0 65 61 64 79 20 71 75 65 0A  
FFFFFFFFFFFC416A.0 45 20 2D 20 65 64 69 74 20 6D     			db		"E - edit memory",10
FFFFFFFFFFFC4174.0 65 6D 6F 72 79 0A  
FFFFFFFFFFFC417A.0 46 20 2D 20 66 69 6C 6C 20 6D     			db		"F - fill memory",10
FFFFFFFFFFFC4184.0 65 6D 6F 72 79 0A  
FFFFFFFFFFFC418A.0 46 49 20 3C 73 74 72 69 6E 67     			db    "FI <string>- find string in memory",10
FFFFFFFFFFFC4194.0 3E 2D 20 66 69 6E 64 20 73 74  
FFFFFFFFFFFC419E.0 72 69 6E 67 20 69 6E 20 6D 65  
FFFFFFFFFFFC41A8.0 6D 6F 72 79 0A  
FFFFFFFFFFFC41AD.0 4B 20 3C 74 69 64 3E 20 2D 20     			db		"K <tid> - kill task", 10
FFFFFFFFFFFC41B7.0 6B 69 6C 6C 20 74 61 73 6B 0A  
FFFFFFFFFFFC41C1.0 4D 20 3C 73 74 61 72 74 3E 20     			db		"M <start> <length>	- dump memory",10
FFFFFFFFFFFC41CB.0 3C 6C 65 6E 67 74 68 3E 09 2D  
FFFFFFFFFFFC41D5.0 20 64 75 6D 70 20 6D 65 6D 6F  
FFFFFFFFFFFC41DF.0 72 79 0A  
FFFFFFFFFFFC41E2.0 50 20 2D 20 64 69 73 70 6C 61     			db    "P - display PAM",10
FFFFFFFFFFFC41EC.0 79 20 50 41 4D 0A  
FFFFFFFFFFFC41F2.0 53 20 2D 20 73 77 69 74 63 68     			db		"S - switch task",10
FFFFFFFFFFFC41FC.0 20 74 61 73 6B 0A  
FFFFFFFFFFFC4202.0 56 20 3C 6D 69 64 3E 20 64 75     			db    "V <mid> dump virtual memory map",10
FFFFFFFFFFFC420C.0 6D 70 20 76 69 72 74 75 61 6C  
FFFFFFFFFFFC4216.0 20 6D 65 6D 6F 72 79 20 6D 61  
FFFFFFFFFFFC4220.0 70 0A  
FFFFFFFFFFFC4222.0 00                                			db		0
                        			; align cache
                        	msgTaskStart:
FFFFFFFFFFFC4223.0 20 74 61 73 6B 20 73 74 61 72     			db		" task started."
FFFFFFFFFFFC422D.0 74 65 64 2E  
                        	msgCRLF:
FFFFFFFFFFFC4231.0 0D 0A 00                          			db		13,10,0
                        	msgPrompt:
FFFFFFFFFFFC4234.0 0D 0A 3E                          		db      CR,LNFD,'>',0
                        	flt50:
FFFFFFFFFFFC4237.0 00 00 00 00 00 00 00 00 00 00     		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFFFFFFFFFC4241.0 00 00 00 00 00 00 00 00 00 00  
FFFFFFFFFFFC424B.0 00 00 00 00 00 90 04 40 00 00  
FFFFFFFFFFFC4255.0 00 00  
                        	flt20:
FFFFFFFFFFFC4257.0 00 00 00 00 00 00 00 00 00 00     		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFFFFFFFFFC4261.0 00 00 00 00 00 00 00 00 00 00  
FFFFFFFFFFFC426B.0 00 00 00 00 00 40 03 40 00 00  
FFFFFFFFFFFC4275.0 00 00  
                        	flt10:
FFFFFFFFFFFC4277.0 00 00 00 00 00 00 00 00 00 00     		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFFFFFFFFFC4281.0 00 00 00 00 00 00 00 00 00 00  
FFFFFFFFFFFC428B.0 00 00 00 00 00 40 02 40 00 00  
FFFFFFFFFFFC4295.0 00 00  
                        	
                        	;.include "fltToString.r64"
                        	;.include "bios-mem.r64"
                        	.file "bios-pam.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	
                        		rodata
FFFFFFFFFFFC4297.0 00                                		align 8
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8
                        	end_init_data:
                        	_end_init_data:

rodata start: FFFFFFFFFFF88000
data start:                0
bss start:                0

634 symbols
  Symbol Name                              seg     address bits references
  BS                                        const  000004.0 0 5
  CR                                        const  000006.1 0 5
  CSR_DCAUSE                                const  002003.0 0 16
  CSR_DSCRATCH                              const  002020.1 0 16
  CSR_DTCBPTR                                code  c0000000000000ce.1 0 32
  CSR_MEPC                                  const  001824.0 0 15
  CSR_MSEMA                                 const  001860.1 0 15
  CSR_REGSET                                const  002809.0 0 16
  CSR_TASKID                                const  000808.0 0 14
  CSR_TRACECTRL                             const  003850.0 0 16
  CSTART                                     code  c0000000000000fe.0 0 32
  CURIN                                     const  0001b8.0 0 11
  CUROUT                                    const  0001b8.1 0 11
  CheckDevOwner                              code  c0000000000000ee.1 0 32
  CopyDevDCB                                 code  c000000000000127.1 0 32
  CopyDevFuncTbl                             code  c000000000000126.1 0 32
  DBGATTR                                   const  1fffff060df8000.0 0 59
  DBGRout                                    code  fffffffffffc0ff2.0 0 18
  DBGxit                                     code  c000000000000121.0 0 32
  DEL                                       const  00003f.1 0 8
  DVF_Base                                  const  001000.0 0 15
  DumpReadyQueue                             code  c0000000000000db.0 0 32
  DumpTimeoutList                            code  c0000000000000ff.1 0 32
  DumpTraceQueue                             code  fffffffffffc0dca.0 0 18
  DumpTraceQueue.dmpTrace                    code  fffffffffffc0dce.1 0 18
  DumpTraceQueue.dmpTraceEmpty               code  fffffffffffc0deb.0 0 18
  DumpTraceQueue.inf                         code  fffffffffffc0df0.0 0 18
  EOF                                       const  00000d.0 0 6
  EditMem                                    code  fffffffffffc0ade.1 0 18
  FLT_WD                                    const  00001b.0 0 7
  FillMem                                    code  fffffffffffc0b4c.1 0 18
  FillMem.0001                               code  fffffffffffc0b5e.0 0 18
  Finalizer                                  code  c0000000000000d7.1 0 32
  Find                                       code  fffffffffffc0b70.1 0 18
  Find.endOfWord                             code  fffffffffffc0b91.1 0 18
  Find.found                                 code  fffffffffffc0bde.1 0 18
  Find.fwe                                   code  fffffffffffc0b78.0 0 18
  Find.loop                                  code  fffffffffffc0b9d.1 0 18
  Find.next                                  code  fffffffffffc0bc0.1 0 18
  Find.notFound                              code  fffffffffffc0be6.0 0 18
  GetDecNum                                  code  fffffffffffc0c6f.1 0 18
  GetDecNum.0001                             code  fffffffffffc0c87.0 0 18
  GetDecNum.isDigit                          code  fffffffffffc0c8e.1 0 18
  GetDecNum.next                             code  fffffffffffc0c79.1 0 18
  GetHexNum                                  code  fffffffffffc0c07.0 0 18
  GetHexNum.0001                             code  fffffffffffc0c39.1 0 18
  GetHexNum.isDigit                          code  fffffffffffc0c63.0 0 18
  GetHexNum.isHexLower                       code  fffffffffffc0c52.0 0 18
  GetHexNum.isHexUpper                       code  fffffffffffc0c41.0 0 18
  GetHexNum.next                             code  fffffffffffc0c11.0 0 18
  GetUIFlag                                  code  c0000000000000ec.1 0 32
  Getch                                      code  fffffffffffc0610.0 0 18
  INBUF                                     const  000080.0 0 10
  IRQCause                                  const  00084c.0 0 14
  IRQFlag                                   const  000848.0 0 14
  IRQRout                                    code  fffffffffffc0e80.0 0 18
  IRQRout.InitDev                            code  fffffffffffc0f5d.0 0 18
  IRQRout.brk                                code  fffffffffffc0eba.1 0 18
  IRQRout.devAgain                           code  fffffffffffc0f35.1 0 18
  IRQRout.gcIrq                              code  fffffffffffc0fbf.0 0 18
  IRQRout.isIRQ                              code  fffffffffffc0edc.1 0 18
  IRQRout.noIRQ                              code  fffffffffffc0f4a.1 0 18
  IRQRout.notSerial                          code  fffffffffffc0f8d.0 0 18
  IRQRout.notVia                             code  fffffffffffc0fba.1 0 18
  IRQRout.soc                                code  fffffffffffc0eb6.0 0 18
  IRQRout.softwareIrq                        code  fffffffffffc0f4f.1 0 18
  IRQRout.timerIrq                           code  fffffffffffc0f4f.1 0 18
  IRQRout.unimp                              code  fffffffffffc0e96.1 0 18
  IdleTask                                   code  fffffffffffc0532.0 0 18
  IdleTask.IdleCode                          code  fffffffffffc058c.0 0 18
  IdleTask.loop                              code  fffffffffffc054b.1 0 18
  IdleTask.loop2                             code  fffffffffffc0544.1 0 18
  IdleTask.nxtObj                            code  fffffffffffc05ce.0 0 18
  IdleTaskMbx                               const  000608.0 0 13
  IdleTaskMsgD1                             const  00060c.0 0 13
  IdleTaskMsgD2                             const  000610.0 0 13
  IdleTaskMsgD3                             const  000614.0 0 13
  LEDS                                      const  ffffffffff910000.0 0 25
  LNFD                                      const  000005.0 0 5
  LOG_TCBSZ                                 const  000005.0 0 5
  MBX_BLOCKPTR_BUFSZ                        const  000004.0 0 5
  MEPC1                                     const  0001ac.0 0 11
  MMUInit                                    code  c0000000000000d2.1 0 32
  MachineStart                               code  fffffffffffc0300.0 0 18
  MachineStart.0001                          code  fffffffffffc0384.0 0 18
  MbxBlockPtr                               const  000850.0 0 14
  Monitor                                    code  fffffffffffc0862.0 0 18
  Monitor.0001                               code  fffffffffffc0870.0 0 18
  Monitor.0002                               code  fffffffffffc089e.1 0 18
  Monitor.0003                               code  fffffffffffc08c8.1 0 18
  Monitor.0004                               code  fffffffffffc0902.1 0 18
  Monitor.0005                               code  fffffffffffc0a39.0 0 18
  Monitor.0006                               code  fffffffffffc09ac.0 0 18
  Monitor.0007                               code  fffffffffffc09d0.1 0 18
  Monitor.0009                               code  fffffffffffc09f7.1 0 18
  Monitor.0010                               code  fffffffffffc0a0c.1 0 18
  Monitor.0011                               code  fffffffffffc0a24.0 0 18
  Monitor.0012                               code  fffffffffffc0a39.0 0 18
  Monitor.basSize                            code  fffffffffffc0952.1 0 18
  Monitor.doBackspace                        code  fffffffffffc08bc.1 0 18
  Monitor.doDelete                           code  fffffffffffc0899.1 0 18
  Monitor.noT                                code  fffffffffffc09c9.1 0 18
  Monitor.notFind                            code  fffffffffffc09f5.0 0 18
  Monitor.notX                               code  fffffffffffc0920.1 0 18
  Monitor.procLine                           code  fffffffffffc08e6.1 0 18
  Monitor.skip                               code  fffffffffffc08ed.1 0 18
  Monitor.skip2                              code  fffffffffffc08fd.1 0 18
  OBJMagic                                  const  000000.0 0 1
  OSECALL                                    code  c000000000000122.0 0 32
  OSOCall                                    code  c0000000000000d5.0 0 32
  PAMFindRun.foundRun                        code  fffffffffffc10b1.0 0 19
  PAMFindRun.nextPage                        code  fffffffffffc105d.0 0 19
  PAMFindRun.notAvailable                    code  fffffffffffc109c.0 0 19
  PAMFindRun.outOfMem                        code  fffffffffffc10ac.0 0 19
  PAMFindRun.runInc                          code  fffffffffffc106b.1 0 19
  PAMFindRun.xit                             code  fffffffffffc10b3.1 0 19
  PutCRLF                                    code  fffffffffffc0d8c.0 0 18
  PutHexByte                                 code  fffffffffffc0ce2.1 0 18
  PutHexHalf                                 code  c00000000000010b.0 0 32
  PutHexNybble                               code  fffffffffffc0cf8.0 0 18
  PutHexNybble.lt10                          code  fffffffffffc0d0e.0 0 18
  PutHexOcta                                 code  fffffffffffc0ca2.0 0 18
  PutHexTetra                                code  fffffffffffc0cb7.1 0 18
  PutHexWord                                 code  c000000000000106.0 0 32
  PutHexWyde                                 code  fffffffffffc0ccd.0 0 18
  PutString                                  code  fffffffffffc0da2.1 0 18
  PutString.0001                             code  fffffffffffc0daf.0 0 18
  PutString.done                             code  fffffffffffc0dbd.1 0 18
  Putch                                      code  fffffffffffc0630.0 0 18
  ROMBASE                                   const  fffffffffffc0000.0 0 21
  SCRATCHMEM                                const  ffffffffff400000.0 0 26
  SerialDCB                                  code  c000000000000127.0 0 32
  SerialFuncTbl                              code  c000000000000126.0 0 32
  SerialPutChar                              code  c0000000000000eb.1 0 32
  SkipSpaces                                 code  fffffffffffc0beb.0 0 18
  SkipSpaces.done                            code  fffffffffffc0c04.1 0 18
  SkipSpaces.skip2                           code  fffffffffffc0beb.0 0 18
  SystemASR                                rodata  fffffffffffc4000.0 0 32
  TBASR                                      code  c0000000000000fc.0 0 32
  TCBPriority                               const  000170.1 0 11
  TCBStatus                                 const  000170.0 0 11
  TCB_MAGIC                                 const  102a21a1.0 0 31
  TEXTSCR                                   const  ffffffffff800000.0 0 26
  TS_READY                                  const  000000.1 0 2
  TinyBasicASR                             rodata  fffffffffffc408c.0 0 32
  UserStart                                  code  fffffffffffc046e.0 0 18
  UserStart2                                 code  fffffffffffc0475.0 0 18
  UserStart2.appBad                          code  fffffffffffc0485.0 0 18
  ViaDCB                                     code  c000000000000129.0 0 32
  ViaFuncTbl                                 code  c000000000000128.1 0 32
  WaitForIOFocus                             code  c0000000000000ed.1 0 32
  _DBGAttr                                  const  ffffffffff400000.0 0 26
  _Delay2s                                   code  fffffffffffc05f0.0 0 18
  _Delay2s.0001                              code  fffffffffffc05f2.1 0 18
  _FMTKInit                                  code  c0000000000000d3.0 0 32
  _InitPIC                                   code  c0000000000000d3.1 0 32
  _cursorX                                  const  ffffffffff400004.0 0 26
  _cursorY                                  const  ffffffffff400004.1 0 26
  _pti_init                                  code  c0000000000000d1.1 0 32
  _pti_read_block                            code  c0000000000000d2.0 0 32
  calcScreenPos                              code  fffffffffffc0660.0 0 18
  calcScreenPos.0001                         code  fffffffffffc068e.0 0 18
  calcScreenPos.0002                         code  fffffffffffc066d.1 0 18
  calcScreenPos.0003                         code  fffffffffffc069c.0 0 18
  calcScreenPos.0004                         code  fffffffffffc067f.1 0 18
  dbg_BlankLastLine                          code  fffffffffffc0790.0 0 18
  dbg_BlankLastLine.0001                     code  fffffffffffc07a2.1 0 18
  dbg_HomeCursor                             code  fffffffffffc07b5.0 0 18
  dbg_Putch                                  code  fffffffffffc0700.0 0 18
  dbg_Putch.cr                               code  fffffffffffc0751.0 0 18
  dbg_Putch.lf                               code  fffffffffffc072c.1 0 18
  dbg_Putch.xit                              code  fffffffffffc0725.0 0 18
  dbg_ScrollUp                               code  fffffffffffc0760.0 0 18
  dbg_ScrollUp.0001                          code  fffffffffffc0770.1 0 18
  doMem                                      code  fffffffffffc0a3b.1 0 18
  doMem.0002                                 code  fffffffffffc0aa5.1 0 18
  doMem.0003                                 code  fffffffffffc0ad0.0 0 18
  doMem.0004                                 code  fffffffffffc0abd.0 0 18
  doMem.loop                                 code  fffffffffffc0a8b.0 0 18
  doMem.unprintable                          code  fffffffffffc0acb.0 0 18
  doMem.userMem                              code  fffffffffffc0aa1.0 0 18
  doPState                                   code  c0000000000000fa.0 0 32
  doVMem                                     code  fffffffffffc0aef.1 0 18
  doVMem.notLF                               code  fffffffffffc0b05.0 0 18
  fgetc                                      code  fffffffffffc0819.0 0 18
  fgetc.0001                                 code  fffffffffffc083d.0 0 18
  fgetc.0002                                 code  fffffffffffc084b.1 0 18
  fgetc.checkOwner                           code  fffffffffffc0833.1 0 18
  fgetc.notOwner                             code  fffffffffffc0858.0 0 18
  fputc                                      code  fffffffffffc07c9.1 0 18
  fputc.0001                                 code  fffffffffffc07f9.0 0 18
  fputc.checkOwner                           code  fffffffffffc07f2.0 0 18
  fputc.noBypass                             code  fffffffffffc07e1.1 0 18
  fputc.notOwner                             code  fffffffffffc0814.0 0 18
  fputc.xit                                  code  fffffffffffc0807.1 0 18
  gcIncrement                                code  c000000000000129.1 0 32
  incScreenPos                               code  fffffffffffc06b0.0 0 18
  incScreenPos.0001                          code  fffffffffffc06f3.1 0 18
  incScreenPos.0002                          code  fffffffffffc06e8.0 0 18
  loop2                                      code  c000000000000108.0 0 32
  msgMonHelp                               rodata  fffffffffffc4131.0 0 32
  msgPrompt                                rodata  fffffffffffc4234.0 0 32
  msgTaskStart                             rodata  fffffffffffc4223.0 0 32

Undefined Symbols
  CSR_DTCBPTR                                code  800000000000019d 32 3
  CSTART                                     code  80000000000001fc 32 2
  CheckDevOwner                              code  80000000000001dd 32 2
  CopyDevDCB                                 code  800000000000024f 32 2
  CopyDevFuncTbl                             code  800000000000024d 32 2
  DBGxit                                     code  8000000000000242 32 5
  DumpReadyQueue                             code  80000000000001b6 32 3
  DumpTimeoutList                            code  80000000000001ff 32 1
  Finalizer                                  code  80000000000001af 32 1
  GetUIFlag                                  code  80000000000001d9 32 2
  MMUInit                                    code  80000000000001a5 32 1
  OSECALL                                    code  8000000000000244 32 1
  OSOCall                                    code  80000000000001aa 32 1
  PutHexHalf                                 code  8000000000000216 32 1
  PutHexWord                                 code  800000000000020c 32 2
  SerialDCB                                  code  800000000000024e 32 1
  SerialFuncTbl                              code  800000000000024c 32 1
  SerialPutChar                              code  80000000000001d7 32 1
  TBASR                                      code  80000000000001f8 32 1
  ViaDCB                                     code  8000000000000252 32 1
  ViaFuncTbl                                 code  8000000000000251 32 1
  WaitForIOFocus                             code  80000000000001db 32 2
  _FMTKInit                                  code  80000000000001a6 32 1
  _InitPIC                                   code  80000000000001a7 32 1
  _pti_init                                  code  80000000000001a3 32 1
  _pti_read_block                            code  80000000000001a4 32 1
  doPState                                   code  80000000000001f4 32 1
  gcIncrement                                code  8000000000000253 32 1
  loop2                                      code  8000000000000210 32 1

  Macro Name
0 compressable instructions
The top 1024 are:
Comp  Opcode  Count

Instruction Statistics
Loads:         0 (0.000000%)
Stores:        0 (0.000000%)
  Indexed:     0 (0.000000%)
Pushes:        0 (0.000000%)
Compares:      5 (0.442478%)
Branches:     58 (5.132743%)
BEQZ/NEZ:	     0 (0.000000%)
  BEQI:		     0 (0.000000%)
  BNEI:		     0 (0.000000%)
  BBc:		     0 (0.000000%)
  BLcc:		     0 (0.000000%)
Calls:		   144 (12.743363%)
Returns:	   108 (9.557522%)
Adds:	        79 (6.991150%)
Subs:	         0 (0.000000%)
Ands:	         6 (0.530973%)
Ors:	         0 (0.000000%)
Xors:	         1 (0.088496%)
Bits:	         0 (0.000000%)
Tsts:	         0 (0.000000%)
Lshifts:       0 (0.000000%)
shifts:	       0 (0.000000%)
Luis:	         0 (0.000000%)
Moves:	       0 (0.000000%)
CMoves:	       0 (0.000000%)
Sets:	        16 (1.415929%)
  Mops:        0 (0.000000%)
Ptrdif:        0 (0.000000%)
Bitfield:      0 (0.000000%)
Csr:		      28 (2.477876%)
Floatops:      0 (0.000000%)
others:      718 (63.539823%)
Total:      1130

number of bytes: 3847.000000
number of instructions: 1130
number of compressed instructions: 619
3.404425 bytes (27 bits) per instruction
Compression ratio: 24.346116%
Number of long branches: 0
