                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/const.r64",1
                        	.file "../fmtk/const.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_UNDEAD   EQU   64
                        	TS_RUNNING	EQU		128
                        	
                        	AS_NONE     EQU   0
                        	AS_LIVE     EQU   1
                        	AS_DEAD     EQU   2
                        	AS_UNDEAD   EQU   4
                        	
                        	PRI_NORMAL  EQU   2
                        	PRI_LOW     EQU   3
                        	
                        	OST_WHITE   EQU   0
                        	OST_GREY    EQU   1
                        	OST_BLACK   EQU   2
                        	OST_UNDEAD  EQU   64    ; no longer alive, but not dead yet (finalizer hasn't been called)
                        	OST_DEAD    EQU   128   ; completely dead, finalizer called already
                        	
                        	TCB_MAGIC     EQU   ((' ' << 24) | ('T' << 16) | ('C' << 8) | 'B')
ACB_MAGIC     EQU   ((' ' << 24) | ('A' << 16) | ('C' << 8) | 'B')
MSG_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('S' << 8) | 'G')
MBX_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('B' << 8) | 'X')

                        	UNDEADQ     EQU   7
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_Func  =   0x02
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadDCBOffset = 0x1A
                        	E_Busy = 0x1B
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	E_BadTcbPointer = 0x27
                        	E_BadTid = 0x28
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	= 0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMoreAppIds = 0x46
                        	E_NoMem = 0x47
                        	
                        	CSR_TRACECTRL = $70A0
                        	CSR_PTA     = $1003
                        	CSR_TASKID  = $1010
                        	CSR_ASID    = $101F
                        	CSR_MSTATUS = $3000
                        	CSR_RSSTACK = $3043
                        	CSR_PMSTACK = $3040
                        	CSR_MEPC    = $3048
                        	CSR_MSEMA   = $30C1
                        	
                        	CSR_REGSET  = $5012
                        	CSR_DBAD0   = $5018
                        	CSR_DBAD1   = $5019
                        	CSR_DBAD2   = $501A
                        	CSR_DBAD3   = $501B
                        	CSR_DBCR    = $501C
                        	CSR_DBSR    = $501D
                        	
                        	TCBPTR_MASK = $FFF803FF
                        	
                        	; Message types
                        	MT_ANNOUNCE = $00000010
                        	MT_IRQ      = $FFFFFFFF
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/types.r64",1
                        	.file "../fmtk/types.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	OBJMagic    EQU   0
                        	OBJSize     EQU   8
                        	OBJTypenum  EQU   16
                        	OBJID       EQU   20
                        	OBJState    EQU   24    ; WHITE, GREY, BLACK
                        	OBJScavcnt  EQU   25    ; scavange count
                        	OBJOwningMap  EQU   26
                        	OBJPad1       EQU   27
                        	OBJCollectionIndex  EQU   28
                        	OBJUsedInMap  EQU   32    ; used in map
                        	OBJPad3       EQU   36
                        	OBJFWAddr     EQU   40    ; forwarding address
                        	OBJFinalizer  EQU   48
                        	OBJ_SIZE      EQU   64
                        	
                        	; Task Control Block
                        	TCBObject   EQU   $000    ; Object structure, state
                        	TCBIntRegs  EQU   $040    ; integer register set storage area (room for 64-bit)
                        	TCBxCR      EQU   $040
                        	TCBxRA      EQU   $048
                        	TCBxSP      EQU   $050
                        	TCBxGP      EQU   $058
                        	TCBxTP      EQU   $060
                        	TCBxT0      EQU   $068
                        	TCBxT1      EQU   $070
                        	TCBxT2      EQU   $078
                        	TCBxFP      EQU   $080
                        	TCBxS1      EQU   $088
                        	TCBxA0      EQU   $090
                        	TCBxA1      EQU   $098
                        	TCBxA2      EQU   $0A0
                        	TCBxA3      EQU   $0A8
                        	TCBxA4      EQU   $0B0
                        	TCBxA5      EQU   $0B8
                        	TCBxA6      EQU   $0C0
                        	TCBxA7      EQU   $0C8
                        	TCBxS2      EQU   $0D0
                        	TCBxS3      EQU   $0D8
                        	TCBxS4      EQU   $0E0
                        	TCBxS5      EQU   $0E8
                        	TCBxS6      EQU   $0F0
                        	TCBxS7      EQU   $0F8
                        	TCBxS8      EQU   $100
                        	TCBxS9      EQU   $108
                        	TCBxS10     EQU   $110
                        	TCBxS11     EQU   $118
                        	TCBxT3      EQU   $120
                        	TCBxT4      EQU   $128
                        	TCBxT5      EQU   $130
                        	TCBxT6      EQU   $138
                        	TCBxRA0     EQU   $140
                        	TCBxRA1     EQU   $148
                        	TCBxCN      EQU   $150
                        	TCBFltRegs  EQU   $158    ; float register set storage area
                        	TCBRegsEnd  EQU   $258
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBbases  	EQU		$258		; base register storage
                        	TCBepc  		EQU		$2D8
                        	TCBStatus		EQU		$2E0
                        	TCBPriority	EQU		$2E1
                        	TCBWaitMbx	EQU		$2E2
                        	TCBRegset   EQU   $2E3
                        	TCBHasFocus EQU   $2E4
                        	TCBStackBot	EQU		$2E8
                        	TCBMsgD1		EQU		$2F0
                        	TCBMsgD2		EQU		$2F8
                        	TCBMsgD3		EQU		$300
                        	TCBStartTick	EQU	$308
                        	TCBEndTick	EQU		$310
                        	TCBTicks		EQU		$318
                        	TCBException	EQU	$320
                        	TCBNext			EQU		$328
                        	TCBPrev			EQU		$330
                        	TCBTimeout	EQU		$338
                        	TCBtid      EQU   $340
                        	TCBmid      EQU   $342
                        	TCBappid    EQU   $344
                        	TCBOpMode   EQU   $346
                        	TCBMbxNext  EQU   $348
                        	TCBMbxPrev  EQU   $350
                        	TCBTaskNum  EQU   $358
                        	TCBName			EQU		$360
                        	
                        	; Application Control Block
                        	ACBObject     EQU   0
                        	ACBpData      EQU   64
                        	ACBDataSize   EQU   72
                        	ACBpUIData    EQU   80
                        	ACBUIDataSize EQU   88
                        	ACBGCRoots    EQU   96
                        	ACBGCRootCnt  EQU   104
                        	ACBGCNdx      EQU   112
                        	ACBGCMarkingQue EQU   120
                        	ACBGCMarkingQueFull   EQU   128
                        	ACBGCMarkingQueEmpty  EQU   129
                        	ACBGCOverflow EQU   130
                        	ACBpCode      EQU   134
                        	ACBObjectList EQU   144
                        	ACBGarbageList  EQU   152
                        	ACBHeap       EQU   160   ; 640+ bytes for heap object info
                        	ACBiofNext    EQU   824
                        	ACBiofPrev    EQU   832
                        	ACBUserName   EQU   840   ; 2 byte index of string in string area
                        	ACBPath       EQU   842   ; 2 byte index of string in string area
                        	ACBExitRunFile  EQU   844 ; 2 byte index of string in string area
                        	ACBCommandLine  EQU   846 ; 2 byte index of string in string area
                        	ACBpVidMem    EQU   848
                        	ACBpVirtVidMem  EQU 856
                        	ACBVideoRows  EQU   864
                        	ACBVideoCols  EQU   865
                        	ACBCursorRow  EQU   866
                        	ACBCursorCol  EQU   867
                        	ACBNormAttr   EQU   868
                        	ACBKeyState1  EQU   872
                        	ACBKeyState2  EQU   874
                        	ACBKeybdWaitFlag  EQU   876
                        	ACBKeybdHead  EQU   878
                        	ACBKeybdTail  EQU   879
                        	ACBKeybdBuffer  EQU   880
                        	ACBnumber     EQU   944
                        	ACBNext       EQU   952
                        	ACBTask       EQU   960
                        	ACBHasFocus   EQU   962
                        	ACBmid        EQU   964
                        	ACBStatus     EQU   966
                        	ACBTemplates  EQU   968   ; 256 * 8 bytes reserved for template pointers
                        	ACBPad        EQU   3016
                        	ACBStrings    EQU   3072  ; start of 1kB string area
                        	ACBEnd        EQU   4096
                        	
                        	; Application startup record
                        	ASRPageSize   EQU   0
                        	ASRPriority   EQU   1
                        	ASRRegset     EQU   2
                        	ASRmid        EQU   3
                        	ASRAffinity   EQU   4
                        	ASRCodeSize   EQU   8
                        	ASRDataSize   EQU   16
                        	ASRUIDataSize EQU   24
                        	ASRHeapSize   EQU   32
                        	ASRStackSize  EQU   40
                        	ASRpCode      EQU   48
                        	ASRpData      EQU   56
                        	ASRpUIData    EQU   64
                        	ASR_SIZE      EQU   72
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	;MBX_WTIDS			equ		4		; tasks waiting at mailbox
                        	MBX_LINK      equ   8
                        	MBX_TQHEAD    equ   8   ; link field for free list shared with task queue head
                        	MBX_TQTAIL    equ   16
                        	MBX_MQHEAD		equ		24		
                        	MBX_MQTAIL		equ		32
                        	MBX_SIZE			equ		40
                        	
                        	MSG_LINK	  equ		0
                        	MSG_RETADR  equ   8
                        	MSG_TGTADR  equ   10
                        	MSG_TYPE    equ   12
                        	MSG_D1		  equ		16
                        	MSG_D2		  equ		24
                        	MSG_D3		  equ		32
                        	MSG_SIZE	  equ		40
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/config.r64",1
                        	.file "../fmtk/config.r64",1
                        	MAX_TID		EQU		15
                        	NR_TCB		EQU		32
                        	NTASK     EQU   32      ; number of tasks allowed
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		12
                        	LOG_ACBSZ EQU   12
                        	OSPAGES		EQU		8		    ; pages of memory dedicated to OS
                        	MAXVPG    EQU   32767   ; maximum virtual page number
                        	PAGESZ    EQU   4096    ; size of a page of memory
                        	MEMSZ     EQU   131072  ; 4096B pages
                        	MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/device.r64",1
                        	.file "../fmtk/device.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2021  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_fUI       EQU   0x3A    ; user interface device
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x60
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	DVC_IsUI          EQU   27
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Front Panel 		FP
                        	;11
                        	;12		Hard disk				HD1
                        	;13		Hard disk				HD2
                        	;14
                        	;15   Time slice / GP	VIA
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/macro.r64",1
                        	.file "../fmtk/macro.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; disable interrupts
                        	macro mDI
  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
endm
                        	
                        	; disable interrupts
                        	macro mEI
  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
endm
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		$a0,#-1
	sto		$a0,adr
endm
                        	
                        	macro mGetCurrentTid
  csrrw $a0,#CSR_TASKID,$x0
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	brk   #240
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#tm
	brk   #240
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   a1 = device # to check
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
  mov   $t2,$a1
	
	ldi		$a0,#20
	brk   #240
tst   $a1
	bne 	.HasFocus@
	ldi   $a0,#26             ; FMTK_IO
	mov   $a1,$t2
	ldi   $a2,#9              ; peekchar function
	brk   #240
	sne		$a0,#$14						; CTRL-T
	bt		.WFF2@
	; eat up the CTRL-T
	ldi		$a0,#26							; FMTK_IO
	mov   $a1,$t2
	ldi		$a2,#8							; getchar function
	brk   #240
	ldi		$a0,#21							; switch IO Focus
	brk   #240
	jmp		.WFF1@
.WFF2@:
	
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#1
	brk   #240

	jmp		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = mailbox handle
                        	; Modifies:
                        	;   $t0
                        	; Returns:
                        	;   $a0 = mailbox pointer
                        	;------------------------------------------------------------------------------
                        	
                        	macro mMbxHandleToPointer
  lsr   $t0,$a0,#8    ; extract collection index
  asl   $t0,$t0,#2
  ldt   $t0,MbxBlockPtr[$t0]
  and   $a0,$a0,#$FF
  asl   $a0,$a0,#2
  or    $a0,$a0,$t0
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list pointer to TCB
                        	;------------------------------------------------------------------------------
                        	
                        	;macro mPopTimeoutList
                        	;	lbu		$v1,TCBStatus[$v0]		; no longer a waiting status
                        	;	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
                        	;	beqz	$t1,.noWait@
                        	;	ldbu  $a0,TCBtid[$v0]
                        	;	mMbxRemoveTask							; remove task from mailbox list
                        	.noWait@:
                        	;	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
                        	;	stb		$v1,TCBStatus[$v0]
                        	;	ldt		$v1,TCBNext[$v0]			; get next task on timeout list
                        	;	stt		$v1,TimeoutList				; update list head
                        	;	beqz	$v1,.done@
                        	;	stt		$x0,TCBPrev[$v1]			; TimeoutList->prev = 0
                        	.done@:
                        	;	stt		$x0,TCBNext[$v0]
                        	;	stt		$x0,TCBPrev[$v0]
                        	endm
                        	
                        	macro mGetAppMid
  asl   $a0,$a0,#LOG_PGSZ
  ldb   $a0,ACBmid[$a0]
endm
                        	
                        	; Macros to enable and disable time-slice interrupts
                        	macro mTimeSliceEI
	ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
	stt		$t0,VIA_IER+VIA
endm
                        	
                        	macro mTimeSliceDI
	ldi		$t0,#$100						; disable timer3 (time slice) interrupts
	stt		$t0,VIA_IER+VIA
	nop                   ; make sure disable has time for effect
	nop
endm
                        	
                        	; Inserting into the ready queue is done by both OS ecall functions and
                        	; interrupt driven scheduling. It's important to have interrupts disabled
                        	; so that there is no contention for the ready queue.
                        	
                        	macro mInsertIntoReadyQueue
	asl   $t0,$a0,#LOG_TCBSZ
	ldbu	$t1,TCBStatus[$t0]	; set status to ready
	or		$t1,$t1,#TS_READY
	stb		$t1,TCBStatus[$t0]
	ldb		$t1,TCBPriority[$t0]
	pushq	$a0,$t1
endm
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/globals.r64",1
                        	.file "../fmtk/globals.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	INBUF				equ		$0100
                        	switchflag	equ		$0200
                        	milliseconds	equ		$0208
                        	CurrentTid  equ   $210
                        	TaskNum     equ   $220
                        	__xhandler_head equ $228
                        	
                        	ACBPtrs EQU $0280
                        	APPID_POOL  EQU   $02F0
                        	NPAGES	equ		$0300
                        	QNDX		EQU		$0304
                        	READYQ	EQU		$0308
                        	TID_POOL  EQU		$0310
                        	missed_ticks	equ		$0320
                        	TimeoutList		equ		$0328
                        	Tick		EQU		$0330
                        	SysSema	EQU		$0340
                        	MEPC0   EQU   $0350
                        	MEPC1   EQU   $0358
                        	MEPC2   EQU   $0360
                        	MEPC3   EQU   $0368
                        	CURIN   EQU   $0370
                        	CUROUT  EQU   $0371
                        	CHAINA0 EQU   $0378
                        	CHAINA1 EQU   $0380
                        	CHAINA2 EQU   $0388
                        	CHAINA3 EQU   $0390
                        	CHAINA4 EQU   $0398
                        	CHAINA5 EQU   $03A0
                        	READYQ  EQU   $0400
                        	RDYQ0		EQU		$0400
                        	RDYQ1		EQU		$0500
                        	RDYQ2		EQU		$0600
                        	RDYQ3		EQU		$0700
                        	mbxs		EQU		$0800
                        	mbxs_end	EQU	$0C00
                        	FreeMsg	EQU		$0C00
                        	FreeMbx EQU   $0C08
                        	IdleTaskMbx EQU   $0C10
                        	IdleTaskMsgD1 EQU   $0C18
                        	IdleTaskMsgD2 EQU   $0C20
                        	IdleTaskMsgD3 EQU   $0C28
                        	IdleTaskId    EQU   $0C2A
                        	PAMPtr  EQU   $0FF8
                        	IOFocusNdx		EQU		$1080
                        	IOFocusTbl		EQU		$1088
                        	IRQFlag   EQU $1090
                        	IRQCause  EQU $1098
                        	MbxBlockPtr EQU   $10A0
                        	MbxBlockPtrEnd  EQU MbxBlockPtr + MBX_BLOCKPTR_BUFSZ * 4
                        	MbxBlockCounter EQU $10E0
                        	RegsetTid   EQU   $10F0
                        	SerRcvBuf		EQU		$1400
                        	SerXmitBuf	EQU		$1800
                        	SerHeadRcv	EQU		$1C00
                        	SerTailRcv	EQU		$1C04
                        	SerHeadXmit	EQU		$1C08
                        	SerTailXmit	EQU		$1C0C
                        	SerRcvXon		EQU		$1C10
                        	SerRcvXoff	EQU		$1C11
                        	; The following must be at least 128 byte aligned
                        	DVF_Base		EQU		$2000
                        	DVF_Limit		EQU		$3000
                        	DCB_Base    EQU   $3000
                        	DCB_Limit   EQU   $3C00
                        	PAM     EQU   $4000
                        	_PAM     EQU   $4000
                        	_PAMend  EQU   $C000
                        	
                        	SysHeapStart  EQU   $5000
                        	SysHeapEnd    EQU   $20000
                        	
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	
                        	TEST  equ   1
                        	
                        	CTRLC				equ		$03
                        	CTRLT       equ   $14
                        	BS					equ		$08
                        	LNFD  			equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	EOF         equ   $1A
                        	DEL					equ		$7F
                        	VIA					equ		$FFFFFFFFFF910000
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_T2CL    equ   $20
                        	VIA_T2CH    equ   $24
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFFFFFFFFF930000
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        	
                        	CSR_UIE     equ   $004
                        	ROMBASE		equ		$FFFFFFFFFFFC0000
                        	IOBASE		equ		$FFFFFFFFFF800000
                        	TEXTSCR		equ		$FFFFFFFFFF800000
                        	KEYBD		equ		$FFFFFFFFFF8E0000
                        	LEDS		equ			$FFFFFFFFFF910000
                        	xbLEDS		equ			$FFFFFFFFFBDC0600
                        	xbBridge1 equ   $FFFFFFFFFFDCF010
                        	BUTTONS		equ		$FFFFFFFFFF910000
                        	SCRATCHPAD	equ		$FFFFFFFFFF400000
                        	SCRATCHMEM	equ		$FFFFFFFFFF400000
                        	_DBGAttr  equ   SCRATCHMEM
                        	;DBGATTR   equ   $0000FFFF000F0000   ; white on blue, priority $40
                        	DBGATTR   equ   %000000_111111111111111111111_000001100000110111111_0000000000000000
                        	_cursorX  equ   _DBGAttr + 8
                        	_cursorY  equ   _cursorX + 1
                        	
                        	
                        	.file "any1_rom.r64",49
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        	{+
                        		org		ROMBASE				; user mode exception
FFFFFFFFFFFC0000.0 FE0915878 		jmp		DBGRout
FFFFFFFFFFFC0004.8 000000000 		org 	ROMBASE+$C0				; machine mode exception
FFFFFFFFFFFC0009.0 000000000 
FFFFFFFFFFFC000D.8 000000000 
FFFFFFFFFFFC0012.0 000000000 
FFFFFFFFFFFC0016.8 000000000 
FFFFFFFFFFFC001B.0 000000000 
FFFFFFFFFFFC001F.8 000000000 
FFFFFFFFFFFC0024.0 000000000 
FFFFFFFFFFFC0028.8 000000000 
FFFFFFFFFFFC002D.0 000000000 
FFFFFFFFFFFC0031.8 000000000 
FFFFFFFFFFFC0036.0 000000000 
FFFFFFFFFFFC003A.8 000000000 
FFFFFFFFFFFC003F.0 000000000 
FFFFFFFFFFFC0043.8 000000000 
FFFFFFFFFFFC0048.0 000000000 
FFFFFFFFFFFC004C.8 000000000 
FFFFFFFFFFFC0051.0 000000000 
FFFFFFFFFFFC0055.8 000000000 
FFFFFFFFFFFC005A.0 000000000 
FFFFFFFFFFFC005E.8 000000000 
FFFFFFFFFFFC0063.0 000000000 
FFFFFFFFFFFC0067.8 000000000 
FFFFFFFFFFFC006C.0 000000000 
FFFFFFFFFFFC0070.8 000000000 
FFFFFFFFFFFC0075.0 000000000 
FFFFFFFFFFFC0079.8 000000000 
FFFFFFFFFFFC007E.0 000000000 
FFFFFFFFFFFC0082.8 000000000 
FFFFFFFFFFFC0087.0 000000000 
FFFFFFFFFFFC008B.8 000000000 
FFFFFFFFFFFC0090.0 000000000 
FFFFFFFFFFFC0094.8 000000000 
FFFFFFFFFFFC0099.0 000000000 
FFFFFFFFFFFC009D.8 000000000 
FFFFFFFFFFFC00A2.0 000000000 
FFFFFFFFFFFC00A6.8 000000000 
FFFFFFFFFFFC00AB.0 000000000 
FFFFFFFFFFFC00AF.8 000000000 
FFFFFFFFFFFC00B4.0 000000000 
FFFFFFFFFFFC00B8.8 000000000 
FFFFFFFFFFFC00BD.0 878000000 
FFFFFFFFFFFC00C0.0 FE0915878 		jmp		DBGRout
FFFFFFFFFFFC00C4.8 000000000 		org		ROMBASE+$F2			; non-maskable interrupt
FFFFFFFFFFFC00C9.0 000000000 
FFFFFFFFFFFC00CD.8 000000000 
FFFFFFFFFFFC00D2.0 000000000 
FFFFFFFFFFFC00D6.8 000000000 
FFFFFFFFFFFC00DB.0 000000000 
FFFFFFFFFFFC00DF.8 000000000 
FFFFFFFFFFFC00E4.0 000000000 
FFFFFFFFFFFC00E8.8 000000000 
FFFFFFFFFFFC00ED.0 000000000 
FFFFFFFFFFFC00F1.8 001070790 
FFFFFFFFFFFC00F2.0 000107079 		bra		MachineStart    ; cannot use a jump here, takes too much room
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC00F6.8 000000000 		org		ROMBASE+$100
FFFFFFFFFFFC00FB.0 000000000 
FFFFFFFFFFFC00FF.8 E08300780 
FFFFFFFFFFFC0100.0 FE0830078 		jmp		IRQRout
FFFFFFFFFFFC0104.8 000000000 		org 	ROMBASE+$1C0		; machine mode exception
FFFFFFFFFFFC0109.0 000000000 
FFFFFFFFFFFC010D.8 000000000 
FFFFFFFFFFFC0112.0 000000000 
FFFFFFFFFFFC0116.8 000000000 
FFFFFFFFFFFC011B.0 000000000 
FFFFFFFFFFFC011F.8 000000000 
FFFFFFFFFFFC0124.0 000000000 
FFFFFFFFFFFC0128.8 000000000 
FFFFFFFFFFFC012D.0 000000000 
FFFFFFFFFFFC0131.8 000000000 
FFFFFFFFFFFC0136.0 000000000 
FFFFFFFFFFFC013A.8 000000000 
FFFFFFFFFFFC013F.0 000000000 
FFFFFFFFFFFC0143.8 000000000 
FFFFFFFFFFFC0148.0 000000000 
FFFFFFFFFFFC014C.8 000000000 
FFFFFFFFFFFC0151.0 000000000 
FFFFFFFFFFFC0155.8 000000000 
FFFFFFFFFFFC015A.0 000000000 
FFFFFFFFFFFC015E.8 000000000 
FFFFFFFFFFFC0163.0 000000000 
FFFFFFFFFFFC0167.8 000000000 
FFFFFFFFFFFC016C.0 000000000 
FFFFFFFFFFFC0170.8 000000000 
FFFFFFFFFFFC0175.0 000000000 
FFFFFFFFFFFC0179.8 000000000 
FFFFFFFFFFFC017E.0 000000000 
FFFFFFFFFFFC0182.8 000000000 
FFFFFFFFFFFC0187.0 000000000 
FFFFFFFFFFFC018B.8 000000000 
FFFFFFFFFFFC0190.0 000000000 
FFFFFFFFFFFC0194.8 000000000 
FFFFFFFFFFFC0199.0 000000000 
FFFFFFFFFFFC019D.8 000000000 
FFFFFFFFFFFC01A2.0 000000000 
FFFFFFFFFFFC01A6.8 000000000 
FFFFFFFFFFFC01AB.0 000000000 
FFFFFFFFFFFC01AF.8 000000000 
FFFFFFFFFFFC01B4.0 000000000 
FFFFFFFFFFFC01B8.8 000000000 
FFFFFFFFFFFC01BD.0 078000000 
FFFFFFFFFFFC01C0.0 FE0830078 		jmp		IRQRout
FFFFFFFFFFFC01C4.8 000000000 		org		ROMBASE+$1F2		; non-maskable interrupt
FFFFFFFFFFFC01C9.0 000000000 
FFFFFFFFFFFC01CD.8 000000000 
FFFFFFFFFFFC01D2.0 000000000 
FFFFFFFFFFFC01D6.8 000000000 
FFFFFFFFFFFC01DB.0 000000000 
FFFFFFFFFFFC01DF.8 000000000 
FFFFFFFFFFFC01E4.0 000000000 
FFFFFFFFFFFC01E8.8 000000000 
FFFFFFFFFFFC01ED.0 000000000 
FFFFFFFFFFFC01F1.8 000870790 
FFFFFFFFFFFC01F2.0 000087079 		bra		MachineStart    ; cannot use a jump here, takes too much room
                        	
FFFFFFFFFFFC01F6.8 000000000 		org		ROMBASE+$200
FFFFFFFFFFFC01FB.0 000000000 
FFFFFFFFFFFC01FF.8 E08300780 
FFFFFFFFFFFC0200.0 FE0830078 		jmp		IRQRout
FFFFFFFFFFFC0204.8 000000000 		org 	ROMBASE+$2C0		; machine mode exception
FFFFFFFFFFFC0209.0 000000000 
FFFFFFFFFFFC020D.8 000000000 
FFFFFFFFFFFC0212.0 000000000 
FFFFFFFFFFFC0216.8 000000000 
FFFFFFFFFFFC021B.0 000000000 
FFFFFFFFFFFC021F.8 000000000 
FFFFFFFFFFFC0224.0 000000000 
FFFFFFFFFFFC0228.8 000000000 
FFFFFFFFFFFC022D.0 000000000 
FFFFFFFFFFFC0231.8 000000000 
FFFFFFFFFFFC0236.0 000000000 
FFFFFFFFFFFC023A.8 000000000 
FFFFFFFFFFFC023F.0 000000000 
FFFFFFFFFFFC0243.8 000000000 
FFFFFFFFFFFC0248.0 000000000 
FFFFFFFFFFFC024C.8 000000000 
FFFFFFFFFFFC0251.0 000000000 
FFFFFFFFFFFC0255.8 000000000 
FFFFFFFFFFFC025A.0 000000000 
FFFFFFFFFFFC025E.8 000000000 
FFFFFFFFFFFC0263.0 000000000 
FFFFFFFFFFFC0267.8 000000000 
FFFFFFFFFFFC026C.0 000000000 
FFFFFFFFFFFC0270.8 000000000 
FFFFFFFFFFFC0275.0 000000000 
FFFFFFFFFFFC0279.8 000000000 
FFFFFFFFFFFC027E.0 000000000 
FFFFFFFFFFFC0282.8 000000000 
FFFFFFFFFFFC0287.0 000000000 
FFFFFFFFFFFC028B.8 000000000 
FFFFFFFFFFFC0290.0 000000000 
FFFFFFFFFFFC0294.8 000000000 
FFFFFFFFFFFC0299.0 000000000 
FFFFFFFFFFFC029D.8 000000000 
FFFFFFFFFFFC02A2.0 000000000 
FFFFFFFFFFFC02A6.8 000000000 
FFFFFFFFFFFC02AB.0 000000000 
FFFFFFFFFFFC02AF.8 000000000 
FFFFFFFFFFFC02B4.0 000000000 
FFFFFFFFFFFC02B8.8 000000000 
FFFFFFFFFFFC02BD.0 078000000 
FFFFFFFFFFFC02C0.0 FE0830078 		jmp		IRQRout
FFFFFFFFFFFC02C4.8 000000000 		org		ROMBASE+$2F2		; non-maskable interrupt
FFFFFFFFFFFC02C9.0 000000000 
FFFFFFFFFFFC02CD.8 000000000 
FFFFFFFFFFFC02D2.0 000000000 
FFFFFFFFFFFC02D6.8 000000000 
FFFFFFFFFFFC02DB.0 000000000 
FFFFFFFFFFFC02DF.8 000000000 
FFFFFFFFFFFC02E4.0 000000000 
FFFFFFFFFFFC02E8.8 000000000 
FFFFFFFFFFFC02ED.0 000000000 
FFFFFFFFFFFC02F1.8 000070790 
FFFFFFFFFFFC02F2.0 000007079 		bra		MachineStart    ; cannot use a jump here, takes too much room
                        	
                        	;------------------------------------------------------------------------------
                        	; Reset starting address.
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC02F6.8 000000000 		org		ROMBASE+$300
FFFFFFFFFFFC02FB.0 000000000 
FFFFFFFFFFFC02FF.8 0AA003040 
                        	MachineStart:
                        	;  ldi   $t1,#$81
                        	;  sto   $t1,xbBridge1
FFFFFFFFFFFC0300.0 00AA00304 	  ldi   $t0,#$AA
FFFFFFFFFFFC0304.8 FFFF22050 	  stb   $t0,LEDS
FFFFFFFFFFFC0309.0 000300070 
FFFFFFFFFFFC030D.8 00AA01404 	  ldi   $a0,#$AA
FFFFFFFFFFFC0312.0 FFFF22050 	  stb   $a0,LEDS
FFFFFFFFFFFC0316.8 001400070 
                        	
FFFFFFFFFFFC031B.0 FFFE81950 		ldi		$sp,#SCRATCHMEM+$CDF8		  ; setup machine mode stack pointer
FFFFFFFFFFFC031F.8 CDF801E04 
FFFFFFFFFFFC0324.0 FFF879E04 		sub 	$sp,$sp,#8
FFFFFFFFFFFC0328.8 000A01404 		ldi   $a0,#10
FFFFFFFFFFFC032D.0 000001504 		ldi   $a1,#0
FFFFFFFFFFFC0331.8 0001A747C 		call  _Delay2s
FFFFFFFFFFFC0336.0 00028F07C 		call  dbg_HomeCursor
FFFFFFFFFFFC033A.8 C1837E050 		ldi		$a1,#DBGATTR		  ; set zorder $40, white text, blue background
FFFFFFFFFFFC033F.0 007FFFF51 
FFFFFFFFFFFC0343.8 000001504 
FFFFFFFFFFFC0348.0 FFFE80050 		sto		$a1,_DBGAttr
FFFFFFFFFFFC034C.8 301500070 
                        	  ; clear debug screen
FFFFFFFFFFFC0351.0 FFFE80050 	  ldo   $a0,_DBGAttr
FFFFFFFFFFFC0355.8 300001460 
FFFFFFFFFFFC035A.0 FFFF00050 	  ldi   $t0,#TEXTSCR
FFFFFFFFFFFC035E.8 000000304 
                        	ifdef TEST
FFFFFFFFFFFC0363.0 000600404 	  ldi   $t1,#6
                        	else
                        	  ldi   $t1,#56*29
                        	endif
                        	.0001:
FFFFFFFFFFFC0367.8 FFFF10404 	  sub   $t1,$t1,#1
FFFFFFFFFFFC036C.0 000010058 	  sto   $a0,[$t0+$t1*8]
FFFFFFFFFFFC0370.8 36140C071 
FFFFFFFFFFFC0375.0 FF8013D4F 	  bne   $t1,$x0,.0001
FFFFFFFFFFFC0379.8 C1837E050 		ldi		$a1,#DBGATTR|$41
FFFFFFFFFFFC037E.0 007FFFF51 
FFFFFFFFFFFC0382.8 004101504 
FFFFFFFFFFFC0387.0 FFFF00050 		sto		$a1,TEXTSCR
FFFFFFFFFFFC038B.8 301500070 
FFFFFFFFFFFC0390.0 FFFF00050 		sto		$a1,TEXTSCR+8
FFFFFFFFFFFC0394.8 301500870 
FFFFFFFFFFFC0399.0 FFFF00050 		sto		$a1,TEXTSCR+16
FFFFFFFFFFFC039D.8 301501070 
FFFFFFFFFFFC03A2.0 FFFF00050 		sto		$a1,TEXTSCR+24
FFFFFFFFFFFC03A6.8 301501870 
                        	
                        	;  ldi   $a0,#msgStart
                        	  ;call  PutHexTetra
FFFFFFFFFFFC03AB.0 FFFFF1050 	  ldi   $a0,#msgStart
FFFFFFFFFFFC03AF.8 823001404 
FFFFFFFFFFFC03B4.0 0005D187C 	  call  PutString
                        	
                        	;  call  _ramtest2
                        	;	csrrs $x0,#CSR_TRACECTRL,#1 ; turn on tracing
FFFFFFFFFFFC03B8.8 01FE8B87C 	  call  _pti_init
FFFFFFFFFFFC03BD.0 000010050 	  ldi   $a1,#$80000
FFFFFFFFFFFC03C1.8 000001504 
FFFFFFFFFFFC03C6.0 000040050 	  ldi   $a0,#$200000
FFFFFFFFFFFC03CA.8 000001404 
FFFFFFFFFFFC03CF.0 01FE8087C 	  call  _pti_read_block
                        	
FFFFFFFFFFFC03D3.8 01FE7E87C 		call  MMUInit					; initialize MMU for address space zero.
FFFFFFFFFFFC03D8.0 01FE7C87C 		call  _FMTKInit
                        		;call  ViaSetup
                        	;	call  _SerialInit
FFFFFFFFFFFC03DC.8 01FE7A87C 		call  _InitPIC
FFFFFFFFFFFC03E1.0 000500304 		ldi   $t0,#5          ; set current input and output to serial port
FFFFFFFFFFFC03E5.8 068303070 		stb   $t0,CURIN
FFFFFFFFFFFC03EA.0 068303170 		stb   $t0,CUROUT
FFFFFFFFFFFC03EE.8 000000304 		ldi		$t0,#0
FFFFFFFFFFFC03F3.0 00304C00F 		csrrw $x0,#CSR_MSEMA,$t0  ; turn off semaphores
FFFFFFFFFFFC03F7.8 00604C00F 		csrrw	$x0,#$181,$t0		    ; set ASID
FFFFFFFFFFFC03FC.0 00040C00F 		csrrw $x0,#CSR_TASKID,$t0 ; clear task id
FFFFFFFFFFFC0400.8 FFFFF8050 		ldi		$t0,#$FFFFFFFFFFFC0000
FFFFFFFFFFFC0405.0 000000304 
FFFFFFFFFFFC0409.8 100D4C00F 		csrrw $x0,#$5035,$t0		; set tvec for debug mode
FFFFFFFFFFFC040E.0 FFFFF8050 		ldi		$t0,#$FFFFFFFFFFFC0100
FFFFFFFFFFFC0412.8 010000304 
FFFFFFFFFFFC0417.0 100D0C00F 		csrrw $x0,#$5034,$t0		; set tvec for interrupt mode
FFFFFFFFFFFC041B.8 FFFFF8050 		ldi		$t0,#$FFFFFFFFFFFC0200
FFFFFFFFFFFC0420.0 020000304 
FFFFFFFFFFFC0424.8 100CCC00F 		csrrw $x0,#$5033,$t0		; set tvec for machine mode
FFFFFFFFFFFC0429.0 FC1F00304 		ldi   $t0,#$FFFFFFFFFFFFFC1F  ; run user mode in register set #0
FFFFFFFFFFFC042D.8 0010CC00F 		csrrw $x0,#CSR_RSSTACK,$t0
FFFFFFFFFFFC0432.0 FFFFF0150 		ldi		$t0,#UserStart
FFFFFFFFFFFC0436.8 08F400304 
FFFFFFFFFFFC043B.0 10120C00F 		csrrw	$x0,#$5048,$t0	  ; set mepc
FFFFFFFFFFFC043F.8 268301870 		stt   $t0,MEPC1
FFFFFFFFFFFC0444.0 000101404 	  ldi   $a0,#1            ; start task
FFFFFFFFFFFC0448.8 000001504 	  ldi   $a1,#0
FFFFFFFFFFFC044D.0 000001604 	  ldi   $a2,#0
FFFFFFFFFFFC0451.8 FFFFF0150 	  ldi   $a3,#UserStart2
FFFFFFFFFFFC0456.0 090601704 
FFFFFFFFFFFC045A.8 000001804 	  ldi   $a4,#$00
FFFFFFFFFFFC045F.0 01FE3A07C 	  call  OSOCall
FFFFFFFFFFFC0463.8 00045400F 	  csrrw $x0,#CSR_TASKID,$a1
FFFFFFFFFFFC0468.0 001000204 	  csrrs $x0,#CSR_PMSTACK,#16 ; enable interrupts on return
FFFFFFFFFFFC046C.8 00100800F 
FFFFFFFFFFFC0471.0 10280000F 		csrrc $x0,#CSR_TRACECTRL,#0 ; turn off tracing
FFFFFFFFFFFC0475.8 000000045 		rte                       ; switch to user mode
;------------------------------------------------------------------------------
                        	; User mode code staret here
                        	; First thing to do is start a task so that the startup code may run on the
                        	; first task switch.
                        	;------------------------------------------------------------------------------
                        	  align 	code
UserStart:
FFFFFFFFFFFC047A.0 00058BC7C 	  call  DumpTraceQueue
FFFFFFFFFFFC047E.8 240000007 	  wai                   ; wait for task switch
                        	UserStart2:
FFFFFFFFFFFC0483.0 000C01404 	  ldi   $a0,#12         ; start app
FFFFFFFFFFFC0487.8 FFFFF1050 	  ldi   $a1,#SystemASR
FFFFFFFFFFFC048C.0 800001504 
FFFFFFFFFFFC0490.8 000210000 	  brk   #240
.appBad:
FFFFFFFFFFFC0495.0 16005300C 	  tst   $cr0,$a0
FFFFFFFFFFFC0499.8 00000008F 
FFFFFFFFFFFC049E.0 FFFFC3E4F 	  bne   $cr0,.appBad
FFFFFFFFFFFC04A2.8 020054B02 	  mov   $s1,$a1
FFFFFFFFFFFC04A7.0 000E01404 	  ldi   $a0,#14         ; get current tid
FFFFFFFFFFFC04AB.8 000210000 	  brk   #240            ; $a1 = task id
  ldi   $a0,#30         ; set task's app id
FFFFFFFFFFFC04B0.0 001E01404 
FFFFFFFFFFFC04B4.8 02002D602 	  mov   $a2,$s1         ; $a2 = app id
FFFFFFFFFFFC04B9.0 000210000 	  brk   #240

FFFFFFFFFFFC04BD.8 020054B02 	  mov   $s1,$a1         ; s1 = app id
FFFFFFFFFFFC04C2.0 01400FF50 		ldi		$sp,#$A0080000-4  ; setup user mode stack pointer
FFFFFFFFFFFC04C6.8 FFFC01E04 
                        	
FFFFFFFFFFFC04CB.0 000C01404 	  ldi   $a0,#12         ; start app
FFFFFFFFFFFC04CF.8 FFFFF1050 	  ldi   $a1,#TinyBasicASR
FFFFFFFFFFFC04D4.0 811801504 
FFFFFFFFFFFC04D8.8 000210000 	  brk   #240
	ldi		$a0,#1          ; Start finalizer task, task #1
FFFFFFFFFFFC04DD.0 000101404 
FFFFFFFFFFFC04E1.8 02002D502 		mov   $a1,$s1
FFFFFFFFFFFC04E6.0 000001604 		ldi		$a2,#0
FFFFFFFFFFFC04EA.8 000000050 		ldi		$a3,#Finalizer
FFFFFFFFFFFC04EF.0 F00000051 
FFFFFFFFFFFC04F3.8 01AB01704 
FFFFFFFFFFFC04F8.0 000B01804 		ldi   $a4,#$0B        ; user mode, regset 11
FFFFFFFFFFFC04FC.8 000210000 		brk   #240
	ldi		$a0,#1          ; Start task for monitor, task #2
FFFFFFFFFFFC0501.0 000101404 
FFFFFFFFFFFC0505.8 02002D502 		mov   $a1,$s1
FFFFFFFFFFFC050A.0 000001604 		ldi		$a2,#0
FFFFFFFFFFFC050E.8 FFFFF0250 		ldi		$a3,#MonEntry
FFFFFFFFFFFC0513.0 12BB01704 
FFFFFFFFFFFC0517.8 000A01804 		ldi   $a4,#$0A        ; user mode, regset 10
FFFFFFFFFFFC051C.0 000210000 		brk   #240
  ldi   $a0,#25         ; map OS vars
FFFFFFFFFFFC0520.8 001901404 
FFFFFFFFFFFC0525.0 000210000 	  brk   #240
  mov   $gp,$a1
FFFFFFFFFFFC0529.8 020055C02 
                        	
                        	UserStart3:
FFFFFFFFFFFC052E.0 01400FF50 		ldi		$sp,#$A0080000-4  ; setup user mode stack pointer
FFFFFFFFFFFC0532.8 FFFC01E04 
FFFFFFFFFFFC0537.0 001801404 		ldi		$a0,#24							; RequestIOFocus
FFFFFFFFFFFC053B.8 02002D502 		mov   $a1,$s1
FFFFFFFFFFFC0540.0 000210000 		brk   #240
;	ldi		$sp,#$70000		      ; setup temporary user mode stack pointer
                        	;	mov   $a0,$a1             ; $a0 = tid
                        	;	call AllocStack
                        	;	add   $sp,$v1,#1020       ; place stack pointer at top of allocated region
FFFFFFFFFFFC0544.8 000800304 		ldi		$t0,#$08						; turn on the LED
FFFFFFFFFFFC0549.0 FFFF22050 		stt		$t0,VIA+VIA_PARAW
FFFFFFFFFFFC054D.8 200303C70 
FFFFFFFFFFFC0552.0 001000504 		ldi		$t2,#16							; send an XON just in case
FFFFFFFFFFFC0556.8 001101704 		ldi		$a3,#XON
                        	.0004:
FFFFFFFFFFFC055B.0 0000B447C 		call  Putch ;SerialPutChar
R2 operation needs two source operands. (1311)
R2 operation needs two source operandsFFFFFFFFFFFC055F.8 0A007DF02 		sub.	$t2,$t2,#1
FFFFFFFFFFFC0564.0 FFFFC3E4F 		bne	  $cr0,.0004
                        	.0002:
                        	;  ldi   $a0,#25             ; Map OS vars
                        	;  brk #240
                        	;  mov   $gp,$a1
                        	  ; Request that the idle task announce itself.
                        	;  ldi   $a0,#9              ; SendMsg
                        	;  ldwu  $a1,IdleTaskMbx[$gp]
                        	;  beqz  $a1,.noMbx
                        	;  ldi   $a2,#MT_ANNOUNCE
                        	;  ldi   $a3,#0
                        	;  ldi   $a4,#0
                        	;  brk #240
                        	.noMbx:
FFFFFFFFFFFC0568.8 FFFFF1050 		ldi		$a0,#msgStart				; spit out a startup message
FFFFFFFFFFFC056D.0 823001404 
FFFFFFFFFFFC0571.8 0004F2C7C 		call  PutString
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		brk #240
FFFFFFFFFFFC0576.0 01FDB187C 		call  DumpReadyQueue
FFFFFFFFFFFC057A.8 FE04AEC78 		jmp		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#9							; peekchar function
                        	;	brk #240
                        	;	mov   $v0,$v1
                        	;	bltz	$v1,.0003
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#8							; getchar function
                        	;	brk #240
                        	;	mov		$a3,$v1
                        	;	mov   $a0,$a3
                        	;	call PutHexByte
                        	;	bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	; This task runs only if nothing else can run. It must run at the machine
                        	; operating mode.
                        	; Search for ready tasks and add them back into the ready queue.
                        	;------------------------------------------------------------------------------
                        	;  align 	code
                        	IdleTask:
FFFFFFFFFFFC057F.0 000601404 	  ldi   $a0,#6                ; alloc mailbox
FFFFFFFFFFFC0583.8 000001504 	  ldi   $a1,#0                ; app #0
FFFFFFFFFFFC0588.0 000210000 	  brk   #240
  stw   $a1,IdleTaskMbx[$gp]  ; save mailbox handle off
FFFFFFFFFFFC058C.8 000000150 
FFFFFFFFFFFC0591.0 181571070 
                        	.loop2:
FFFFFFFFFFFC0595.8 400000304 	  ldi   $t0,#$4000
FFFFFFFFFFFC059A.0 000100404 	  ldi   $t1,#1
                        	.loop:
FFFFFFFFFFFC059E.8 000B01404 	  ldi   $a0,#11               ; PeekMsg
FFFFFFFFFFFC05A3.0 000000150 	  ldwu  $a1,IdleTaskMbx[$gp]
FFFFFFFFFFFC05A7.8 1C1071564 
FFFFFFFFFFFC05AC.0 0C1801604 	  ldi   $a2,#IdleTaskMsgD1
FFFFFFFFFFFC05B0.8 0C2001704 	  ldi   $a3,#IdleTaskMsgD2
FFFFFFFFFFFC05B5.0 0C2801804 	  ldi   $a4,#IdleTaskMsgD3
FFFFFFFFFFFC05B9.8 000101904 	  ldi   $a5,#1                ; remove from queue if present
                        	;  brk #240
                        	;  bnez  $a0,.noMsg
                        	;  ldt   $a0,IdleTaskMsgD1
                        	;  xor   $t1,$a0,#MT_ANNOUNCE
                        	;  bnez  $t1,.noAnnounce
                        	;  ldi   $a0,#msgIdleAnnounce
                        	;  call PutString
                        	.noAnnounce:
                        	.noMsg:
FFFFFFFFFFFC05BE.0 001101404 	  ldi   $a0,#17               ; run as OS
FFFFFFFFFFFC05C2.8 FFFFF0150 	  ldi   $a1,#.IdleCode
FFFFFFFFFFFC05C7.0 0BD601504 
FFFFFFFFFFFC05CB.8 02000D602 	  mov   $a2,$t0
FFFFFFFFFFFC05D0.0 000210000 	  brk   #240
  add   $t0,$t0,#PAGESZ
FFFFFFFFFFFC05D4.8 10000C304 
FFFFFFFFFFFC05D9.0 004000050 	  sne   $t3,$t0,#MEMSZ*PAGESZ
FFFFFFFFFFFC05DD.8 00000C627 
FFFFFFFFFFFC05E2.0 FFC01B14F 	  bne   $t3,#0,.loop
FFFFFFFFFFFC05E6.8 FE02CAC78 		jmp		.loop2
                        	  ; This section of code runs as part of the OS
                        	  ; Don't callany functions though as there's no stack available
                        	.IdleCode:
FFFFFFFFFFFC05EB.0 200058360 	  ldt   $t0,OBJMagic[$a2]
FFFFFFFFFFFC05EF.8 0040A8850 	  sne   $t3,$t0,#TCB_MAGIC
FFFFFFFFFFFC05F4.0 43420C627 
FFFFFFFFFFFC05F8.8 004018D4F 	  bne   $t3,#0,.nxtObj
FFFFFFFFFFFC05FD.0 02E014664 	  ldbu  $t3,TCBStatus[$t2]    ; get status
FFFFFFFFFFFC0601.8 000118608 	  and  	$t3,$t3,#TS_READY
FFFFFFFFFFFC0606.0 004018A4F 	  bne   $t3,#0,.nxtObj
                        	  ; The task was ready, but not found in the ready queue. So add it
FFFFFFFFFFFC060A.8 040C59402 	  lsr   $a0,$a2,#LOG_PGSZ
                        	  
FFFFFFFFFFFC060F.0 00100400F 	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	
FFFFFFFFFFFC0613.8 020A50302 		asl   $t0,$a0,#LOG_TCBSZ
FFFFFFFFFFFC0618.0 02E00C464 		ldbu	$t1,TCBStatus[$t0]	; set status to ready
FFFFFFFFFFFC061C.8 000110409 		or		$t1,$t1,#TS_READY
FFFFFFFFFFFC0621.0 05840E070 		stb		$t1,TCBStatus[$t0]
FFFFFFFFFFFC0625.8 02E10C460 		ldb		$t1,TCBPriority[$t0]
FFFFFFFFFFFC062A.0 100450007 		pushq	$a0,$t1
                        	
FFFFFFFFFFFC062E.8 00100400F 	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
                        	.nxtObj:
FFFFFFFFFFFC0633.0 000001404 	  ldi   $a0,#E_Ok
FFFFFFFFFFFC0637.8 000000050 	  jmp   OSExit
FFFFFFFFFFFC063C.0 F00000051 
FFFFFFFFFFFC0640.8 00006EC78 
                        	
                        	msgIdleAnnounce:
FFFFFFFFFFFC0645.0 256C64694 	  db  "Idle task running.",CR,0
FFFFFFFFFFFC0649.8 B63716470 
FFFFFFFFFFFC064E.0 6E6572702 
FFFFFFFFFFFC0652.8 E276E696E 
FFFFFFFFFFFC0657.0 0000000D0 
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	;  align 	code
FFFFFFFFFFFC0659.0 000000000 		align	64
FFFFFFFFFFFC065D.8 000000000 
FFFFFFFFFFFC0662.0 000000000 
FFFFFFFFFFFC0666.8 000000000 
FFFFFFFFFFFC066B.0 000000000 
FFFFFFFFFFFC066F.8 000000000 
FFFFFFFFFFFC0674.0 000000000 
FFFFFFFFFFFC0678.8 000000000 
FFFFFFFFFFFC067D.0 504000000 
                        	_Delay2s:
                        	ifdef TEST
FFFFFFFFFFFC0680.0 000A01504 	  ldi     $a1,#10
                        	else
                        		ldi			$a1,#3000000
                        	endif
                        	.0001:
FFFFFFFFFFFC0684.8 441055602 		srl			$a2,$a1,#16
FFFFFFFFFFFC0689.0 FFFF22050 		stb			$a2,LEDS
FFFFFFFFFFFC068D.8 001600070 
FFFFFFFFFFFC0692.0 FFFF55504 		sub 		$a1,$a1,#1
FFFFFFFFFFFC0696.8 FF9503C48 		bgt		  $a1,#0,.0001
FFFFFFFFFFFC069B.0 000879E7B 		ret

                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		$a0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	Getch:
FFFFFFFFFFFC069F.8 FFF079E04 		sub		$sp,$sp,#16
FFFFFFFFFFFC06A4.0 301578870 		sto		$a1,8[$sp]
FFFFFFFFFFFC06A8.8 000501504 		ldi   $a1,#5  ;CURIN
FFFFFFFFFFFC06AD.0 00011DC7C 		call  fgetc
FFFFFFFFFFFC06B1.8 300879560 		ldo		$a1,8[$sp]
FFFFFFFFFFFC06B6.0 001079E04 		add   $sp,$sp,#16
FFFFFFFFFFFC06BA.8 000879E7B 		ret

                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = character to put
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	_putch:
FFFFFFFFFFFC06BF.0 000070879 	  bra   dbg_Putch
                        	  ; align cache
                        	Putch:
FFFFFFFFFFFC06C3.8 00006E479 	  bra   dbg_Putch
FFFFFFFFFFFC06C8.0 FFE879E04 		sub		$sp,$sp,#24
FFFFFFFFFFFC06CC.8 301778870 		sto		$a3,8[$sp]
FFFFFFFFFFFC06D1.0 301579070 		sto		$a1,16[$sp]
FFFFFFFFFFFC06D5.8 020051702 		mov		$a3,$a0
FFFFFFFFFFFC06DA.0 000501504 		ldi		$a1,#5  ;CUROUT    ; serial port
FFFFFFFFFFFC06DE.8 0000C607C 		call	fputc
FFFFFFFFFFFC06E3.0 300879760 		ldo		$a3,8[$sp]
FFFFFFFFFFFC06E7.8 301079560 		ldo		$a1,16[$sp]
FFFFFFFFFFFC06EC.0 001879E04 		add   $sp,$sp,#24
FFFFFFFFFFFC06F0.8 000879E7B 		ret

                        	  ; align cache
                        	calcScreenPos:
FFFFFFFFFFFC06F5.0 FFFE80050 	  ldbu  $t0,_cursorY
FFFFFFFFFFFC06F9.8 000900364 
FFFFFFFFFFFC06FE.0 004018A4B 	  bgeu  $t3,#29,.0001
                        	.0002:
FFFFFFFFFFFC0702.8 00380C415 	  mulf  $t1,$t0,#56
FFFFFFFFFFFC0707.0 FFFE80050 	  ldbu  $t0,_cursorX
FFFFFFFFFFFC070B.8 000800364 
FFFFFFFFFFFC0710.0 00400CA4B 	  bgeu  $t0,#56,.0003
                        	.0004:
FFFFFFFFFFFC0714.8 080310402 	  add   $t1,$t1,$t0
FFFFFFFFFFFC0719.0 340310402 	  sll   $t1,$t1,#3
FFFFFFFFFFFC071D.8 FFFF00050 	  add   $t2,$t1,#TEXTSCR
FFFFFFFFFFFC0722.0 000010504 
FFFFFFFFFFFC0726.8 000879E7B 	  ret
; This is cool in ANY1. Storing a smalll constant to memory does not require
                        	; the use of a source register. This allows the LDI and the STB to proceed
                        	; in parallel. The store does not need to wait for a register.
                        	.0001:
FFFFFFFFFFFC072B.0 001C00304 	  ldi   $t0,#28
FFFFFFFFFFFC072F.8 FFFE80050 	  stb   #28,_cursorY
FFFFFFFFFFFC0734.0 004000970 
FFFFFFFFFFFC0738.8 FFFFE5079 	  bra   .0002
                        	.0003:
FFFFFFFFFFFC073D.0 003700304 	  ldi   $t0,#55
FFFFFFFFFFFC0741.8 FFFE80050 	  stb   $t0,_cursorX
FFFFFFFFFFFC0746.0 000300870 
FFFFFFFFFFFC074A.8 FFFFE5079 	  bra   .0004
                        	
                        	  ; align cache
                        	incScreenPos:
FFFFFFFFFFFC074F.0 FFFE80050 	  ldbu  $t0,_cursorX
FFFFFFFFFFFC0753.8 000800364 
FFFFFFFFFFFC0758.0 00010C304 	  add   $t0,$t0,#1
FFFFFFFFFFFC075C.8 00400CC4A 	  bltu  $t0,#56,.0001
FFFFFFFFFFFC0761.0 FFFE80050 	  stb   #0,_cursorX
FFFFFFFFFFFC0765.8 004000870 
FFFFFFFFFFFC076A.0 FFFE80050 	  ldbu  $t0,_cursorY
FFFFFFFFFFFC076E.8 000900364 
FFFFFFFFFFFC0773.0 00010C304 	  add   $t0,$t0,#1
FFFFFFFFFFFC0777.8 00400C34A 	  bltu  $t0,#29,.0002
FFFFFFFFFFFC077C.0 00004387C 	  call  dbg_ScrollUp
FFFFFFFFFFFC0780.8 000879E7B 	  ret
.0002:
FFFFFFFFFFFC0785.0 FFFE80050 	  stb   $t0,_cursorY
FFFFFFFFFFFC0789.8 000300970 
FFFFFFFFFFFC078E.0 000879E7B 	  ret
.0001:
FFFFFFFFFFFC0792.8 FFFE80050 	  stb   $t0,_cursorX
FFFFFFFFFFFC0797.0 000300870 
FFFFFFFFFFFC079B.8 000879E7B 	  ret
  
                        	  ; align cache
                        	dbg_Putch:
FFFFFFFFFFFC07A0.0 00405134E 	  beq  	$a0,#CR,.cr
FFFFFFFFFFFC07A4.8 00405094E 	  beq  	$a0,#LNFD,.lf
FFFFFFFFFFFC07A9.0 FFFE80050 	  ldo   $t3,_DBGAttr
FFFFFFFFFFFC07AD.8 300000660 
FFFFFFFFFFFC07B2.0 020650602 	  or    $t3,$a0,$t3
FFFFFFFFFFFC07B6.8 FFFF9F47C 	  call  calcScreenPos
FFFFFFFFFFFC07BB.0 300614070 	  sto   $t3,[$t2]
FFFFFFFFFFFC07BF.8 FFFFC7C7C 	  call  incScreenPos
FFFFFFFFFFFC07C4.0 300078160 	  ldo		$x1,[$sp]
FFFFFFFFFFFC07C8.8 000879E7B 	  ret
 .lf:
FFFFFFFFFFFC07CD.0 FFFE80050 	  stb   #0,_cursorX
FFFFFFFFFFFC07D1.8 004000870 
FFFFFFFFFFFC07D6.0 FFFE80050 	  ldbu  $a0,_cursorY
FFFFFFFFFFFC07DA.8 000901464 
FFFFFFFFFFFC07DF.0 000151404 	  add   $a0,$a0,#1
FFFFFFFFFFFC07E3.8 00405074B 	  bgeu  $a0,#29,dbg_ScrollUp
FFFFFFFFFFFC07E8.0 FFFE80050 	  stb   $a0,_cursorY
FFFFFFFFFFFC07EC.8 001400970 
FFFFFFFFFFFC07F1.0 000879E7B 	  ret
.cr:
FFFFFFFFFFFC07F5.8 FFFE80050 	  stb   #0,_cursorX
FFFFFFFFFFFC07FA.0 004000870 
FFFFFFFFFFFC07FE.8 000879E7B 	  ret

                        	  ; align cache
                        	dbg_ScrollUp:
FFFFFFFFFFFC0803.0 FFFF00050 	  ldi   $t0,#TEXTSCR
FFFFFFFFFFFC0807.8 000000304 
                        	ifdef TEST
FFFFFFFFFFFC080C.0 000600404 	  ldi   $t1,#6
                        	else
                        	  ldi   $t1,#56*28
                        	endif
                        	.0001:
FFFFFFFFFFFC0810.8 31C00C560 	  ldo   $t2,56*8[$t0]
FFFFFFFFFFFC0815.0 FFFF10404 	  sub  	$t1,$t1,#1      ; placed here eliminates pipeline bubble
FFFFFFFFFFFC0819.8 30050C070 	  sto   $t2,[$t0]
FFFFFFFFFFFC081E.0 00080C304 	  add   $t0,$t0,#8
FFFFFFFFFFFC0822.8 FFC013C4F 	  bne   $t1,#0,.0001
                        	
                        	  ; align cache
                        	dbg_BlankLastLine:
FFFFFFFFFFFC0827.0 FFFF00050 	  ldi   $t0,#TEXTSCR+56*28
FFFFFFFFFFFC082B.8 062000304 
FFFFFFFFFFFC0830.0 003700404 	  ldi   $t1,#55
FFFFFFFFFFFC0834.8 000000504 	  ldi   $t2,_DBGAttr
  or    $t2,$t2,#' '
FFFFFFFFFFFC0839.0 002014509 
                        	.0001:
FFFFFFFFFFFC083D.8 000010058 	  sto   $t2,[$t0+$t1*8]
FFFFFFFFFFFC0842.0 36050C071 
FFFFFFFFFFFC0846.8 FFFF10404 	  sub  	$t1,$t1,#1
FFFFFFFFFFFC084B.0 FFC013D4B 	  bgeu  $t1,#1,.0001
FFFFFFFFFFFC084F.8 000879E7B 	  ret

                        	  ; align cache
                        	dbg_HomeCursor:
FFFFFFFFFFFC0854.0 FFFE80050 	  stb   #0,_cursorX
FFFFFFFFFFFC0858.8 004000870 
FFFFFFFFFFFC085D.0 FFFE80050 	  stb   #0,_cursorY
FFFFFFFFFFFC0861.8 004000970 
FFFFFFFFFFFC0866.0 000879E7B 	  ret
  
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   EOF if error occurred, otherwise character to put
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	fputc:
FFFFFFFFFFFC086A.8 FFE079E04 		sub		$sp,$sp,#32
FFFFFFFFFFFC086F.0 301579070 		sto		$a1,16[$sp]
FFFFFFFFFFFC0873.8 301679870 		sto		$a2,24[$sp]
FFFFFFFFFFFC0878.0 004268300 		seq   $t0,$a6,#'B'
                        		bf    .noBypass
FFFFFFFFFFFC087C.8 01FC3647C 		call  SerialPutChar
FFFFFFFFFFFC0881.0 FE0466C78 		jmp   .xit
                        	.noBypass:
                        		; If the device is a UI device there may be multiple owning jobs. It doesn't
                        		; do any good to check for ownership. Instead the I/O focus is checked to
                        		; see if it's present.
FFFFFFFFFFFC0885.8 01FC3247C 		call  GetUIFlag
FFFFFFFFFFFC088A.0 16005700C 		tst   $cr0,$a1
FFFFFFFFFFFC088E.8 00000008F 
FFFFFFFFFFFC0893.0 007FC044E 		beq   $cr0,.checkOwner
FFFFFFFFFFFC0897.8 301079560 	  ldo   $a1,16[$sp]
FFFFFFFFFFFC089C.0 01FC2787C 		call  WaitForIOFocus
FFFFFFFFFFFC08A0.8 FE045B878 		jmp   .0001
                        	.checkOwner:
FFFFFFFFFFFC08A5.0 01FC2387C 	  call  CheckDevOwner
FFFFFFFFFFFC08A9.8 16005300C 	  tst   $cr0,$a0
FFFFFFFFFFFC08AE.0 00000008F 
FFFFFFFFFFFC08B2.8 007FC0A4F 	  bne   $cr0,.notOwner
                        	.0001:
FFFFFFFFFFFC08B7.0 301079560 	  ldo   $a1,16[$sp]
FFFFFFFFFFFC08BB.8 001A01404 		ldi		$a0,#26							; FMTK_IO
FFFFFFFFFFFC08C0.0 000D01604 		ldi		$a2,#13							; putchar function
FFFFFFFFFFFC08C4.8 000210000 		brk   #240
	mov   $a0,$a3
FFFFFFFFFFFC08C9.0 02005D402 
                        	.xit:
FFFFFFFFFFFC08CD.8 301079560 		ldo		$a1,16[$sp]
FFFFFFFFFFFC08D2.0 301879660 		ldo		$a2,24[$sp]
FFFFFFFFFFFC08D6.8 002079E04 		add   $sp,$sp,#32
FFFFFFFFFFFC08DB.0 000879E7B 		ret
.notOwner:
FFFFFFFFFFFC08DF.8 001A01404 	  ldi   $a0,#EOF
FFFFFFFFFFFC08E4.0 FE0466C78 	  jmp   .xit
                        	 
                        	;------------------------------------------------------------------------------
                        	; fgetc - get a character from an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		4 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device getchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		a0 character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	fgetc:
FFFFFFFFFFFC08E8.8 FFE079E04 		sub	$sp,$sp,#32
FFFFFFFFFFFC08ED.0 301579070 		sto		$a1,16[$sp]
FFFFFFFFFFFC08F1.8 301679870 		sto		$a2,24[$sp]
FFFFFFFFFFFC08F6.0 01FBFA07C 		call  GetUIFlag
FFFFFFFFFFFC08FA.8 16005400C 		tst   $a1
FFFFFFFFFFFC08FF.0 00000008F 
FFFFFFFFFFFC0903.8 007FFC44E 		beq   .checkOwner
FFFFFFFFFFFC0908.0 201079560 		ldt		$a1,16[$sp]
FFFFFFFFFFFC090C.8 01FBEF47C 		call  WaitForIOFocus
FFFFFFFFFFFC0911.0 FE0496078 		jmp   .0001
                        	.checkOwner:
FFFFFFFFFFFC0915.8 201079560 		ldt		$a1,16[$sp]
FFFFFFFFFFFC091A.0 01FBE907C 	  call  CheckDevOwner
FFFFFFFFFFFC091E.8 16005000C 	  tst   $a0
FFFFFFFFFFFC0923.0 00000008F 
FFFFFFFFFFFC0927.8 007FFCA4F 	  bne   .notOwner
                        	.0001:
FFFFFFFFFFFC092C.0 001A01404 		ldi		$a0,#26							; FMTK_IO
FFFFFFFFFFFC0930.8 201079560 		ldt		$a1,16[$sp]
FFFFFFFFFFFC0935.0 000801604 		ldi		$a2,#8							; getchar function
FFFFFFFFFFFC0939.8 000210000 		brk   #240
	mov   $a0,$a1
FFFFFFFFFFFC093E.0 020055402 
                        	.0002:
FFFFFFFFFFFC0942.8 301079560 		ldo		$a1,16[$sp]
FFFFFFFFFFFC0947.0 301879660 		ldo		$a2,24[$sp]
FFFFFFFFFFFC094B.8 002079E04 		add   $sp,$sp,#32
FFFFFFFFFFFC0950.0 000879E7B 		ret
.notOwner:
FFFFFFFFFFFC0954.8 FFFF01404 	  ldi   $a0,#-1
FFFFFFFFFFFC0959.0 FE04A1478 	  jmp   .0002
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFFFFFFFFFC095D.8 000A01404 			ldi		$a0,#10
FFFFFFFFFFFC0962.0 000601604 			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	  ; align cache
                        	Monitor:
                        	.getFocus:
                        	;	ldi   $a0,#20       ; has IO focus
                        	;	brk #240
                        	;	bnez  $v1,.hasFocus
                        	;	ldi   $a0,#21       ; switch focus
                        	;	brk #240
                        	;	bra   .getFocus
                        	.hasFocus:
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFFFFFFFFFC0966.8 000000B04 		ldi		  $s1,#0					; s1 = input pointer
FFFFFFFFFFFC096B.0 0002D8C7C 		call    PutInlineString
FFFFFFFFFFFC096F.8 870E3A0D0 		db      CR,LNFD,'>',0
                        	.0001:
FFFFFFFFFFFC0972.8 FFFE9687C 		call	    Getch						; wait until character pressed
FFFFFFFFFFFC0977.0 16005000C 		tst     $a0        ; test return value
FFFFFFFFFFFC097B.8 00000008F 
FFFFFFFFFFFC0980.0 FFFFFFD48 		bmi	    .0001
FFFFFFFFFFFC0984.8 000001400 		seq     $a0,#LNFD  ; process line feed
	seq.or  $a0,#CR    ; and carriage return
                        		bt	    .procLine
FFFFFFFFFFFC0989.0 000001400 		seq		  $a0,#BS
	bt	    .doBackspace
FFFFFFFFFFFC098D.8 000001400 		seq		  $a0,#DEL
	bt	    .doDelete
FFFFFFFFFFFC0992.0 02142C070 		stb		  $a0,INBUF[$s1]
FFFFFFFFFFFC0996.8 00012CB04 		add		  $s1,$s1,#1
FFFFFFFFFFFC099B.0 FFFE9447C 		call    Putch
FFFFFFFFFFFC099F.8 FE04B9478 		jmp		  .0001
                        	.doDelete:
FFFFFFFFFFFC09A4.0 02002CC02 		mov		  $s2,$s1
FFFFFFFFFFFC09A8.8 000130C04 		add		  $s2,$s2,#1
                        	.0002:
FFFFFFFFFFFC09AD.0 010030360 		ldb		  $t0,INBUF[$s2]
FFFFFFFFFFFC09B1.8 018333F70 		stb		  $t0,INBUF-1[$s2]
FFFFFFFFFFFC09B6.0 000130C04 		add		  $s2,$s2,#1
FFFFFFFFFFFC09BA.8 010030304 		add		  $t0,$s2,#INBUF
FFFFFFFFFFFC09BF.0 007F00328 		slt		  $t0,#INBUF+$7F
                        		bt		  .0002
FFFFFFFFFFFC09C3.8 020030070 		stb		  $x0,INBUF[$s2]
FFFFFFFFFFFC09C8.0 FE04B9478 		jmp		  .0001
                        	.doBackspace:
FFFFFFFFFFFC09CC.8 16002C00C 	  tst     $s1
FFFFFFFFFFFC09D1.0 00000008F 
FFFFFFFFFFFC09D5.8 FFFFFEA4E 		beq		  .0001		        ; can't backspace anymore
FFFFFFFFFFFC09DA.0 FFFE74C7C 		call    Putch           ; show the backspace
FFFFFFFFFFFC09DE.8 FFFF2CB04 		sub		  $s1,$s1,#1
FFFFFFFFFFFC09E3.0 02002CC02 		mov		  $s2,$s1
                        	.0003:
FFFFFFFFFFFC09E7.8 010130360 		ldb		  $t0,INBUF+1[$s2]
FFFFFFFFFFFC09EC.0 020330070 		stb		  $t0,INBUF[$s2]
FFFFFFFFFFFC09F0.8 000130C04 		add		  $s2,$s2,#1
FFFFFFFFFFFC09F5.0 010030304 		add		  $t0,$s2,#INBUF
FFFFFFFFFFFC09F9.8 007F00328 		slt		  $t0,#INBUF+$7F
                        		bt		  .0003
FFFFFFFFFFFC09FE.0 020030070 		stb		  $x0,INBUF[$s2]
FFFFFFFFFFFC0A02.8 FE04B9478 		jmp		  .0001
                        	.procLine:
FFFFFFFFFFFC0A07.0 02002C070 		stb		  $x0,INBUF[$s1]
FFFFFFFFFFFC0A0B.8 000000B04 		ldi		  $s1,#0
                        	.skip:
FFFFFFFFFFFC0A10.0 01002C360 		ldb.	  $t0,INBUF[$s1]
FFFFFFFFFFFC0A14.8 00FFFCA4E 		beq		  .0005
FFFFFFFFFFFC0A19.0 000000300 		seq		  $t0,#'>'
	bf		  .0004
                        	.skip2:
FFFFFFFFFFFC0A1D.8 00012CB04 		add		  $s1,$s1,#1
FFFFFFFFFFFC0A22.0 FE0508078 		jmp		  .skip
                        	.0004:
FFFFFFFFFFFC0A26.8 000000300 		seq		  $t0,#' '
	seq.or  $t0,#'\t'
                        		bt		  .skip2
FFFFFFFFFFFC0A2B.0 000000300 		seq     $t0,#'X'  ; exit from monitor
	bf      .notX
FFFFFFFFFFFC0A2F.8 000001404 		ldi     $a0,#E_Ok
FFFFFFFFFFFC0A34.0 000000050 		jmp     OSExit
FFFFFFFFFFFC0A38.8 F00000051 
FFFFFFFFFFFC0A3D.0 00006EC78 
                        	.notX:
FFFFFFFFFFFC0A41.8 000000300 		seq		  $t0,#'M'
	bt	    doMem
FFFFFFFFFFFC0A46.0 000000300 		seq     $t0,#'V'
	bt      doVMem
FFFFFFFFFFFC0A4A.8 000000300 		seq     $t0,#'P'
	bt      doPStat
FFFFFFFFFFFC0A4F.0 000000300 		seq		  $t0,#'B'
	bt		  .0006
FFFFFFFFFFFC0A53.8 00021147C 		call    GetDecNum
FFFFFFFFFFFC0A58.0 16005000C 		tst     $a0
FFFFFFFFFFFC0A5C.8 00000008F 
FFFFFFFFFFFC0A61.0 007FFC24F 		bne     .basSize
FFFFFFFFFFFC0A65.8 7D0001404 		ldi     $a0,#32000
                        	.basSize:
FFFFFFFFFFFC0A6A.0 000C01404 		ldi		  $a0,#12					; Start App
FFFFFFFFFFFC0A6E.8 000000050 		ldi     $a1,#TBASR
FFFFFFFFFFFC0A73.0 F00000051 
FFFFFFFFFFFC0A77.8 01EF01504 
FFFFFFFFFFFC0A7C.0 000210000 		brk     #240
	mov		  $s1,$a1					; save v1
FFFFFFFFFFFC0A80.8 020054B02 
FFFFFFFFFFFC0A85.0 FFFFF1050 		ldi		  $a0,#msgCRLF
FFFFFFFFFFFC0A89.8 846201404 
FFFFFFFFFFFC0A8E.0 00026487C 		call    PutString
FFFFFFFFFFFC0A92.8 02002D402 		mov		  $a0,$s1					; get back v1
FFFFFFFFFFFC0A97.0 00021EC7C 		call    PutHexByte
FFFFFFFFFFFC0A9B.8 FFFFF1050 		ldi		  $a0,#msgTaskStart
FFFFFFFFFFFC0AA0.0 844601404 
FFFFFFFFFFFC0AA4.8 00025947C 		call    PutString
FFFFFFFFFFFC0AA9.0 01FB1807C 		call    DumpReadyQueue
                        		; The monitor is running in machine mode. A return instruction is used to
                        		; switch to user mode. The return address must be set to the desired user
                        		; code address.
                        		
FFFFFFFFFFFC0AAD.8 00100400F 	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	; disable interrupts
FFFFFFFFFFFC0AB2.0 000000050 		ldi     $t0,#CSTART       ; pick start of Tiny Basic
FFFFFFFFFFFC0AB6.8 F00000051 
FFFFFFFFFFFC0ABB.0 01F300304 
FFFFFFFFFFFC0ABF.8 00D04C00F 		csrrw   $x0,#$341,$t0     ; set as return address
FFFFFFFFFFFC0AC4.0 000002250 		ldi     $t0,#$00011111    ; bits to select register set #1
FFFFFFFFFFFC0AC8.8 111100304 
FFFFFFFFFFFC0ACD.0 10048C00F 		csrrw   $x0,#CSR_REGSET,$t0     ; select register set #1 (will decrement to zero then on mret)
FFFFFFFFFFFC0AD1.8 000000045 		rte                     ; will begin running Tiny Basic in user mode
	;ldi		$a0,#5					; Reschedule task
                        		;ldi		$a1,#1					; sleep(0)
                        		;brk #240
FFFFFFFFFFFC0AD6.0 FE04B3478 		jmp		  Monitor
                        	.0006:
FFFFFFFFFFFC0ADA.8 000000300 		seq		  $t0,#'D'
	bf		  .0007
FFFFFFFFFFFC0ADF.0 01012C360 		ldb		  $t0,INBUF+1[$s1]
FFFFFFFFFFFC0AE3.8 000000300 		seq		  $t0,#'T'
	bf		  .noT
FFFFFFFFFFFC0AE8.0 01FB0947C 		call    DumpTimeoutList
FFFFFFFFFFFC0AEC.8 FE04B3478 		jmp		  Monitor
                        	.noT:
FFFFFFFFFFFC0AF1.0 01FAF407C 		call	  DumpReadyQueue
                        		;ldi		$a0,#15
                        		;brk #240
FFFFFFFFFFFC0AF5.8 FE04B3478 		jmp		  Monitor
                        	.0007:
FFFFFFFFFFFC0AFA.0 000000300 		seq		  $t0,#'E'
	bt		  EditMem
FFFFFFFFFFFC0AFE.8 000000300 		seq		  $t0,#'F'
	bf		  .0009
FFFFFFFFFFFC0B03.0 01012C360 		ldb     $t0,INBUF+1[$s1]
FFFFFFFFFFFC0B07.8 000000327 		sne     $t0,#'I'
	bt      .notFind
FFFFFFFFFFFC0B0C.0 00012CB04 		add     $s1,$s1,#1
FFFFFFFFFFFC0B10.8 FE069E478 		jmp     Find
                        	.notFind:
FFFFFFFFFFFC0B15.0 FE0683478 		jmp		  FillMem
                        	.0009:
FFFFFFFFFFFC0B19.8 000000327 		sne		  $t0,#'S'
	bt		  .0010
FFFFFFFFFFFC0B1E.0 000501404 		ldi		  $a0,#5					; sleep(0)
FFFFFFFFFFFC0B22.8 000101504 		ldi		  $a1,#1
FFFFFFFFFFFC0B27.0 000210000 		brk     #240
	jmp		  Monitor
FFFFFFFFFFFC0B2B.8 FE04B3478 
                        	.0010:
FFFFFFFFFFFC0B30.0 000000327 		sne		  $t0,#'K'
	bt		  .0011
FFFFFFFFFFFC0B34.8 00016AC7C 		call    GetHexNum
FFFFFFFFFFFC0B39.0 020051502 		mov		  $a1,$a0					; a0 = pid
FFFFFFFFFFFC0B3D.8 000301404 		ldi		  $a0,#3					; kill task
FFFFFFFFFFFC0B42.0 000210000 		brk     #240
	jmp		  Monitor
FFFFFFFFFFFC0B46.8 FE04B3478 
                        	.0011:
FFFFFFFFFFFC0B4B.0 000000427 		sne		  $t1,#'?'
	bt		  .0012
FFFFFFFFFFFC0B4F.8 FFFFF1050 		ldi		  $a0,#msgMonHelp
FFFFFFFFFFFC0B54.0 826201404 
FFFFFFFFFFFC0B58.8 0001FF47C 		call    PutString
FFFFFFFFFFFC0B5D.0 FE04B3478 		jmp		  Monitor
                        	.0012:
                        	.0005:
FFFFFFFFFFFC0B61.8 FE04B3478 		jmp		  Monitor
                        	
                        	  ; align cache
                        	doMem:
FFFFFFFFFFFC0B66.0 FFF879E04 		sub	$sp,$sp,#8
FFFFFFFFFFFC0B6A.8 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0B6F.0 01002C360 		ldb		$t0,INBUF[$s1]
FFFFFFFFFFFC0B73.8 000000327 		sne   $t0,#'O'
	bt    .0001
FFFFFFFFFFFC0B78.0 00012CB04 		add		$s1,$s1,#1
                        	.0001:
FFFFFFFFFFFC0B7C.8 300B78070 		sto		$s1,[$sp]
FFFFFFFFFFFC0B81.0 000D01404 		ldi		$a0,#CR
FFFFFFFFFFFC0B85.8 FFFD9F07C 		call  Putch
FFFFFFFFFFFC0B8A.0 010001404 		ldi		$a0,#INBUF
FFFFFFFFFFFC0B8E.8 0001E447C 		call  PutString
FFFFFFFFFFFC0B93.0 300078B60 		ldo		$s1,[$sp]
FFFFFFFFFFFC0B97.8 000879E04 		add		$sp,$sp,#8
FFFFFFFFFFFC0B9C.0 00013707C 		call  GetHexNum
FFFFFFFFFFFC0BA0.8 020050D02 		mov		$s3,$a0
FFFFFFFFFFFC0BA5.0 020050F02 		mov   $s5,$a0
FFFFFFFFFFFC0BA9.8 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0BAE.0 00012E07C 		call	  GetHexNum
FFFFFFFFFFFC0BB2.8 080D50E02 		add		$s4,$a0,$s3
                        	.loop2:
FFFFFFFFFFFC0BB7.0 FFFD7447C 		call	Getch						; check for ctrl-c
FFFFFFFFFFFC0BBB.8 000001400 		seq		$a0,#3
	bt		Monitor
FFFFFFFFFFFC0BC0.0 000D01404 		ldi		$a0,#CR
FFFFFFFFFFFC0BC4.8 FFFD7F87C 		call	Putch
FFFFFFFFFFFC0BC9.0 020035402 		mov		$a0,$s3
FFFFFFFFFFFC0BCD.8 01FA9A47C 		call	PutHexWord
FFFFFFFFFFFC0BD2.0 003A01404 		ldi		$a0,#':'
FFFFFFFFFFFC0BD6.8 FFFD7687C 		call	Putch
FFFFFFFFFFFC0BDB.0 000700C04 		ldi		$s2,#7
                        	.loop:
FFFFFFFFFFFC0BDF.8 002001404 		ldi		$a0,#' '
FFFFFFFFFFFC0BE4.0 FFFD6FC7C 		call	Putch
FFFFFFFFFFFC0BE8.8 16000F00C 		tst   $cr0,$t0
FFFFFFFFFFFC0BED.0 00000008F 
FFFFFFFFFFFC0BF1.8 007FC064F 		bne   $cr0,.userMem
FFFFFFFFFFFC0BF6.0 002101404 		ldi   $a0,#33         ; Fetch memory word
FFFFFFFFFFFC0BFA.8 020035502 		mov   $a1,$s3
FFFFFFFFFFFC0BFF.0 000210000 		brk   #240
	mov   $a0,$a1
FFFFFFFFFFFC0C03.8 020055402 
FFFFFFFFFFFC0C08.0 FE0608878 		jmp   .0002
                        	.userMem
FFFFFFFFFFFC0C0C.8 000035460 		ldb		$a0,[$s3]
                        	.0002:
FFFFFFFFFFFC0C11.0 000161C7C 		call	PutHexByte
FFFFFFFFFFFC0C15.8 000134D04 		add		$s3,$s3,#1
R2 operation needs two source operands. (2232)
R2 operation needs two source operandsFFFFFFFFFFFC0C1A.0 0A007DF02 		sub.	$s2,$s2,#1
FFFFFFFFFFFC0C1E.8 FFFFFF249 		bge		.loop
FFFFFFFFFFFC0C23.0 000038D2C 		sltu  $s3,$s4
	bt	  .loop2
FFFFFFFFFFFC0C27.8 00017A87C 		call  PutInlineString
FFFFFFFFFFFC0C2C.0 003CD0202 		db    ' ',' ',0
FFFFFFFFFFFC0C2D.0 02003CD02 		mov   $s3,$s5
                        	.0004:
FFFFFFFFFFFC0C31.8 000035464 		ldbu  $a0,[$s3]
FFFFFFFFFFFC0C36.0 000001428 		slt   $a0,#$20
	bt    .unprintable
FFFFFFFFFFFC0C3A.8 FFFD4487C 		call  Putch
FFFFFFFFFFFC0C3F.0 FE0626478 		jmp   .0003
                        	.unprintable:
FFFFFFFFFFFC0C43.8 002E01404 	  ldi   $a0,#'.'
FFFFFFFFFFFC0C48.0 FFFD3DC7C 	  call  Putch
                        	.0003:
FFFFFFFFFFFC0C4C.8 000134D04 	  add   $s3,$s3,#1
FFFFFFFFFFFC0C51.0 000038D2C 	  sltu  $s3,$s4
  bt    .0004
FFFFFFFFFFFC0C55.8 000D01404 	  ldi   $a0,#CR
FFFFFFFFFFFC0C5A.0 FFFD34C7C 	  call  Putch
FFFFFFFFFFFC0C5E.8 FE04B3478 		jmp		Monitor		
                        	
                        	  ; align cache
                        	EditMem:
FFFFFFFFFFFC0C63.0 00010400F 		csrrs $x0,#CSR_UIE,#1        ; enable gc interrupt
FFFFFFFFFFFC0C67.8 0000D147C 		call	  GetHexNum			; get address to edit
FFFFFFFFFFFC0C6C.0 020050D02 		mov		$s3,$a0
FFFFFFFFFFFC0C70.8 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0C75.0 0000CA87C 		call	  GetHexNum			; get value to set
FFFFFFFFFFFC0C79.8 000D50070 		stb		$s3,[$a0]			; update mem
FFFFFFFFFFFC0C7E.0 FE04B3478 		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >V 0
                        	; Displays the virtual memory map for the specified app.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	doVMem:
FFFFFFFFFFFC0C82.8 00012CB04 	  add   $s1,$s1,#1
FFFFFFFFFFFC0C87.0 0000F787C 	  call  GetDecNum
FFFFFFFFFFFC0C8B.8 000000404 	  ldi   $t1,#0
FFFFFFFFFFFC0C90.0 021050302 	  asl   $t0,$a0,#16
                        	.0001:
R2 operation needs two source operands. (2300)
R2 operation needs two source operandsFFFFFFFFFFFC0C94.8 00007DF02 	  and.  $a0,$t1,#3
FFFFFFFFFFFC0C99.0 007FFC24F 	  bne   .notLF
FFFFFFFFFFFC0C9D.8 00013F87C 	  call  PutInlineString
FFFFFFFFFFFC0CA2.0 40200A0D0 	  db    CR,LNFD,0
                        	.notLF:
FFFFFFFFFFFC0CA5.0 02000D402 	  mov   $a0,$t0
FFFFFFFFFFFC0CA9.8 01FA2C47C 	  call  PutHexWord
FFFFFFFFFFFC0CAE.0 003A01404 	  ldi   $a0,#':'
FFFFFFFFFFFC0CB2.8 FFFD0887C 	  call  Putch
FFFFFFFFFFFC0CB7.0 380301402 	  mvmap $a0,$x0,$t0
FFFFFFFFFFFC0CBB.8 01FA2607C 	  call  PutHexHalf
FFFFFFFFFFFC0CC0.0 002001404 	  ldi   $a0,#' '
FFFFFFFFFFFC0CC4.8 FFFCFF87C 	  call  Putch
FFFFFFFFFFFC0CC9.0 00010C304 	  add   $t0,$t0,#1
FFFFFFFFFFFC0CCD.8 000110404 	  add   $t1,$t1,#1
FFFFFFFFFFFC0CD2.0 000000428 	  slt   $t1,#256
  bt    .0001
FFFFFFFFFFFC0CD6.8 FE04B3478 	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >P
                        	; Display the PAM bits status.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	doPStat:
FFFFFFFFFFFC0CDB.0 000120C7C 	  call  PutInlineString
FFFFFFFFFFFC0CDF.8 40000A0D0 	  db    CR,LNFD,0
FFFFFFFFFFFC0CE2.8 000000404 	  ldi   $t1,#0        ; $a1 = bit number
                        	.0001:
FFFFFFFFFFFC0CE7.0 002001404 	  ldi   $a0,#32       ; Get PAM bit pair
FFFFFFFFFFFC0CEB.8 000210000 	  brk   #240
  add   $a0,$a1,#'0'
FFFFFFFFFFFC0CF0.0 003055404 
FFFFFFFFFFFC0CF4.8 FFFCE787C 	  call  Putch
FFFFFFFFFFFC0CF9.0 000110404 	  add   $t1,$t1,#1
FFFFFFFFFFFC0CFD.8 000000428 	  slt   $t1,#MEMSZ
  bne   .0001
FFFFFFFFFFFC0D02.0 FE04B3478 	  jmp   Monitor
                        	 
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	FillMem:
FFFFFFFFFFFC0D06.8 000081C7C 		call	GetHexNum			; get address
FFFFFFFFFFFC0D0B.0 020050D02 		mov		$s3,$a0
FFFFFFFFFFFC0D0F.8 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0D14.0 00007B07C 		call	GetHexNum			; get length
FFFFFFFFFFFC0D18.8 020050E02 		mov		$s4,$a0
FFFFFFFFFFFC0D1D.0 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0D21.8 00007447C 		call	GetHexNum			; get byte to use
                        	.0001:
R2 operation needs two source operands. (2385)
R2 operation needs two source operandsFFFFFFFFFFFC0D26.0 0A007DF02 		sub.	$s4,$s4,#1
FFFFFFFFFFFC0D2A.8 000038058 		stb		$a0,[$s3+$s4]
FFFFFFFFFFFC0D2F.0 001434071 
FFFFFFFFFFFC0D33.8 FFFFFFD48 		bgt		.0001
FFFFFFFFFFFC0D38.0 FE04B3478 		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; FI Hello
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	Find:
FFFFFFFFFFFC0D3C.8 000D01404 	  ldi   $a0,#CR
FFFFFFFFFFFC0D41.0 FFFCC147C 	  call  Putch
FFFFFFFFFFFC0D45.8 000A01404 	  ldi   $a0,#LNFD
FFFFFFFFFFFC0D4A.0 FFFCBCC7C 	  call  Putch
FFFFFFFFFFFC0D4E.8 00005287C 	  call  SkipSpaces
FFFFFFFFFFFC0D53.0 02002CC02 	  mov   $s2,$s1
                        	.fwe:
FFFFFFFFFFFC0D57.8 010030364 	  ldbu.   $t0,INBUF[$s2]
FFFFFFFFFFFC0D5C.0 0003FFF0D 	  seq.or  $t0,#' '
FFFFFFFFFFFC0D60.8 0003FFF0D 	  seq.or  $t0,#CR    ; cmp power!
                        	  bt      .endOfWord
FFFFFFFFFFFC0D65.0 000130C04 	  add     $s2,$s2,#1
FFFFFFFFFFFC0D69.8 FE06ABC78 	  jmp     .fwe
                        	.endOfWord:
FFFFFFFFFFFC0D6E.0 020030070 	  stb   $x0,INBUF[$s2]
FFFFFFFFFFFC0D72.8 02002CC02 	  mov   $s2,$s1
FFFFFFFFFFFC0D77.0 000001404 	  ldi   $a0,#0
FFFFFFFFFFFC0D7B.8 000001504 	  ldi   $a1,#0
                        	.loop:
FFFFFFFFFFFC0D80.0 FFFC8FC7C 		call	Getch						; check for ctrl-c
FFFFFFFFFFFC0D84.8 000001400 		seq   $a0,#3
	bt	  Monitor
                        	.0001:
FFFFFFFFFFFC0D89.0 000050364 	  ldbu  $t0,[$a0]
FFFFFFFFFFFC0D8D.8 010030464 	  ldbu. $t1,INBUF[$s2]
FFFFFFFFFFFC0D92.0 007FFCD4E 	  beq   .found
FFFFFFFFFFFC0D96.8 000010300 	  seq   $t0,$t1
  bf    .next
FFFFFFFFFFFC0D9B.0 000151404 	  add   $a0,$a0,#1
FFFFFFFFFFFC0D9F.8 000130C04 	  add   $s2,$s2,#1
FFFFFFFFFFFC0DA4.0 FE06C0078 	  jmp   .loop
                        	.next:
FFFFFFFFFFFC0DA8.8 02002CC02 	  mov   $s2,$s1         ; start over again with $s2
FFFFFFFFFFFC0DAD.0 000155404 	  add   $a0,$a1,#1      ; start over again with $a0, but increment by one
FFFFFFFFFFFC0DB1.8 000010050 	  ldi   $t2,#$80000     ; 512k
FFFFFFFFFFFC0DB6.0 000000504 
FFFFFFFFFFFC0DBA.8 020051502 	  mov   $a1,$a0         ; remember new starting pos.
FFFFFFFFFFFC0DBF.0 08055000D 	  slt   $cr0,$a0,$t2
FFFFFFFFFFFC0DC3.8 FFFFC314F 	  bne   $cr0,.loop
FFFFFFFFFFFC0DC8.0 FE06EE878 	  jmp   .notFound
                        	.found:
FFFFFFFFFFFC0DCC.8 00007687C 	  call  PutHexTetra
FFFFFFFFFFFC0DD1.0 0000A5C7C 	  call  PutInlineString
FFFFFFFFFFFC0DD5.8 47000A0D0 	  db    CR,LNFD,0
FFFFFFFFFFFC0DD8.8 FE06D4478 	  jmp   .next
                        	.notFound:
FFFFFFFFFFFC0DDD.0 000D01404 	  ldi   $a0,#CR
FFFFFFFFFFFC0DE1.8 FFFC7107C 	  call  Putch
FFFFFFFFFFFC0DE6.0 000A01404 	  ldi   $a0,#LNFD
FFFFFFFFFFFC0DEA.8 FFFC6C87C 	  call  Putch
FFFFFFFFFFFC0DEF.0 FE04B3478 	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	SkipSpaces:
                        	.skip2:
FFFFFFFFFFFC0DF3.8 01002C360 		ldb		  $t0,INBUF[$s1]
FFFFFFFFFFFC0DF8.0 000000300 		seq		  $t0,#' '   ; space or
	seq.or  $t0,#'\t'  ; tab - compare power use here
                        		bf	    .done
FFFFFFFFFFFC0DFC.8 00012CB04 		add 		$s1,$s1,#1
FFFFFFFFFFFC0E01.0 FFFFF9479 		bra	  	.skip2
                        	.done
FFFFFFFFFFFC0E05.8 000879E7B 	  ret

                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	GetHexNum:
FFFFFFFFFFFC0E0A.0 000001404 		ldi		$a0,#0							; a0 = num
FFFFFFFFFFFC0E0E.8 FFFFF287C 		call   	SkipSpaces
                        	.next:
FFFFFFFFFFFC0E13.0 01002C360 		ldb		  $t0,INBUF[$s1]
FFFFFFFFFFFC0E17.8 000000329 		sge     $t0,#'0'
	sle.and	$t0,#'9'
                        		bt		  .isDigit
FFFFFFFFFFFC0E1C.0 000000329 		sge		  $t0,#'A'
	sle.and $t0,#'F'
                        		bt		  .isHexUpper
FFFFFFFFFFFC0E20.8 000000329 		sge		  $t0,#'a'
	sle.and	$t0,#'f'
                        		bt		.isHexLower
                        	.0001:
FFFFFFFFFFFC0E25.0 000879E7B 		ret
.isHexUpper:
FFFFFFFFFFFC0E29.8 020451402 		asl		$a0,$a0,#4
FFFFFFFFFFFC0E2E.0 FFBF0C304 		sub		$t0,$t0,#'A'
FFFFFFFFFFFC0E32.8 000A0C304 		add		$t0,$t0,#10
FFFFFFFFFFFC0E37.0 020351402 		or		$a0,$a0,$t0
FFFFFFFFFFFC0E3B.8 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0E40.0 FE0709878 		jmp		.next
                        	.isHexLower:
FFFFFFFFFFFC0E44.8 020451402 		asl		$a0,$a0,#4
FFFFFFFFFFFC0E49.0 FF9F0C304 		sub		$t0,$t0,#'a'
FFFFFFFFFFFC0E4D.8 000A0C304 		add		$t0,$t0,#10
FFFFFFFFFFFC0E52.0 020351402 		or		$a0,$a0,$t0
FFFFFFFFFFFC0E56.8 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0E5B.0 FE0709878 		jmp		.next
                        	.isDigit:
FFFFFFFFFFFC0E5F.8 020451402 		asl		$a0,$a0,#4
FFFFFFFFFFFC0E64.0 FFD00C304 		sub		$t0,$t0,#'0'
FFFFFFFFFFFC0E68.8 020351402 		or		$a0,$a0,$t0
FFFFFFFFFFFC0E6D.0 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0E71.8 FE0709878 		jmp		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a decimal number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	GetDecNum:
FFFFFFFFFFFC0E76.0 000001404 		ldi		$a0,#0							; a0 = num
FFFFFFFFFFFC0E7A.8 FFFFBC87C 		call 	  SkipSpaces
                        	.next:
FFFFFFFFFFFC0E7F.0 01002C360 		ldb		  $t0,INBUF[$s1]
FFFFFFFFFFFC0E83.8 000000329 		sge     $t0,#'0'
	sle.and $t0,#'9'
                        		bt		  .isDigit
                        	.0001:
FFFFFFFFFFFC0E88.0 000879E7B 		ret
.isDigit:
FFFFFFFFFFFC0E8C.8 020150502 		asl		$t2,$a0,#1    ; multiply by 10
FFFFFFFFFFFC0E91.0 020351402 		asl   $a0,$a0,#3    ; * 8
FFFFFFFFFFFC0E95.8 080551402 		add   $a0,$a0,$t2   ; + *2
FFFFFFFFFFFC0E9A.0 FFD00C304 		sub		$t0,$t0,#'0'
FFFFFFFFFFFC0E9E.8 080351402 		add		$a0,$a0,$t0
FFFFFFFFFFFC0EA3.0 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0EA7.8 FE073F878 		jmp		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output an octabyte as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains octabyte value to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	PutHexOcta:
FFFFFFFFFFFC0EAC.0 082051402 		ror		$a0,$a0,#32
FFFFFFFFFFFC0EB0.8 00000487C 		call	PutHexTetra
FFFFFFFFFFFC0EB5.0 062051402 		rol   $a0,$a0,#32
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains word to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexTetra:
FFFFFFFFFFFC0EB9.8 081051402 		ror		$a0,$a0,#16
FFFFFFFFFFFC0EBE.0 00000487C 		call	PutHexWyde
FFFFFFFFFFFC0EC2.8 061051402 		rol		$a0,$a0,#16
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexWyde:
FFFFFFFFFFFC0EC7.0 080851402 		ror		$a0,$a0,#8
FFFFFFFFFFFC0ECB.8 00000487C 		call	PutHexByte
FFFFFFFFFFFC0ED0.0 060851402 		rol		$a0,$a0,#8
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexByte:
FFFFFFFFFFFC0ED4.8 080451402 		ror		$a0,$a0,#4		; put the high order nybble first
FFFFFFFFFFFC0ED9.0 00000487C 		call	PutHexNybble
FFFFFFFFFFFC0EDD.8 060451402 		rol		$a0,$a0,#4		; restore a0
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains nybble to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexNybble:
FFFFFFFFFFFC0EE2.0 FFF079E04 		sub	$sp,$sp,#16
FFFFFFFFFFFC0EE6.8 301478070 		sto		$a0,0[$sp]
FFFFFFFFFFFC0EEB.0 300378870 		sto   $t0,8[$sp]
FFFFFFFFFFFC0EEF.8 000F51408 		and		$a0,$a0,#15		; strip off high order bits
FFFFFFFFFFFC0EF4.0 000001428 		slt   $a0,#10
	bt		.lt10
FFFFFFFFFFFC0EF8.8 FFF651404 		sub		$a0,$a0,#10
FFFFFFFFFFFC0EFD.0 001151404 		add		$a0,$a0,#'A'-'0'
                        	.lt10:
FFFFFFFFFFFC0F01.8 003051404 		add		$a0,$a0,#'0'
FFFFFFFFFFFC0F06.0 FFFBDEC7C 		call	Putch
                        	.0001:
FFFFFFFFFFFC0F0A.8 300079460 		ldo		$a0,0[$sp]
FFFFFFFFFFFC0F0F.0 300878360 		ldo   $t0,8[$sp]
FFFFFFFFFFFC0F13.8 001079E04 		add   $sp,$sp,#16
FFFFFFFFFFFC0F18.0 000879E7B 		ret

                        	;------------------------------------------------------------------------------
                        	; PutInlineString
                        	;   Put a string of characters to output device. The string parameter is
                        	; located as an inline parameter.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutInlineString:
FFFFFFFFFFFC0F1C.8 300078460 	  ldo   $t1,[$sp]         ; pop return address
FFFFFFFFFFFC0F21.0 000879E04 	  add   $sp,$sp,#8
FFFFFFFFFFFC0F25.8 FFF879E04 		sub		$sp,$sp,#8				
FFFFFFFFFFFC0F2A.0 301478070 		sto		$a0,[$sp]				  ; save a0
FFFFFFFFFFFC0F2E.8 000410404 		add		$t1,$t1,#4  			; t1 = pointer to string
                        	.0001:
FFFFFFFFFFFC0F33.0 000011460 		ldb		$a0,[$t1]
FFFFFFFFFFFC0F37.8 000110404 		add		$t1,$t1,#1				; advance pointer to next byte
FFFFFFFFFFFC0F3C.0 00405034E 		beq 	$a0,#0,.done      ; branch if done
FFFFFFFFFFFC0F40.8 FFFBC187C 		call	Putch							; output character
FFFFFFFFFFFC0F45.0 FFFFF7079 		bra		.0001
                        	.done:
FFFFFFFFFFFC0F49.8 300079460 		ldo		$a0,[$sp]				  ; restore a0
FFFFFFFFFFFC0F4E.0 000879E04 		add   $sp,$sp,#8
FFFFFFFFFFFC0F52.8 000010078 	  jmp   [$t1]
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	PutString:
FFFFFFFFFFFC0F57.0 FFF079E04 		sub		$sp,$sp,#16
FFFFFFFFFFFC0F5B.8 301478070 		sto		$a0,[$sp]				  ; save argument
FFFFFFFFFFFC0F60.0 300B78870 		sto   $s1,8[$sp]        ; and reg var
FFFFFFFFFFFC0F64.8 020050B02 		mov		$s1,$a0						; t1 = pointer to string
                        	.0001:
FFFFFFFFFFFC0F69.0 00002D460 		ldb		$a0,[$s1]
FFFFFFFFFFFC0F6D.8 00012CB04 		add		$s1,$s1,#1				; advance pointer to next byte
FFFFFFFFFFFC0F72.0 00405034E 		beq 	$a0,#0,.done     	; branch if done
FFFFFFFFFFFC0F76.8 FFFBA687C 		call	Putch							; output character
FFFFFFFFFFFC0F7B.0 FFFFF7079 		bra		.0001
                        	.done:
FFFFFFFFFFFC0F7F.8 300079460 		ldo		$a0,[$sp]				  ; restore argument
FFFFFFFFFFFC0F84.0 300878B60 		ldo   $s1,8[$sp]
FFFFFFFFFFFC0F88.8 001079E04 		add   $sp,$sp,#16
FFFFFFFFFFFC0F8D.0 000879E7B 		ret

                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	DumpTraceQueue:
FFFFFFFFFFFC0F91.8 005801A04 		ldi     $a6,#'X'        ; bypass='B' in fputc routine
                        	.dmpTrace:
FFFFFFFFFFFC0F96.0 000D01404 		ldi     $a0,#CR
FFFFFFFFFFFC0F9A.8 FFFB9487C 		call    Putch
FFFFFFFFFFFC0F9F.0 000E01504 		ldi     $a1,#14         ; processor trace queue status
FFFFFFFFFFFC0FA3.8 140055407 		peekq.  $a0,$a1
FFFFFFFFFFFC0FA8.0 007FFC548 		bmi     .dmpTraceEmpty  ; emptied out?
FFFFFFFFFFFC0FAC.8 000F01504 		ldi     $a1,#15         ; processor trace queue data
FFFFFFFFFFFC0FB1.0 000003FAA 		popq.   $a0,$a1
FFFFFFFFFFFC0FB5.8 FFFF7B47C 		call    PutHexOcta
FFFFFFFFFFFC0FBA.0 FE07CB078 		jmp     .dmpTrace
                        	.dmpTraceEmpty:
FFFFFFFFFFFC0FBE.8 000D01404 		ldi     $a0,#CR
FFFFFFFFFFFC0FC3.0 FFFB8047C 		call    Putch
                        	.inf:
FFFFFFFFFFFC0FC7.8 FE07E3C78 	  jmp     .inf
FFFFFFFFFFFC0FCC.0 000879E7B 	  ret

                        	;------------------------------------------------------------------------------
                        	; Exception processing code staret here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;
                        	; On incoming the register file has been set to the interrupt register file
                        	; or the machine mode register file.
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC0FD0.8 000000000 	  align 16
FFFFFFFFFFFC0FD5.0 000000000 
FFFFFFFFFFFC0FD9.8 000000000 
FFFFFFFFFFFC0FDE.0 000000000 
                        	; Top of stack for different register sets
                        	StackTbl:
FFFFFFFFFFFC0FE0.0 000000000 	  dw    $0
FFFFFFFFFFFC0FE4.8 000000000 
FFFFFFFFFFFC0FE8.0 000000000 	  dw    $0
FFFFFFFFFFFC0FEC.8 000000000 
FFFFFFFFFFFC0FF0.0 000000000 	  dw    $0
FFFFFFFFFFFC0FF4.8 000000000 
FFFFFFFFFFFC0FF8.0 000000000 	  dw    $0
FFFFFFFFFFFC0FFC.8 000000000 
FFFFFFFFFFFC1000.0 000000000 	  dw    $0
FFFFFFFFFFFC1004.8 000000000 
FFFFFFFFFFFC1008.0 000000000 	  dw    $0
FFFFFFFFFFFC100C.8 000000000 
FFFFFFFFFFFC1010.0 000000000 	  dw    $0
FFFFFFFFFFFC1014.8 000000000 
FFFFFFFFFFFC1018.0 000000000 	  dw    $0
FFFFFFFFFFFC101C.8 000000000 
FFFFFFFFFFFC1020.0 000000000 	  dw    $0
FFFFFFFFFFFC1024.8 000000000 
FFFFFFFFFFFC1028.0 000000000 	  dw    $0
FFFFFFFFFFFC102C.8 000000000 
FFFFFFFFFFFC1030.0 000000000 	  dw    $0
FFFFFFFFFFFC1034.8 000000000 
FFFFFFFFFFFC1038.0 000000000 	  dw    $0
FFFFFFFFFFFC103C.8 CF0000000 
FFFFFFFFFFFC1040.0 000703FCF 	  dw    $7F400-4
FFFFFFFFFFFC1044.8 CF0000000 
FFFFFFFFFFFC1048.0 000707FCF 	  dw    $7F800-4
FFFFFFFFFFFC104C.8 CF0000000 
FFFFFFFFFFFC1050.0 00070BFCF 	  dw    $7FC00-4
FFFFFFFFFFFC1054.8 CF0000000 
FFFFFFFFFFFC1058.0 00070FFCF 	  dw    $80000-4
FFFFFFFFFFFC105C.8 0F0000000 
                        	
                        	.file "any1_rom.r64",1238
                        		code
                        		align	16
                        	IRQRout:
FFFFFFFFFFFC1060.0 00D08030F 		csrrw	$t0,#$342,$x0			; get cause code
FFFFFFFFFFFC1064.8 16000C00C 		tst   $t0
FFFFFFFFFFFC1069.0 00000008F 
FFFFFFFFFFFC106D.8 007FFD548 		bmi	  .isIRQ		        ; irq or brk #240?
FFFFFFFFFFFC1072.0 000000300 		seq   $t0,#2            ; illegal instruction?
	bt    .illegal
FFFFFFFFFFFC1076.8 01FFFFF50 		and   $t2,$t0,#$FFFFFFFC
FFFFFFFFFFFC107B.0 FFFC0C508 
FFFFFFFFFFFC107F.8 000000500 		seq   $t2,#8
	bt    .brk
                        		; Some other cause
                        	.illegal:
FFFFFFFFFFFC1084.0 000000850 	  stt   $t0,$4018
FFFFFFFFFFFC1088.8 200301870 
FFFFFFFFFFFC108D.0 10280400F 		csrrc $x0,#CSR_TRACECTRL,#1 ; turn off tracing
FFFFFFFFFFFC1091.8 FFFFF0350 		ldi   $t0,#DumpTraceQueue
FFFFFFFFFFFC1096.0 1F2300304 
FFFFFFFFFFFC109A.8 00120C00F 		csrrw $x0,#CSR_MEPC,$t0
FFFFFFFFFFFC109F.0 000000045 		rte
.soc:
FFFFFFFFFFFC10A3.8 FE0851C78 	  jmp   .soc
                        	.brk:
                        	  ; We reset the stack pointer at each callto the OS in case an error causes
                        	  ; it to be messed up.
FFFFFFFFFFFC10A8.0 0010C030F 	  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
FFFFFFFFFFFC10AC.8 000F0C308 	  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
FFFFFFFFFFFC10B1.0 02020C502 	  asl   $t2,$t0,#2        ; $t2 = table index
FFFFFFFFFFFC10B5.8 FFFFF0350 		ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFFFFFFFFFC10BA.0 2FC015E60 
FFFFFFFFFFFC10BE.8 000000050 		jmp		OSECALL					  ; goto operating system calldispatcher
FFFFFFFFFFFC10C3.0 F00000051 
FFFFFFFFFFFC10C7.8 00008DC78 
                        	.isIRQ:
FFFFFFFFFFFC10CC.0 0010C030F 	  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
FFFFFFFFFFFC10D0.8 000F0C308 	  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
FFFFFFFFFFFC10D5.0 02020C502 	  asl   $t2,$t0,#2        ; $t2 = table index
FFFFFFFFFFFC10D9.8 FFFFF0350 		ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFFFFFFFFFC10DE.0 2FC015E60 
FFFFFFFFFFFC10E2.8 00D08030F 		csrrw	$t0,#$342,$x0			; get cause code
                        	
FFFFFFFFFFFC10E7.0 000000250 	  ldt   $t1,IRQFlag     ; update IRQ flag for Tiny Basic
FFFFFFFFFFFC10EB.8 209000460 
FFFFFFFFFFFC10F0.0 000110404 	  add   $t1,$t1,#1
FFFFFFFFFFFC10F4.8 000000250 	  stt   $t1,IRQFlag
FFFFFFFFFFFC10F9.0 210401070 
FFFFFFFFFFFC10FD.8 00FF0C308 	  and   $t0,$t0,#$FF
FFFFFFFFFFFC1102.0 000000250 	  stt   $t0,IRQCause    ; update cause code for Tiny Basic
FFFFFFFFFFFC1106.8 210301870 
R2 operation needs two source operands. (3016)
R2 operation needs two source operandsFFFFFFFFFFFC110B.0 0A007DF02 	  sub.  $t1,$t0,#1
FFFFFFFFFFFC110F.8 007FC104E 	  beq   $cr0,.softwareIrq
R2 operation needs two source operands. (3019)
R2 operation needs two source operandsFFFFFFFFFFFC1114.0 0A007DF02 	  sub.  $t1,$t1,#1
FFFFFFFFFFFC1118.8 007FC0E4E 	  beq   $cr0,.timerIrq
R2 operation needs two source operands. (3022)
R2 operation needs two source operandsFFFFFFFFFFFC111D.0 0A007DF02 	  sub.  $t1,$t1,#1      ; garbage collect interrupt?
FFFFFFFFFFFC1121.8 007FC2E4E 	  beq   $cr0,.gcIrq
FFFFFFFFFFFC1126.0 001F0C708 		and		$t4,$t0,#31			; interrupting device # is low order 5 bits of cause code
FFFFFFFFFFFC112A.8 000500604 		ldi   $t3,#5          ; try 5 times
                        	.devAgain:
FFFFFFFFFFFC112F.0 02001C802 		mov   $t5,$t4
FFFFFFFFFFFC1133.8 020720802 		asl		$t5,$t5,#7				; 128 bytes per device func table
FFFFFFFFFFFC1138.0 205820804 		add		$t5,$t5,#DVF_Base+22*4	; load IRQ routine vector from device func table
FFFFFFFFFFFC113C.8 300020860 		ldo.	$t5,[$t5]
FFFFFFFFFFFC1141.0 007FC034E 		beq	  $cr0,.noIRQ	    ; make sure there's an address to go to
FFFFFFFFFFFC1145.8 020023202 		mov   $cn,$t5
FFFFFFFFFFFC114A.0 0000C8078 		jmp		[$cn]						; jump to the IRQ routine
                        	.noIRQ:
R2 operation needs two source operands. (3048)
R2 operation needs two source operandsFFFFFFFFFFFC114E.8 0A007DF02 	  sub.  $t3,$t3,#1
FFFFFFFFFFFC1153.0 007FC024F 	  bne   $cr0,.InitDev
                        	.softwareIrq:
                        	.timerIrq:
FFFFFFFFFFFC1157.8 FE08FA878 	  jmp   ERETx2
                        		; The device function tables may have been zeroed out, try initializing them.
                        		; The following uses $a0-$a1, $t0-$t2
                        	.InitDev:
FFFFFFFFFFFC115C.0 000000700 		seq   $t4,#5
	bf    .notSerial
FFFFFFFFFFFC1160.8 000501404 		ldi		$a0,#5							; serial device
FFFFFFFFFFFC1165.0 000000050 		ldi		$a1,#SerialFuncTbl
FFFFFFFFFFFC1169.8 F00000051 
FFFFFFFFFFFC116E.0 023F01504 
FFFFFFFFFFFC1172.8 000000050 		jal	  CopyDevFuncTbl
FFFFFFFFFFFC1177.0 F00000051 
FFFFFFFFFFFC117B.8 000090178 
FFFFFFFFFFFC1180.0 000501404 		ldi		$a0,#5							; serial device
FFFFFFFFFFFC1184.8 000000050 		ldi   $a1,#SerialDCB
FFFFFFFFFFFC1189.0 F00000051 
FFFFFFFFFFFC118D.8 024101504 
FFFFFFFFFFFC1192.0 000000050 		jal   CopyDevDCB
FFFFFFFFFFFC1196.8 F00000051 
FFFFFFFFFFFC119B.0 000090978 
FFFFFFFFFFFC119F.8 FE0897878 		jmp   .devAgain
                        	.notSerial:
FFFFFFFFFFFC11A4.0 000F01404 		ldi		$a0,#15							; VIA device
FFFFFFFFFFFC11A8.8 000050700 		seq   $t4,$a0
	bf    .notVia
FFFFFFFFFFFC11AD.0 000000050 		ldi		$a1,#ViaFuncTbl
FFFFFFFFFFFC11B1.8 F00000051 
FFFFFFFFFFFC11B6.0 024401504 
FFFFFFFFFFFC11BA.8 000000050 		jal	  CopyDevFuncTbl
FFFFFFFFFFFC11BF.0 F00000051 
FFFFFFFFFFFC11C3.8 000090178 
FFFFFFFFFFFC11C8.0 000F01404 		ldi		$a0,#15							; VIA device
FFFFFFFFFFFC11CC.8 000000050 		ldi		$a1,#ViaDCB
FFFFFFFFFFFC11D1.0 F00000051 
FFFFFFFFFFFC11D5.8 024501504 
FFFFFFFFFFFC11DA.0 000000050 		jal	  CopyDevDCB
FFFFFFFFFFFC11DE.8 F00000051 
FFFFFFFFFFFC11E3.0 000090978 
FFFFFFFFFFFC11E7.8 FE0897878 		jmp   .devAgain
                        	.notVia:
FFFFFFFFFFFC11EC.0 FE08FA878 	  jmp   ERETx2
                        	.gcIrq:
                        	;	ldi		$sp,#$7F800-4		; setup interrupt mode stack pointer
FFFFFFFFFFFC11F0.8 01F79987C 	  call gcIncrement
                        	ERETx2:
                        	;  mDI
                        	;  csrrc $x0,#$7C0,#31   ; select machine regs only
                        	;  csrrw $t0,#$7C0,$x0   ; get register sets
                        	;  srl   $t0,$t0,#5      ; extract register set selection
                        	;  sll   $t0,$t0,#3
                        	;  ldt   $t1,MEPC0[$t0]  ; get it
                        	;  csrrw $x0,#$341,$t1   ; set mepc
                        	  
FFFFFFFFFFFC11F5.0 00100400F 	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFFFFFFFFFC11F9.8 00000003F 	nop
FFFFFFFFFFFC11FE.0 00000003F 	  nop
FFFFFFFFFFFC1202.8 0010C030F 	  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
FFFFFFFFFFFC1207.0 000F0C308 	  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
FFFFFFFFFFFC120B.8 02020C502 	  asl   $t2,$t0,#2        ; $t2 = table index
FFFFFFFFFFFC1210.0 FFFFF0350 		ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFFFFFFFFFC1214.8 2FC015E60 
FFFFFFFFFFFC1219.0 000000045 		rte

                        		; In case the pipeline runs ahead into the following table which will
                        		; result in illegal instructions.
FFFFFFFFFFFC121D.8 00000003F 		nop
FFFFFFFFFFFC1222.0 00000003F 		nop
FFFFFFFFFFFC1226.8 00000003F 	  nop
                        	
                        	  ; align cache
                        	DBGRout:
FFFFFFFFFFFC122B.0 00000000D 	  rex   #3,x0
  rte
	nop
FFFFFFFFFFFC122F.8 00000003F 
FFFFFFFFFFFC1234.0 00000003F 		nop
FFFFFFFFFFFC1238.8 00000003F 	  nop
                        	
                        	
                        		rodata
                        		align 8
                        	__rodata_start:
                        		rodata
                        		align	2
                        	; Application startup record for system
                        	SystemASR:
FFFFFFFFFFFC4000.0 00                                	  db    0     ; page size (can't change on this system)
FFFFFFFFFFFC4001.0 20                                	  db    2     ; priority normal
FFFFFFFFFFFC4002.0 C0                                	  db    12    ; register set for startup task
FFFFFFFFFFFC4003.0 00                                	  db    0     ; memory map #0
FFFFFFFFFFFC4004.0 00 00 00 00 00 00 00 00           	  dw    0     ; processor affinity
FFFFFFFFFFFC400C.0 00 00 00 00 00 00 00 00           	  dw    0     ; code size (0 = in ROM, don't move)
FFFFFFFFFFFC4014.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC401C.0 00 00 00 00 00 00 00 00           	  dw    0     ; data size (preinitialized data)
FFFFFFFFFFFC4024.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC402C.0 00 00 00 00 00 00 00 00           	  dw    0     ; uninitialized data size
FFFFFFFFFFFC4034.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC403C.0 00 00 00 00 00 00 00 00           	  dw    0     ; Heap size
FFFFFFFFFFFC4044.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC404C.0 00 40 00 00 00 00 00 00           	  dw    1024  ; stack size
FFFFFFFFFFFC4054.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC405C.0 EF A0 8F FF FF FF FF FF           	  dw    IdleTask  ; pointer to code
FFFFFFFFFFFC4064.0 00 00 00 00 00 00 00 00           	  dw    0       ; reserved
FFFFFFFFFFFC406C.0 00 00 00 00 00 00 00 00           	  dw    0     ; pointer to data
FFFFFFFFFFFC4074.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC407C.0 00 00 00 00 00 00 00 00           	  dw    0     ; ui data
FFFFFFFFFFFC4084.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
                        	
                        	; Application startup record for Tiny Basic
                        	TinyBasicASR:
FFFFFFFFFFFC408C.0 00                                	  db    0     ; page size (can't change on this system)
FFFFFFFFFFFC408D.0 20                                	  db    2     ; priority normal
FFFFFFFFFFFC408E.0 00                                	  db    0     ; register set
FFFFFFFFFFFC408F.0 10                                	  db    1     ; memory map
FFFFFFFFFFFC4090.0 00 00 00 00 00 00 00 00           	  dw    0     ; processor affinity
FFFFFFFFFFFC4098.0 00 00 00 00 00 00 00 00           	  dw    0     ; code size (0 = in ROM, don't move)
FFFFFFFFFFFC40A0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40A8.0 00 00 00 00 00 00 00 00           	  dw    0     ; data size (preinitialized data)
FFFFFFFFFFFC40B0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40B8.0 00 08 00 00 00 00 00 00           	  dw    32768 ; uninitialized data size
FFFFFFFFFFFC40C0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40C8.0 00 00 00 00 00 00 00 00           	  dw    0     ; Heap size
FFFFFFFFFFFC40D0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40D8.0 00 80 00 00 00 00 00 00           	  dw    2048  ; stack size
FFFFFFFFFFFC40E0.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC40E8.0 3F 10 00 00 00 00 00 08           	  dw    CSTART  ; pointer to code
FFFFFFFFFFFC40F0.0 00 00 00 00 00 00 00 00           	  dw    0       ; reserved
FFFFFFFFFFFC40F8.0 00 00 00 00 00 00 00 00           	  dw    0     ; pointer to data
FFFFFFFFFFFC4100.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
FFFFFFFFFFFC4108.0 00 00 00 00 00 00 00 00           	  dw    0     ; ui data
FFFFFFFFFFFC4110.0 00 00 00 00 00 00 00 00           	  dw    0     ; reserved
                        	    
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFFFFFFFFFC4118.0 64 56 D6 47 96 B6 96 02 35 97     			db		"Femtiki System Starting.",10
FFFFFFFFFFFC4122.0 37 47 56 D6 02 35 47 16 27 47  
FFFFFFFFFFFC412C.0 96 E6 76 E2 A0  
                        	msgMonHelp:
FFFFFFFFFFFC4131.0 D4 F6 E6 96 47 F6 27 02 34 F6     			db		"Monitor Commands",10
FFFFFFFFFFFC413B.0 D6 D6 16 E6 46 37 A0  
FFFFFFFFFFFC4142.0 24 02 D2 02 37 47 16 27 47 02     			db		"B - start tiny basic",10
FFFFFFFFFFFC414C.0 47 96 E6 97 02 26 16 37 96 36  
FFFFFFFFFFFC4156.0 A0  
FFFFFFFFFFFC4157.0 44 02 D2 02 46 57 D6 07 02 27     			db		"D - dump ready que",10
FFFFFFFFFFFC4161.0 56 16 46 97 02 17 57 56 A0  
FFFFFFFFFFFC416A.0 54 02 D2 02 56 46 96 47 02 D6     			db		"E - edit memory",10
FFFFFFFFFFFC4174.0 56 D6 F6 27 97 A0  
FFFFFFFFFFFC417A.0 64 02 D2 02 66 96 C6 C6 02 D6     			db		"F - fill memory",10
FFFFFFFFFFFC4184.0 56 D6 F6 27 97 A0  
FFFFFFFFFFFC418A.0 64 94 02 C3 37 47 27 96 E6 76     			db    "FI <string>- find string in memory",10
FFFFFFFFFFFC4194.0 E3 D2 02 66 96 E6 46 02 37 47  
FFFFFFFFFFFC419E.0 27 96 E6 76 02 96 E6 02 D6 56  
FFFFFFFFFFFC41A8.0 D6 F6 27 97 A0  
FFFFFFFFFFFC41AD.0 B4 02 C3 47 96 46 E3 02 D2 02     			db		"K <tid> - kill task", 10
FFFFFFFFFFFC41B7.0 B6 96 C6 C6 02 47 16 37 B6 A0  
FFFFFFFFFFFC41C1.0 D4 02 C3 37 47 16 27 47 E3 02     			db		"M <start> <length>	- dump memory",10
FFFFFFFFFFFC41CB.0 C3 C6 56 E6 76 47 86 E3 90 D2  
FFFFFFFFFFFC41D5.0 02 46 57 D6 07 02 D6 56 D6 F6  
FFFFFFFFFFFC41DF.0 27 97 A0  
FFFFFFFFFFFC41E2.0 05 02 D2 02 46 96 37 07 C6 16     			db    "P - display PAM",10
FFFFFFFFFFFC41EC.0 97 02 05 14 D4 A0  
FFFFFFFFFFFC41F2.0 35 02 D2 02 37 77 96 47 36 86     			db		"S - switch task",10
FFFFFFFFFFFC41FC.0 02 47 16 37 B6 A0  
FFFFFFFFFFFC4202.0 65 02 C3 D6 96 46 E3 02 46 57     			db    "V <mid> dump virtual memory map",10
FFFFFFFFFFFC420C.0 D6 07 02 67 96 27 47 57 16 C6  
FFFFFFFFFFFC4216.0 02 D6 56 D6 F6 27 97 02 D6 16  
FFFFFFFFFFFC4220.0 07 A0  
FFFFFFFFFFFC4222.0 00                                			db		0
                        			; align cache
                        	msgTaskStart:
FFFFFFFFFFFC4223.0 02 47 16 37 B6 02 37 47 16 27     			db		" task started."
FFFFFFFFFFFC422D.0 47 56 46 E2  
                        	msgCRLF:
FFFFFFFFFFFC4231.0 D0 A0 00                          			db		13,10,0
                        	flt50:
FFFFFFFFFFFC4234.0 00 00 00 00 00 00 00 00 00 00     		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFFFFFFFFFC423E.0 00 00 00 00 00 00 00 00 00 00  
FFFFFFFFFFFC4248.0 00 00 00 00 00 09 40 04 00 00  
FFFFFFFFFFFC4252.0 00 00  
                        	flt20:
FFFFFFFFFFFC4254.0 00 00 00 00 00 00 00 00 00 00     		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFFFFFFFFFC425E.0 00 00 00 00 00 00 00 00 00 00  
FFFFFFFFFFFC4268.0 00 00 00 00 00 04 30 04 00 00  
FFFFFFFFFFFC4272.0 00 00  
                        	flt10:
FFFFFFFFFFFC4274.0 00 00 00 00 00 00 00 00 00 00     		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFFFFFFFFFC427E.0 00 00 00 00 00 00 00 00 00 00  
FFFFFFFFFFFC4288.0 00 00 00 00 00 04 20 04 00 00  
FFFFFFFFFFFC4292.0 00 00  
                        	
                        	;.include "fltToString.r64"
                        	;.include "bios-mem.r64"
                        	;.include "bios-pam.r64"
                        	;.include "bios-tlb.r64"
                        	;.include "ramtest.r64"
                        	
                        	;.include "../fmtk/msg.r64"
                        	;.include "../fmtk/tcb.r64"
                        	;.include "../fmtk/task.r64"
                        	;.include "../fmtk/io.r64"
                        	;.include "../fmtk/iofocus.r64"
                        	;.include "../fmtk/serial.r64"
                        	;.include "../fmtk/source/drivers/pti_driver.r64"
                        	;.include "../fmtk/app.r64"
                        	;.include "../fmtk/Finalizer.r64"
                        	;.include "../fmtk/gcIncremental.r64"
                        	;.include "../fmtk/source/kernel/fmtk.r64"
                        	;.include "../fmtk/source/kernel/FMTKc.r64"
                        	;.include "../fmtk/source/kernel/SetupDevices.r64"
                        	;.include "../fmtk/source/kernel/pic.r64"
                        	;.include "../fmtk/source/kernel/DBGConsole.r64"
                        	;.include "../fmtk/source/fmtk.l64"
                        	;.include "../fmtk/finalizer.r64"
                        	;.include "../fmtk/gcIncremental.r64"
                        	;.include "TinyBasic.r64"
                        	;.include "../cc64libc/source/rtf64/io.r64"
                        	;.include "../cc64libc/source/cc64libc.l64"
                        	;.include "../c_standard_lib-master/c_standard_lib-master/c_standard_lib.l64"
                        	.file "any1_rom.r64",1
                        	
                        		rodata
FFFFFFFFFFFC4294.0 00 00 00 00                       		align 8
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8
                        	end_init_data:
                        	_end_init_data:

rodata start: FFFFFFFFFFF88000
data start:                0
bss start:                0

592 symbols
  Symbol Name                              seg     address bits references
  CR                                        const  000006.1 0 5
  CSR_MEPC                                  const  001824.0 0 15
  CSR_MSEMA                                 const  001860.1 0 15
  CSR_PMSTACK                               const  001820.0 0 15
  CSR_REGSET                                const  002809.0 0 16
  CSR_RSSTACK                               const  001821.1 0 15
  CSR_TASKID                                const  000808.0 0 14
  CSR_TRACECTRL                             const  003850.0 0 16
  CSTART                                     code  c0000000000000f9.1 0 32
  CURIN                                     const  0001b8.0 0 11
  CUROUT                                    const  0001b8.1 0 11
  CheckDevOwner                              code  c0000000000000ec.0 0 32
  CopyDevDCB                                 code  c000000000000121.0 0 32
  CopyDevFuncTbl                             code  c000000000000120.0 0 32
  DBGATTR                                   const  1fffff060df8000.0 0 59
  DBGRout                                    code  fffffffffffc122b.0 0 18
  DVF_Base                                  const  001000.0 0 15
  DumpReadyQueue                             code  c0000000000000d9.0 0 32
  DumpTimeoutList                            code  c0000000000000fa.1 0 32
  DumpTraceQueue                             code  fffffffffffc0f91.1 0 18
  DumpTraceQueue.dmpTrace                    code  fffffffffffc0f96.0 0 18
  DumpTraceQueue.dmpTraceEmpty               code  fffffffffffc0fbe.1 0 18
  DumpTraceQueue.inf                         code  fffffffffffc0fc7.1 0 18
  EOF                                       const  00000d.0 0 6
  ERETx2                                     code  fffffffffffc11f5.0 0 18
  E_Ok                                      const  000000.0 0 1
  FillMem                                    code  fffffffffffc0d06.1 0 18
  FillMem.0001                               code  fffffffffffc0d26.0 0 18
  Finalizer                                  code  c0000000000000d5.1 0 32
  Find                                       code  fffffffffffc0d3c.1 0 18
  Find.found                                 code  fffffffffffc0dcc.1 0 18
  Find.fwe                                   code  fffffffffffc0d57.1 0 18
  Find.loop                                  code  fffffffffffc0d80.0 0 18
  Find.next                                  code  fffffffffffc0da8.1 0 18
  Find.notFound                              code  fffffffffffc0ddd.0 0 18
  GetDecNum.next                             code  fffffffffffc0e7f.0 0 18
  GetHexNum                                  code  fffffffffffc0e0a.0 0 18
  GetHexNum.next                             code  fffffffffffc0e13.0 0 18
  GetUIFlag                                  code  c0000000000000ea.0 0 32
  Getch                                      code  fffffffffffc069f.1 0 18
  INBUF                                     const  000080.0 0 10
  IRQCause                                  const  00084c.0 0 14
  IRQFlag                                   const  000848.0 0 14
  IRQRout                                    code  fffffffffffc1060.0 0 18
  IRQRout.InitDev                            code  fffffffffffc115c.0 0 18
  IRQRout.devAgain                           code  fffffffffffc112f.0 0 18
  IRQRout.gcIrq                              code  fffffffffffc11f0.1 0 18
  IRQRout.isIRQ                              code  fffffffffffc10cc.0 0 18
  IRQRout.noIRQ                              code  fffffffffffc114e.1 0 18
  IRQRout.soc                                code  fffffffffffc10a3.1 0 18
  IRQRout.softwareIrq                        code  fffffffffffc1157.1 0 18
  IRQRout.timerIrq                           code  fffffffffffc1157.1 0 18
  IdleTask                                   code  fffffffffffc057f.0 0 18
  IdleTask.IdleCode                          code  fffffffffffc05eb.0 0 18
  IdleTask.loop                              code  fffffffffffc059e.1 0 18
  IdleTask.loop2                             code  fffffffffffc0595.1 0 18
  IdleTask.nxtObj                            code  fffffffffffc0633.0 0 18
  IdleTaskMbx                               const  000608.0 0 13
  IdleTaskMsgD1                             const  00060c.0 0 13
  IdleTaskMsgD2                             const  000610.0 0 13
  IdleTaskMsgD3                             const  000614.0 0 13
  LEDS                                      const  ffffffffffc88000.0 0 24
  LNFD                                      const  000005.0 0 5
  LOG_PGSZ                                  const  000006.0 0 5
  LOG_TCBSZ                                 const  000005.0 0 5
  MBX_BLOCKPTR_BUFSZ                        const  000004.0 0 5
  MEMSZ                                     const  010000.0 0 19
  MEPC1                                     const  0001ac.0 0 11
  MMUInit                                    code  c0000000000000d0.1 0 32
  MachineStart                               code  fffffffffffc0300.0 0 18
  MachineStart.0001                          code  fffffffffffc0367.1 0 18
  MbxBlockPtr                               const  000850.0 0 14
  Monitor                                    code  fffffffffffc0966.1 0 18
  Monitor.0001                               code  fffffffffffc0972.1 0 18
  Monitor.0005                               code  fffffffffffc0b61.1 0 18
  Monitor.basSize                            code  fffffffffffc0a6a.0 0 18
  Monitor.skip                               code  fffffffffffc0a10.0 0 18
  OBJMagic                                  const  000000.0 0 1
  OSECALL                                    code  c00000000000011b.1 0 32
  OSExit                                     code  c0000000000000dd.1 0 32
  OSOCall                                    code  c0000000000000d3.0 0 32
  PAGESZ                                    const  000800.0 0 14
  PutHexByte                                 code  fffffffffffc0ed4.1 0 18
  PutHexNybble                               code  fffffffffffc0ee2.0 0 18
  PutHexOcta                                 code  fffffffffffc0eac.0 0 18
  PutHexTetra                                code  fffffffffffc0eb9.1 0 18
  PutHexWyde                                 code  fffffffffffc0ec7.0 0 18
  PutInlineString                            code  fffffffffffc0f1c.1 0 18
  PutInlineString.0001                       code  fffffffffffc0f33.0 0 18
  PutInlineString.done                       code  fffffffffffc0f49.1 0 18
  PutString.0001                             code  fffffffffffc0f69.0 0 18
  PutString.done                             code  fffffffffffc0f7f.1 0 18
  Putch                                      code  fffffffffffc06c3.1 0 18
  ROMBASE                                   const  fffffffffffe0000.0 0 20
  SCRATCHMEM                                const  ffffffffffa00000.0 0 25
  SerialDCB                                  code  c000000000000120.1 0 32
  SerialFuncTbl                              code  c00000000000011f.1 0 32
  SerialPutChar                              code  c0000000000000e9.0 0 32
  SkipSpaces                                 code  fffffffffffc0df3.1 0 18
  SkipSpaces.skip2                           code  fffffffffffc0df3.1 0 18
  StackTbl                                   code  fffffffffffc0fe0.0 0 18
  SystemASR                                rodata  fffffffffffc4000.0 0 32
  TBASR                                      code  c0000000000000f7.1 0 32
  TCBPriority                               const  000170.1 0 11
  TCBStatus                                 const  000170.0 0 11
  TCB_MAGIC                                 const  102a21a1.0 0 31
  TS_READY                                  const  000000.1 0 2
  TinyBasicASR                             rodata  fffffffffffc408c.0 0 32
  UserStart                                  code  fffffffffffc047a.0 0 18
  UserStart2                                 code  fffffffffffc0483.0 0 18
  UserStart2.appBad                          code  fffffffffffc0495.0 0 18
  ViaDCB                                     code  c000000000000122.1 0 32
  ViaFuncTbl                                 code  c000000000000122.0 0 32
  WaitForIOFocus                             code  c0000000000000eb.0 0 32
  _DBGAttr                                  const  ffffffffffa00000.0 0 25
  _Delay2s                                   code  fffffffffffc0680.0 0 18
  _Delay2s.0001                              code  fffffffffffc0684.1 0 18
  _FMTKInit                                  code  c0000000000000d1.0 0 32
  _InitPIC                                   code  c0000000000000d1.1 0 32
  _cursorX                                  const  ffffffffffa00004.0 0 25
  _cursorY                                  const  ffffffffffa00004.1 0 25
  _pti_init                                  code  c0000000000000cf.1 0 32
  _pti_read_block                            code  c0000000000000d0.0 0 32
  calcScreenPos                              code  fffffffffffc06f5.0 0 18
  calcScreenPos.0001                         code  fffffffffffc072b.0 0 18
  calcScreenPos.0002                         code  fffffffffffc0702.1 0 18
  calcScreenPos.0003                         code  fffffffffffc073d.0 0 18
  calcScreenPos.0004                         code  fffffffffffc0714.1 0 18
  dbg_HomeCursor                             code  fffffffffffc0854.0 0 18
  dbg_Putch                                  code  fffffffffffc07a0.0 0 18
  dbg_Putch.cr                               code  fffffffffffc07f5.1 0 18
  dbg_Putch.lf                               code  fffffffffffc07cd.0 0 18
  dbg_ScrollUp                               code  fffffffffffc0803.0 0 18
  dbg_ScrollUp.0001                          code  fffffffffffc0810.1 0 18
  fgetc                                      code  fffffffffffc08e8.1 0 18
  fgetc.0001                                 code  fffffffffffc092c.0 0 18
  fgetc.0002                                 code  fffffffffffc0942.1 0 18
  fgetc.checkOwner                           code  fffffffffffc0915.1 0 18
  fgetc.notOwner                             code  fffffffffffc0954.1 0 18
  fputc                                      code  fffffffffffc086a.1 0 18
  fputc.0001                                 code  fffffffffffc08b7.0 0 18
  fputc.checkOwner                           code  fffffffffffc08a5.0 0 18
  fputc.notOwner                             code  fffffffffffc08df.1 0 18
  fputc.xit                                  code  fffffffffffc08cd.1 0 18
  gcIncrement                                code  c000000000000123.1 0 32
  incScreenPos                               code  fffffffffffc074f.0 0 18
  incScreenPos.0001                          code  fffffffffffc0792.1 0 18
  incScreenPos.0002                          code  fffffffffffc0785.0 0 18
  msgCRLF                                  rodata  fffffffffffc4231.0 0 32
  msgMonHelp                               rodata  fffffffffffc4131.0 0 32
  msgTaskStart                             rodata  fffffffffffc4223.0 0 32
  x0                                         code  c000000000000124.0 0 32

Undefined Symbols
  CSTART                                     code  80000000000001f3 32 2
  CheckDevOwner                              code  80000000000001d8 32 2
  CopyDevDCB                                 code  8000000000000242 32 2
  CopyDevFuncTbl                             code  8000000000000240 32 2
  DumpReadyQueue                             code  80000000000001b2 32 3
  DumpTimeoutList                            code  80000000000001f5 32 1
  Finalizer                                  code  80000000000001ab 32 1
  GetUIFlag                                  code  80000000000001d4 32 2
  MMUInit                                    code  80000000000001a1 32 1
  OSECALL                                    code  8000000000000237 32 1
  OSExit                                     code  80000000000001bb 32 2
  OSOCall                                    code  80000000000001a6 32 1
  SerialDCB                                  code  8000000000000241 32 1
  SerialFuncTbl                              code  800000000000023f 32 1
  SerialPutChar                              code  80000000000001d2 32 1
  TBASR                                      code  80000000000001ef 32 1
  ViaDCB                                     code  8000000000000245 32 1
  ViaFuncTbl                                 code  8000000000000244 32 1
  WaitForIOFocus                             code  80000000000001d6 32 2
  _FMTKInit                                  code  80000000000001a2 32 1
  _InitPIC                                   code  80000000000001a3 32 1
  _pti_init                                  code  800000000000019f 32 1
  _pti_read_block                            code  80000000000001a0 32 1
  gcIncrement                                code  8000000000000247 32 1
  x0                                         code  8000000000000248 32 1

  Macro Name
0 compressable instructions
The top 1024 are:
Comp  Opcode  Count

Instruction Statistics
Loads:         0 (0.000000%)
Stores:        0 (0.000000%)
  Indexed:     0 (0.000000%)
Pushes:        0 (0.000000%)
Compares:      3 (0.362319%)
Branches:     33 (3.985507%)
BEQZ/NEZ:	     0 (0.000000%)
  BEQI:		     0 (0.000000%)
  BNEI:		     0 (0.000000%)
  BBc:		     0 (0.000000%)
  BLcc:		     0 (0.000000%)
Calls:		   154 (18.599034%)
Returns:	    24 (2.898551%)
Adds:	       202 (24.396135%)
Subs:	         0 (0.000000%)
Ands:	         9 (1.086957%)
Ors:	         2 (0.241546%)
Xors:	         0 (0.000000%)
Bits:	         0 (0.000000%)
Tsts:	         0 (0.000000%)
Lshifts:       0 (0.000000%)
shifts:	       0 (0.000000%)
Luis:	         0 (0.000000%)
Moves:	       0 (0.000000%)
CMoves:	       0 (0.000000%)
Sets:	        18 (2.173913%)
  Mops:        0 (0.000000%)
Ptrdif:        0 (0.000000%)
Bitfield:      0 (0.000000%)
Csr:		      25 (3.019324%)
Floatops:      0 (0.000000%)
others:      386 (46.618357%)
Total:       828

number of bytes: 3726.000000
number of instructions: 828
number of compressed instructions: 0
4.500000 bytes (36 bits) per instruction
Compression ratio: 0.000000%
Number of long branches: 0
