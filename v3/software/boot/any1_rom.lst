                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/const.r64",1
                        	.file "../fmtk/const.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_UNDEAD   EQU   64
                        	TS_RUNNING	EQU		128
                        	
                        	AS_NONE     EQU   0
                        	AS_LIVE     EQU   1
                        	AS_DEAD     EQU   2
                        	AS_UNDEAD   EQU   4
                        	
                        	PRI_NORMAL  EQU   2
                        	PRI_LOW     EQU   3
                        	
                        	OST_WHITE   EQU   0
                        	OST_GREY    EQU   1
                        	OST_BLACK   EQU   2
                        	OST_UNDEAD  EQU   64    ; no longer alive, but not dead yet (finalizer hasn't been called)
                        	OST_DEAD    EQU   128   ; completely dead, finalizer called already
                        	
                        	TCB_MAGIC     EQU   ((' ' << 24) | ('T' << 16) | ('C' << 8) | 'B')
ACB_MAGIC     EQU   ((' ' << 24) | ('A' << 16) | ('C' << 8) | 'B')
MSG_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('S' << 8) | 'G')
MBX_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('B' << 8) | 'X')

                        	UNDEADQ     EQU   7
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_Func  =   0x02
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadDCBOffset = 0x1A
                        	E_Busy = 0x1B
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	E_BadTcbPointer = 0x27
                        	E_BadTid = 0x28
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	= 0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMoreAppIds = 0x46
                        	E_NoMem = 0x47
                        	
                        	CSR_TRACECTRL = $70A0
                        	CSR_PTA     = $1003
                        	CSR_TASKID  = $1010
                        	CSR_ASID    = $101F
                        	CSR_MSTATUS = $3000
                        	CSR_RSSTACK = $3043
                        	CSR_PMSTACK = $3040
                        	CSR_MEPC    = $3048
                        	CSR_MSEMA   = $30C1
                        	
                        	CSR_REGSET  = $5012
                        	CSR_DBAD0   = $5018
                        	CSR_DBAD1   = $5019
                        	CSR_DBAD2   = $501A
                        	CSR_DBAD3   = $501B
                        	CSR_DBCR    = $501C
                        	CSR_DBSR    = $501D
                        	
                        	TCBPTR_MASK = $FFF803FF
                        	
                        	; Message types
                        	MT_ANNOUNCE = $00000010
                        	MT_IRQ      = $FFFFFFFF
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/types.r64",1
                        	.file "../fmtk/types.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	OBJMagic    EQU   0
                        	OBJSize     EQU   8
                        	OBJTypenum  EQU   16
                        	OBJID       EQU   20
                        	OBJState    EQU   24    ; WHITE, GREY, BLACK
                        	OBJScavcnt  EQU   25    ; scavange count
                        	OBJOwningMap  EQU   26
                        	OBJPad1       EQU   27
                        	OBJCollectionIndex  EQU   28
                        	OBJUsedInMap  EQU   32    ; used in map
                        	OBJPad3       EQU   36
                        	OBJFWAddr     EQU   40    ; forwarding address
                        	OBJFinalizer  EQU   48
                        	OBJ_SIZE      EQU   64
                        	
                        	; Task Control Block
                        	TCBObject   EQU   $000    ; Object structure, state
                        	TCBIntRegs  EQU   $040    ; integer register set storage area (room for 64-bit)
                        	TCBxCR      EQU   $040
                        	TCBxRA      EQU   $048
                        	TCBxSP      EQU   $050
                        	TCBxGP      EQU   $058
                        	TCBxTP      EQU   $060
                        	TCBxT0      EQU   $068
                        	TCBxT1      EQU   $070
                        	TCBxT2      EQU   $078
                        	TCBxFP      EQU   $080
                        	TCBxS1      EQU   $088
                        	TCBxA0      EQU   $090
                        	TCBxA1      EQU   $098
                        	TCBxA2      EQU   $0A0
                        	TCBxA3      EQU   $0A8
                        	TCBxA4      EQU   $0B0
                        	TCBxA5      EQU   $0B8
                        	TCBxA6      EQU   $0C0
                        	TCBxA7      EQU   $0C8
                        	TCBxS2      EQU   $0D0
                        	TCBxS3      EQU   $0D8
                        	TCBxS4      EQU   $0E0
                        	TCBxS5      EQU   $0E8
                        	TCBxS6      EQU   $0F0
                        	TCBxS7      EQU   $0F8
                        	TCBxS8      EQU   $100
                        	TCBxS9      EQU   $108
                        	TCBxS10     EQU   $110
                        	TCBxS11     EQU   $118
                        	TCBxT3      EQU   $120
                        	TCBxT4      EQU   $128
                        	TCBxT5      EQU   $130
                        	TCBxT6      EQU   $138
                        	TCBxRA0     EQU   $140
                        	TCBxRA1     EQU   $148
                        	TCBxCN      EQU   $150
                        	TCBFltRegs  EQU   $158    ; float register set storage area
                        	TCBRegsEnd  EQU   $258
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBbases  	EQU		$258		; base register storage
                        	TCBepc  		EQU		$2D8
                        	TCBStatus		EQU		$2E0
                        	TCBPriority	EQU		$2E1
                        	TCBWaitMbx	EQU		$2E2
                        	TCBRegset   EQU   $2E3
                        	TCBHasFocus EQU   $2E4
                        	TCBStackBot	EQU		$2E8
                        	TCBMsgD1		EQU		$2F0
                        	TCBMsgD2		EQU		$2F8
                        	TCBMsgD3		EQU		$300
                        	TCBStartTick	EQU	$308
                        	TCBEndTick	EQU		$310
                        	TCBTicks		EQU		$318
                        	TCBException	EQU	$320
                        	TCBNext			EQU		$328
                        	TCBPrev			EQU		$330
                        	TCBTimeout	EQU		$338
                        	TCBtid      EQU   $340
                        	TCBmid      EQU   $342
                        	TCBappid    EQU   $344
                        	TCBOpMode   EQU   $346
                        	TCBMbxNext  EQU   $348
                        	TCBMbxPrev  EQU   $350
                        	TCBTaskNum  EQU   $358
                        	TCBName			EQU		$360
                        	
                        	; Application Control Block
                        	ACBObject     EQU   0
                        	ACBpData      EQU   64
                        	ACBDataSize   EQU   72
                        	ACBpUIData    EQU   80
                        	ACBUIDataSize EQU   88
                        	ACBGCRoots    EQU   96
                        	ACBGCRootCnt  EQU   104
                        	ACBGCNdx      EQU   112
                        	ACBGCMarkingQue EQU   120
                        	ACBGCMarkingQueFull   EQU   128
                        	ACBGCMarkingQueEmpty  EQU   129
                        	ACBGCOverflow EQU   130
                        	ACBpCode      EQU   134
                        	ACBObjectList EQU   144
                        	ACBGarbageList  EQU   152
                        	ACBHeap       EQU   160   ; 640+ bytes for heap object info
                        	ACBiofNext    EQU   824
                        	ACBiofPrev    EQU   832
                        	ACBUserName   EQU   840   ; 2 byte index of string in string area
                        	ACBPath       EQU   842   ; 2 byte index of string in string area
                        	ACBExitRunFile  EQU   844 ; 2 byte index of string in string area
                        	ACBCommandLine  EQU   846 ; 2 byte index of string in string area
                        	ACBpVidMem    EQU   848
                        	ACBpVirtVidMem  EQU 856
                        	ACBVideoRows  EQU   864
                        	ACBVideoCols  EQU   865
                        	ACBCursorRow  EQU   866
                        	ACBCursorCol  EQU   867
                        	ACBNormAttr   EQU   868
                        	ACBKeyState1  EQU   872
                        	ACBKeyState2  EQU   874
                        	ACBKeybdWaitFlag  EQU   876
                        	ACBKeybdHead  EQU   878
                        	ACBKeybdTail  EQU   879
                        	ACBKeybdBuffer  EQU   880
                        	ACBnumber     EQU   944
                        	ACBNext       EQU   952
                        	ACBTask       EQU   960
                        	ACBHasFocus   EQU   962
                        	ACBmid        EQU   964
                        	ACBStatus     EQU   966
                        	ACBTemplates  EQU   968   ; 256 * 8 bytes reserved for template pointers
                        	ACBPad        EQU   3016
                        	ACBStrings    EQU   3072  ; start of 1kB string area
                        	ACBEnd        EQU   4096
                        	
                        	; Application startup record
                        	ASRPageSize   EQU   0
                        	ASRPriority   EQU   1
                        	ASRRegset     EQU   2
                        	ASRmid        EQU   3
                        	ASRAffinity   EQU   4
                        	ASRCodeSize   EQU   8
                        	ASRDataSize   EQU   16
                        	ASRUIDataSize EQU   24
                        	ASRHeapSize   EQU   32
                        	ASRStackSize  EQU   40
                        	ASRpCode      EQU   48
                        	ASRpData      EQU   56
                        	ASRpUIData    EQU   64
                        	ASR_SIZE      EQU   72
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	;MBX_WTIDS			equ		4		; tasks waiting at mailbox
                        	MBX_LINK      equ   8
                        	MBX_TQHEAD    equ   8   ; link field for free list shared with task queue head
                        	MBX_TQTAIL    equ   16
                        	MBX_MQHEAD		equ		24		
                        	MBX_MQTAIL		equ		32
                        	MBX_SIZE			equ		40
                        	
                        	MSG_LINK	  equ		0
                        	MSG_RETADR  equ   8
                        	MSG_TGTADR  equ   10
                        	MSG_TYPE    equ   12
                        	MSG_D1		  equ		16
                        	MSG_D2		  equ		24
                        	MSG_D3		  equ		32
                        	MSG_SIZE	  equ		40
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/config.r64",1
                        	.file "../fmtk/config.r64",1
                        	MAX_TID		EQU		15
                        	NR_TCB		EQU		32
                        	NTASK     EQU   32      ; number of tasks allowed
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		12
                        	LOG_ACBSZ EQU   12
                        	OSPAGES		EQU		8		    ; pages of memory dedicated to OS
                        	MAXVPG    EQU   32767   ; maximum virtual page number
                        	PAGESZ    EQU   4096    ; size of a page of memory
                        	MEMSZ     EQU   131072  ; 4096B pages
                        	MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/device.r64",1
                        	.file "../fmtk/device.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2021  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_fUI       EQU   0x3A    ; user interface device
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x60
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	DVC_IsUI          EQU   27
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Front Panel 		FP
                        	;11
                        	;12		Hard disk				HD1
                        	;13		Hard disk				HD2
                        	;14
                        	;15   Time slice / GP	VIA
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/macro.r64",1
                        	.file "../fmtk/macro.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; disable interrupts
                        	macro mDI
  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
endm
                        	
                        	; disable interrupts
                        	macro mEI
  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
endm
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		$a0,#-1
	sto		$a0,adr
endm
                        	
                        	macro mGetCurrentTid
  csrrw $a0,#CSR_TASKID,$x0
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	brk   #240
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#tm
	brk   #240
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   a1 = device # to check
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
  mov   $t2,$a1
	
	ldi		$a0,#20
	brk   #240
tst   $a1
	bne 	.HasFocus@
	ldi   $a0,#26             ; FMTK_IO
	mov   $a1,$t2
	ldi   $a2,#9              ; peekchar function
	brk   #240
	sne		$a0,#$14						; CTRL-T
	bt		.WFF2@
	; eat up the CTRL-T
	ldi		$a0,#26							; FMTK_IO
	mov   $a1,$t2
	ldi		$a2,#8							; getchar function
	brk   #240
	ldi		$a0,#21							; switch IO Focus
	brk   #240
	jmp		.WFF1@
.WFF2@:
	
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#1
	brk   #240

	jmp		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = mailbox handle
                        	; Modifies:
                        	;   $t0
                        	; Returns:
                        	;   $a0 = mailbox pointer
                        	;------------------------------------------------------------------------------
                        	
                        	macro mMbxHandleToPointer
  lsr   $t0,$a0,#8    ; extract collection index
  asl   $t0,$t0,#2
  ldt   $t0,MbxBlockPtr[$t0]
  and   $a0,$a0,#$FF
  asl   $a0,$a0,#2
  or    $a0,$a0,$t0
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list pointer to TCB
                        	;------------------------------------------------------------------------------
                        	
                        	;macro mPopTimeoutList
                        	;	lbu		$v1,TCBStatus[$v0]		; no longer a waiting status
                        	;	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
                        	;	beqz	$t1,.noWait@
                        	;	ldbu  $a0,TCBtid[$v0]
                        	;	mMbxRemoveTask							; remove task from mailbox list
                        	.noWait@:
                        	;	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
                        	;	stb		$v1,TCBStatus[$v0]
                        	;	ldt		$v1,TCBNext[$v0]			; get next task on timeout list
                        	;	stt		$v1,TimeoutList				; update list head
                        	;	beqz	$v1,.done@
                        	;	stt		$x0,TCBPrev[$v1]			; TimeoutList->prev = 0
                        	.done@:
                        	;	stt		$x0,TCBNext[$v0]
                        	;	stt		$x0,TCBPrev[$v0]
                        	endm
                        	
                        	macro mGetAppMid
  asl   $a0,$a0,#LOG_PGSZ
  ldb   $a0,ACBmid[$a0]
endm
                        	
                        	; Macros to enable and disable time-slice interrupts
                        	macro mTimeSliceEI
	ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
	stt		$t0,VIA_IER+VIA
endm
                        	
                        	macro mTimeSliceDI
	ldi		$t0,#$100						; disable timer3 (time slice) interrupts
	stt		$t0,VIA_IER+VIA
	nop                   ; make sure disable has time for effect
	nop
endm
                        	
                        	; Inserting into the ready queue is done by both OS ecall functions and
                        	; interrupt driven scheduling. It's important to have interrupts disabled
                        	; so that there is no contention for the ready queue.
                        	
                        	macro mInsertIntoReadyQueue
	asl   $t0,$a0,#LOG_TCBSZ
	ldbu	$t1,TCBStatus[$t0]	; set status to ready
	or		$t1,$t1,#TS_READY
	stb		$t1,TCBStatus[$t0]
	ldb		$t1,TCBPriority[$t0]
	pushq	$a0,$t1
endm
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	.file "../fmtk/globals.r64",1
                        	.file "../fmtk/globals.r64",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	INBUF				equ		$0100
                        	switchflag	equ		$0200
                        	milliseconds	equ		$0208
                        	CurrentTid  equ   $210
                        	TaskNum     equ   $220
                        	__xhandler_head equ $228
                        	
                        	ACBPtrs EQU $0280
                        	APPID_POOL  EQU   $02F0
                        	NPAGES	equ		$0300
                        	QNDX		EQU		$0304
                        	READYQ	EQU		$0308
                        	TID_POOL  EQU		$0310
                        	missed_ticks	equ		$0320
                        	TimeoutList		equ		$0328
                        	Tick		EQU		$0330
                        	SysSema	EQU		$0340
                        	MEPC0   EQU   $0350
                        	MEPC1   EQU   $0358
                        	MEPC2   EQU   $0360
                        	MEPC3   EQU   $0368
                        	CURIN   EQU   $0370
                        	CUROUT  EQU   $0371
                        	CHAINA0 EQU   $0378
                        	CHAINA1 EQU   $0380
                        	CHAINA2 EQU   $0388
                        	CHAINA3 EQU   $0390
                        	CHAINA4 EQU   $0398
                        	CHAINA5 EQU   $03A0
                        	READYQ  EQU   $0400
                        	RDYQ0		EQU		$0400
                        	RDYQ1		EQU		$0500
                        	RDYQ2		EQU		$0600
                        	RDYQ3		EQU		$0700
                        	mbxs		EQU		$0800
                        	mbxs_end	EQU	$0C00
                        	FreeMsg	EQU		$0C00
                        	FreeMbx EQU   $0C08
                        	IdleTaskMbx EQU   $0C10
                        	IdleTaskMsgD1 EQU   $0C18
                        	IdleTaskMsgD2 EQU   $0C20
                        	IdleTaskMsgD3 EQU   $0C28
                        	IdleTaskId    EQU   $0C2A
                        	PAMPtr  EQU   $0FF8
                        	IOFocusNdx		EQU		$1080
                        	IOFocusTbl		EQU		$1088
                        	IRQFlag   EQU $1090
                        	IRQCause  EQU $1098
                        	MbxBlockPtr EQU   $10A0
                        	MbxBlockPtrEnd  EQU MbxBlockPtr + MBX_BLOCKPTR_BUFSZ * 4
                        	MbxBlockCounter EQU $10E0
                        	RegsetTid   EQU   $10F0
                        	SerRcvBuf		EQU		$1400
                        	SerXmitBuf	EQU		$1800
                        	SerHeadRcv	EQU		$1C00
                        	SerTailRcv	EQU		$1C04
                        	SerHeadXmit	EQU		$1C08
                        	SerTailXmit	EQU		$1C0C
                        	SerRcvXon		EQU		$1C10
                        	SerRcvXoff	EQU		$1C11
                        	; The following must be at least 128 byte aligned
                        	DVF_Base		EQU		$2000
                        	DVF_Limit		EQU		$3000
                        	DCB_Base    EQU   $3000
                        	DCB_Limit   EQU   $3C00
                        	PAM     EQU   $4000
                        	_PAM     EQU   $4000
                        	_PAMend  EQU   $C000
                        	
                        	SysHeapStart  EQU   $5000
                        	SysHeapEnd    EQU   $20000
                        	
                        	
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	
                        	;TEST  equ   1
                        	
                        	CTRLC				equ		$03
                        	CTRLT       equ   $14
                        	BS					equ		$08
                        	LNFD  			equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	EOF         equ   $1A
                        	DEL					equ		$7F
                        	VIA					equ		$FFFFFFFFFF910000
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_T2CL    equ   $20
                        	VIA_T2CH    equ   $24
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFFFFFFFFF930000
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        	
                        	CSR_UIE     equ   $004
                        	ROMBASE		equ		$FFFFFFFFFFFC0000
                        	IOBASE		equ		$FFFFFFFFFF800000
                        	TEXTSCR		equ		$FFFFFFFFFF800000
                        	KEYBD		equ		$FFFFFFFFFF8E0000
                        	LEDS		equ			$FFFFFFFFFF910000
                        	xbLEDS		equ			$FFFFFFFFFBDC0600
                        	xbBridge1 equ   $FFFFFFFFFFDCF010
                        	BUTTONS		equ		$FFFFFFFFFF910000
                        	SCRATCHPAD	equ		$FFFFFFFFFF400000
                        	SCRATCHMEM	equ		$FFFFFFFFFF400000
                        	_DBGAttr  equ   SCRATCHMEM
                        	;DBGATTR   equ   $0000FFFF000F0000   ; white on blue, priority $40
                        	DBGATTR   equ   %000000_111111111111111111111_000001100000110111111_0000000000000000
                        	_cursorX  equ   _DBGAttr + 8
                        	_cursorY  equ   _cursorX + 1
                        	
                        	
                        	.file "any1_rom.r64",49
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        	{+
                        		org		ROMBASE				; user mode exception
FFFFFFFFFFFC0000.0 0008B8041 		jmp		DBGRout
FFFFFFFFFFFC0004.8 000000000 		org 	ROMBASE+$C0				; machine mode exception
FFFFFFFFFFFC0009.0 000000000 
FFFFFFFFFFFC000D.8 000000000 
FFFFFFFFFFFC0012.0 000000000 
FFFFFFFFFFFC0016.8 000000000 
FFFFFFFFFFFC001B.0 000000000 
FFFFFFFFFFFC001F.8 000000000 
FFFFFFFFFFFC0024.0 000000000 
FFFFFFFFFFFC0028.8 000000000 
FFFFFFFFFFFC002D.0 000000000 
FFFFFFFFFFFC0031.8 000000000 
FFFFFFFFFFFC0036.0 000000000 
FFFFFFFFFFFC003A.8 000000000 
FFFFFFFFFFFC003F.0 000000000 
FFFFFFFFFFFC0043.8 000000000 
FFFFFFFFFFFC0048.0 000000000 
FFFFFFFFFFFC004C.8 000000000 
FFFFFFFFFFFC0051.0 000000000 
FFFFFFFFFFFC0055.8 000000000 
FFFFFFFFFFFC005A.0 000000000 
FFFFFFFFFFFC005E.8 000000000 
FFFFFFFFFFFC0063.0 000000000 
FFFFFFFFFFFC0067.8 000000000 
FFFFFFFFFFFC006C.0 000000000 
FFFFFFFFFFFC0070.8 000000000 
FFFFFFFFFFFC0075.0 000000000 
FFFFFFFFFFFC0079.8 000000000 
FFFFFFFFFFFC007E.0 000000000 
FFFFFFFFFFFC0082.8 000000000 
FFFFFFFFFFFC0087.0 000000000 
FFFFFFFFFFFC008B.8 000000000 
FFFFFFFFFFFC0090.0 000000000 
FFFFFFFFFFFC0094.8 000000000 
FFFFFFFFFFFC0099.0 000000000 
FFFFFFFFFFFC009D.8 000000000 
FFFFFFFFFFFC00A2.0 000000000 
FFFFFFFFFFFC00A6.8 000000000 
FFFFFFFFFFFC00AB.0 000000000 
FFFFFFFFFFFC00AF.8 000000000 
FFFFFFFFFFFC00B4.0 000000000 
FFFFFFFFFFFC00B8.8 000000000 
FFFFFFFFFFFC00BD.0 041000000 
FFFFFFFFFFFC00C0.0 000858041 		jmp		DBGRout
FFFFFFFFFFFC00C4.8 000000000 		org		ROMBASE+$F2			; non-maskable interrupt
FFFFFFFFFFFC00C9.0 000000000 
FFFFFFFFFFFC00CD.8 000000000 
FFFFFFFFFFFC00D2.0 000000000 
FFFFFFFFFFFC00D6.8 000000000 
FFFFFFFFFFFC00DB.0 000000000 
FFFFFFFFFFFC00DF.8 000000000 
FFFFFFFFFFFC00E4.0 000000000 
FFFFFFFFFFFC00E8.8 000000000 
FFFFFFFFFFFC00ED.0 000000000 
FFFFFFFFFFFC00F1.8 001070410 
FFFFFFFFFFFC00F2.0 000107041 		bra		MachineStart    ; cannot use a jump here, takes too much room
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC00F6.8 000000000 		org		ROMBASE+$100
FFFFFFFFFFFC00FB.0 000000000 
FFFFFFFFFFFC00FF.8 007600410 
FFFFFFFFFFFC0100.0 000760041 		jmp		IRQRout
FFFFFFFFFFFC0104.8 000000000 		org 	ROMBASE+$1C0		; machine mode exception
FFFFFFFFFFFC0109.0 000000000 
FFFFFFFFFFFC010D.8 000000000 
FFFFFFFFFFFC0112.0 000000000 
FFFFFFFFFFFC0116.8 000000000 
FFFFFFFFFFFC011B.0 000000000 
FFFFFFFFFFFC011F.8 000000000 
FFFFFFFFFFFC0124.0 000000000 
FFFFFFFFFFFC0128.8 000000000 
FFFFFFFFFFFC012D.0 000000000 
FFFFFFFFFFFC0131.8 000000000 
FFFFFFFFFFFC0136.0 000000000 
FFFFFFFFFFFC013A.8 000000000 
FFFFFFFFFFFC013F.0 000000000 
FFFFFFFFFFFC0143.8 000000000 
FFFFFFFFFFFC0148.0 000000000 
FFFFFFFFFFFC014C.8 000000000 
FFFFFFFFFFFC0151.0 000000000 
FFFFFFFFFFFC0155.8 000000000 
FFFFFFFFFFFC015A.0 000000000 
FFFFFFFFFFFC015E.8 000000000 
FFFFFFFFFFFC0163.0 000000000 
FFFFFFFFFFFC0167.8 000000000 
FFFFFFFFFFFC016C.0 000000000 
FFFFFFFFFFFC0170.8 000000000 
FFFFFFFFFFFC0175.0 000000000 
FFFFFFFFFFFC0179.8 000000000 
FFFFFFFFFFFC017E.0 000000000 
FFFFFFFFFFFC0182.8 000000000 
FFFFFFFFFFFC0187.0 000000000 
FFFFFFFFFFFC018B.8 000000000 
FFFFFFFFFFFC0190.0 000000000 
FFFFFFFFFFFC0194.8 000000000 
FFFFFFFFFFFC0199.0 000000000 
FFFFFFFFFFFC019D.8 000000000 
FFFFFFFFFFFC01A2.0 000000000 
FFFFFFFFFFFC01A6.8 000000000 
FFFFFFFFFFFC01AB.0 000000000 
FFFFFFFFFFFC01AF.8 000000000 
FFFFFFFFFFFC01B4.0 000000000 
FFFFFFFFFFFC01B8.8 000000000 
FFFFFFFFFFFC01BD.0 041000000 
FFFFFFFFFFFC01C0.0 000700041 		jmp		IRQRout
FFFFFFFFFFFC01C4.8 000000000 		org		ROMBASE+$1F2		; non-maskable interrupt
FFFFFFFFFFFC01C9.0 000000000 
FFFFFFFFFFFC01CD.8 000000000 
FFFFFFFFFFFC01D2.0 000000000 
FFFFFFFFFFFC01D6.8 000000000 
FFFFFFFFFFFC01DB.0 000000000 
FFFFFFFFFFFC01DF.8 000000000 
FFFFFFFFFFFC01E4.0 000000000 
FFFFFFFFFFFC01E8.8 000000000 
FFFFFFFFFFFC01ED.0 000000000 
FFFFFFFFFFFC01F1.8 000870410 
FFFFFFFFFFFC01F2.0 000087041 		bra		MachineStart    ; cannot use a jump here, takes too much room
                        	
FFFFFFFFFFFC01F6.8 000000000 		org		ROMBASE+$200
FFFFFFFFFFFC01FB.0 000000000 
FFFFFFFFFFFC01FF.8 006E00410 
FFFFFFFFFFFC0200.0 0006E0041 		jmp		IRQRout
FFFFFFFFFFFC0204.8 000000000 		org 	ROMBASE+$2C0		; machine mode exception
FFFFFFFFFFFC0209.0 000000000 
FFFFFFFFFFFC020D.8 000000000 
FFFFFFFFFFFC0212.0 000000000 
FFFFFFFFFFFC0216.8 000000000 
FFFFFFFFFFFC021B.0 000000000 
FFFFFFFFFFFC021F.8 000000000 
FFFFFFFFFFFC0224.0 000000000 
FFFFFFFFFFFC0228.8 000000000 
FFFFFFFFFFFC022D.0 000000000 
FFFFFFFFFFFC0231.8 000000000 
FFFFFFFFFFFC0236.0 000000000 
FFFFFFFFFFFC023A.8 000000000 
FFFFFFFFFFFC023F.0 000000000 
FFFFFFFFFFFC0243.8 000000000 
FFFFFFFFFFFC0248.0 000000000 
FFFFFFFFFFFC024C.8 000000000 
FFFFFFFFFFFC0251.0 000000000 
FFFFFFFFFFFC0255.8 000000000 
FFFFFFFFFFFC025A.0 000000000 
FFFFFFFFFFFC025E.8 000000000 
FFFFFFFFFFFC0263.0 000000000 
FFFFFFFFFFFC0267.8 000000000 
FFFFFFFFFFFC026C.0 000000000 
FFFFFFFFFFFC0270.8 000000000 
FFFFFFFFFFFC0275.0 000000000 
FFFFFFFFFFFC0279.8 000000000 
FFFFFFFFFFFC027E.0 000000000 
FFFFFFFFFFFC0282.8 000000000 
FFFFFFFFFFFC0287.0 000000000 
FFFFFFFFFFFC028B.8 000000000 
FFFFFFFFFFFC0290.0 000000000 
FFFFFFFFFFFC0294.8 000000000 
FFFFFFFFFFFC0299.0 000000000 
FFFFFFFFFFFC029D.8 000000000 
FFFFFFFFFFFC02A2.0 000000000 
FFFFFFFFFFFC02A6.8 000000000 
FFFFFFFFFFFC02AB.0 000000000 
FFFFFFFFFFFC02AF.8 000000000 
FFFFFFFFFFFC02B4.0 000000000 
FFFFFFFFFFFC02B8.8 000000000 
FFFFFFFFFFFC02BD.0 041000000 
FFFFFFFFFFFC02C0.0 000680041 		jmp		IRQRout
FFFFFFFFFFFC02C4.8 000000000 		org		ROMBASE+$2F2		; non-maskable interrupt
FFFFFFFFFFFC02C9.0 000000000 
FFFFFFFFFFFC02CD.8 000000000 
FFFFFFFFFFFC02D2.0 000000000 
FFFFFFFFFFFC02D6.8 000000000 
FFFFFFFFFFFC02DB.0 000000000 
FFFFFFFFFFFC02DF.8 000000000 
FFFFFFFFFFFC02E4.0 000000000 
FFFFFFFFFFFC02E8.8 000000000 
FFFFFFFFFFFC02ED.0 000000000 
FFFFFFFFFFFC02F1.8 000070410 
FFFFFFFFFFFC02F2.0 000007041 		bra		MachineStart    ; cannot use a jump here, takes too much room
                        	
                        	;------------------------------------------------------------------------------
                        	; Reset starting address.
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC02F6.8 000000000 		org		ROMBASE+$300
FFFFFFFFFFFC02FB.0 000000000 
FFFFFFFFFFFC02FF.8 0AA003040 
                        	MachineStart:
                        	;  ldi   $t1,#$81
                        	;  sto   $t1,xbBridge1
FFFFFFFFFFFC0300.0 00AA00304 	  ldi   $t0,#$AA
FFFFFFFFFFFC0304.8 FFFF22050 	  stb   $t0,LEDS
FFFFFFFFFFFC0309.0 000300070 
FFFFFFFFFFFC030D.8 00AA01404 	  ldi   $a0,#$AA
FFFFFFFFFFFC0312.0 FFFF22050 	  stb   $a0,LEDS
FFFFFFFFFFFC0316.8 001400070 
                        	
FFFFFFFFFFFC031B.0 FFFE81950 		ldi		$sp,#SCRATCHMEM+$CDF8		  ; setup machine mode stack pointer
FFFFFFFFFFFC031F.8 CDF801E04 
FFFFFFFFFFFC0324.0 FFF879E04 		sub 	$sp,$sp,#8
FFFFFFFFFFFC0328.8 000A01404 		ldi   $a0,#10
FFFFFFFFFFFC032D.0 000001504 		ldi   $a1,#0
FFFFFFFFFFFC0331.8 000187541 		call  _Delay2s
FFFFFFFFFFFC0336.0 00026CD41 		call  dbg_HomeCursor
FFFFFFFFFFFC033A.8 C1837E050 		ldi		$a1,#DBGATTR		  ; set zorder $40, white text, blue background
FFFFFFFFFFFC033F.0 007FFFF51 
FFFFFFFFFFFC0343.8 000001504 
FFFFFFFFFFFC0348.0 FFFE80050 		sto		$a1,_DBGAttr
FFFFFFFFFFFC034C.8 301500070 
                        	  ; clear debug screen
FFFFFFFFFFFC0351.0 FFFE80050 	  ldo   $a0,_DBGAttr
FFFFFFFFFFFC0355.8 300001460 
FFFFFFFFFFFC035A.0 FFFF00050 	  ldi   $t0,#TEXTSCR
FFFFFFFFFFFC035E.8 000000304 
                        	ifdef TEST
                        	  ldi   $t1,#6
                        	else
FFFFFFFFFFFC0363.0 065800404 	  ldi   $t1,#56*29
                        	endif
                        	.0001:
FFFFFFFFFFFC0367.8 FFFF10404 	  sub   $t1,$t1,#1
FFFFFFFFFFFC036C.0 000010058 	  sto   $a0,[$t0+$t1*8]
FFFFFFFFFFFC0370.8 36140C071 
FFFFFFFFFFFC0375.0 FF8013D4F 	  bne   $t1,$x0,.0001
FFFFFFFFFFFC0379.8 C1837E050 		ldi		$a1,#DBGATTR|$41
FFFFFFFFFFFC037E.0 007FFFF51 
FFFFFFFFFFFC0382.8 004101504 
FFFFFFFFFFFC0387.0 FFFF00050 		sto		$a1,TEXTSCR
FFFFFFFFFFFC038B.8 301500070 
FFFFFFFFFFFC0390.0 FFFF00050 		sto		$a1,TEXTSCR+8
FFFFFFFFFFFC0394.8 301500870 
FFFFFFFFFFFC0399.0 FFFF00050 		sto		$a1,TEXTSCR+16
FFFFFFFFFFFC039D.8 301501070 
FFFFFFFFFFFC03A2.0 FFFF00050 		sto		$a1,TEXTSCR+24
FFFFFFFFFFFC03A6.8 301501870 
                        	
                        	;  ldi   $a0,#msgStart
                        	  ;call  PutHexTetra
FFFFFFFFFFFC03AB.0 FFFFF0450 	  ldi   $a0,#msgStart
FFFFFFFFFFFC03AF.8 241401404 
FFFFFFFFFFFC03B4.0 0005A4541 	  call  PutString
                        	
                        	;  call  _ramtest2
                        	;	csrrs $x0,#CSR_TRACECTRL,#1 ; turn on tracing
FFFFFFFFFFFC03B8.8 01FE8B541 	  call  _pti_init
FFFFFFFFFFFC03BD.0 000010050 	  ldi   $a1,#$80000
FFFFFFFFFFFC03C1.8 000001504 
FFFFFFFFFFFC03C6.0 000040050 	  ldi   $a0,#$200000
FFFFFFFFFFFC03CA.8 000001404 
FFFFFFFFFFFC03CF.0 01FE80541 	  call  _pti_read_block
                        	
FFFFFFFFFFFC03D3.8 01FE7E541 		call  MMUInit					; initialize MMU for address space zero.
FFFFFFFFFFFC03D8.0 01FE7C541 		call  _FMTKInit
                        		;call  ViaSetup
                        	;	call  _SerialInit
FFFFFFFFFFFC03DC.8 01FE7A541 		call  _InitPIC
FFFFFFFFFFFC03E1.0 000500304 		ldi   $t0,#5          ; set current input and output to serial port
FFFFFFFFFFFC03E5.8 068303070 		stb   $t0,CURIN
FFFFFFFFFFFC03EA.0 068303170 		stb   $t0,CUROUT
FFFFFFFFFFFC03EE.8 000000304 		ldi		$t0,#0
FFFFFFFFFFFC03F3.0 00304C00F 		csrrw $x0,#CSR_MSEMA,$t0  ; turn off semaphores
FFFFFFFFFFFC03F7.8 00604C00F 		csrrw	$x0,#$181,$t0		    ; set ASID
FFFFFFFFFFFC03FC.0 00040C00F 		csrrw $x0,#CSR_TASKID,$t0 ; clear task id
FFFFFFFFFFFC0400.8 FFFFF8050 		ldi		$t0,#$FFFFFFFFFFFC0000
FFFFFFFFFFFC0405.0 000000304 
FFFFFFFFFFFC0409.8 100D4C00F 		csrrw $x0,#$5035,$t0		; set tvec for debug mode
FFFFFFFFFFFC040E.0 FFFFF8050 		ldi		$t0,#$FFFFFFFFFFFC0100
FFFFFFFFFFFC0412.8 010000304 
FFFFFFFFFFFC0417.0 100D0C00F 		csrrw $x0,#$5034,$t0		; set tvec for interrupt mode
FFFFFFFFFFFC041B.8 FFFFF8050 		ldi		$t0,#$FFFFFFFFFFFC0200
FFFFFFFFFFFC0420.0 020000304 
FFFFFFFFFFFC0424.8 100CCC00F 		csrrw $x0,#$5033,$t0		; set tvec for machine mode
FFFFFFFFFFFC0429.0 FC1F00304 		ldi   $t0,#$FFFFFFFFFFFFFC1F  ; run user mode in register set #0
FFFFFFFFFFFC042D.8 0010CC00F 		csrrw $x0,#CSR_RSSTACK,$t0
FFFFFFFFFFFC0432.0 FFFFF0150 		ldi		$t0,#UserStart
FFFFFFFFFFFC0436.8 08F400304 
FFFFFFFFFFFC043B.0 10120C00F 		csrrw	$x0,#$5048,$t0	  ; set mepc
FFFFFFFFFFFC043F.8 268301870 		stt   $t0,MEPC1
FFFFFFFFFFFC0444.0 000101404 	  ldi   $a0,#1            ; start task
FFFFFFFFFFFC0448.8 000001504 	  ldi   $a1,#0
FFFFFFFFFFFC044D.0 000001604 	  ldi   $a2,#0
FFFFFFFFFFFC0451.8 FFFFF0150 	  ldi   $a3,#UserStart2
FFFFFFFFFFFC0456.0 090601704 
FFFFFFFFFFFC045A.8 000001804 	  ldi   $a4,#$00
FFFFFFFFFFFC045F.0 01FE39D41 	  call  OSOCall
FFFFFFFFFFFC0463.8 00045400F 	  csrrw $x0,#CSR_TASKID,$a1
FFFFFFFFFFFC0468.0 001000204 	  csrrs $x0,#CSR_PMSTACK,#16 ; enable interrupts on return
FFFFFFFFFFFC046C.8 00100800F 
FFFFFFFFFFFC0471.0 10280000F 		csrrc $x0,#CSR_TRACECTRL,#0 ; turn off tracing
FFFFFFFFFFFC0475.8 000000045 		rte                       ; switch to user mode
;------------------------------------------------------------------------------
                        	; User mode code staret here
                        	; First thing to do is start a task so that the startup code may run on the
                        	; first task switch.
                        	;------------------------------------------------------------------------------
                        	  align 	code
UserStart:
FFFFFFFFFFFC047A.0 00055E941 	  call  DumpTraceQueue
FFFFFFFFFFFC047E.8 24000007A 	  wai                   ; wait for task switch
                        	UserStart2:
FFFFFFFFFFFC0483.0 000C01404 	  ldi   $a0,#12         ; start app
FFFFFFFFFFFC0487.8 FFFFF0450 	  ldi   $a1,#SystemASR
FFFFFFFFFFFC048C.0 230401504 
FFFFFFFFFFFC0490.8 000210000 	  brk   #240
.appBad:
FFFFFFFFFFFC0495.0 16005300C 	  tst   $cr0,$a0
FFFFFFFFFFFC0499.8 00000008F 
FFFFFFFFFFFC049E.0 FFFFC3E4F 	  bne   $cr0,.appBad
FFFFFFFFFFFC04A2.8 000054B34 	  mov   $s1,$a1
FFFFFFFFFFFC04A7.0 000E01404 	  ldi   $a0,#14         ; get current tid
FFFFFFFFFFFC04AB.8 000210000 	  brk   #240            ; $a1 = task id
  ldi   $a0,#30         ; set task's app id
FFFFFFFFFFFC04B0.0 001E01404 
FFFFFFFFFFFC04B4.8 00002D634 	  mov   $a2,$s1         ; $a2 = app id
FFFFFFFFFFFC04B9.0 000210000 	  brk   #240

FFFFFFFFFFFC04BD.8 000054B34 	  mov   $s1,$a1         ; s1 = app id
FFFFFFFFFFFC04C2.0 01400FF50 		ldi		$sp,#$A0080000-4  ; setup user mode stack pointer
FFFFFFFFFFFC04C6.8 FFFC01E04 
                        	
FFFFFFFFFFFC04CB.0 000C01404 	  ldi   $a0,#12         ; start app
FFFFFFFFFFFC04CF.8 FFFFF0450 	  ldi   $a1,#TinyBasicASR
FFFFFFFFFFFC04D4.0 238C01504 
FFFFFFFFFFFC04D8.8 000210000 	  brk   #240
	ldi		$a0,#1          ; Start finalizer task, task #1
FFFFFFFFFFFC04DD.0 000101404 
FFFFFFFFFFFC04E1.8 00002D534 		mov   $a1,$s1
FFFFFFFFFFFC04E6.0 000001604 		ldi		$a2,#0
FFFFFFFFFFFC04EA.8 000000050 		ldi		$a3,#Finalizer
FFFFFFFFFFFC04EF.0 F00000051 
FFFFFFFFFFFC04F3.8 01AA01704 
FFFFFFFFFFFC04F8.0 000B01804 		ldi   $a4,#$0B        ; user mode, regset 11
FFFFFFFFFFFC04FC.8 000210000 		brk   #240
	ldi		$a0,#1          ; Start task for monitor, task #2
FFFFFFFFFFFC0501.0 000101404 
FFFFFFFFFFFC0505.8 00002D534 		mov   $a1,$s1
FFFFFFFFFFFC050A.0 000001604 		ldi		$a2,#0
FFFFFFFFFFFC050E.8 FFFFF0250 		ldi		$a3,#MonEntry
FFFFFFFFFFFC0513.0 123201704 
FFFFFFFFFFFC0517.8 000A01804 		ldi   $a4,#$0A        ; user mode, regset 10
FFFFFFFFFFFC051C.0 000210000 		brk   #240
  ldi   $a0,#25         ; map OS vars
FFFFFFFFFFFC0520.8 001901404 
FFFFFFFFFFFC0525.0 000210000 	  brk   #240
  mov   $gp,$a1
FFFFFFFFFFFC0529.8 000055C34 
                        	
                        	UserStart3:
FFFFFFFFFFFC052E.0 01400FF50 		ldi		$sp,#$A0080000-4  ; setup user mode stack pointer
FFFFFFFFFFFC0532.8 FFFC01E04 
FFFFFFFFFFFC0537.0 001801404 		ldi		$a0,#24							; RequestIOFocus
FFFFFFFFFFFC053B.8 00002D534 		mov   $a1,$s1
FFFFFFFFFFFC0540.0 000210000 		brk   #240
;	ldi		$sp,#$70000		      ; setup temporary user mode stack pointer
                        	;	mov   $a0,$a1             ; $a0 = tid
                        	;	call AllocStack
                        	;	add   $sp,$v1,#1020       ; place stack pointer at top of allocated region
FFFFFFFFFFFC0544.8 000800304 		ldi		$t0,#$08						; turn on the LED
FFFFFFFFFFFC0549.0 FFFF22050 		stt		$t0,VIA+VIA_PARAW
FFFFFFFFFFFC054D.8 200303C70 
FFFFFFFFFFFC0552.0 001000504 		ldi		$t2,#16							; send an XON just in case
FFFFFFFFFFFC0556.8 001101704 		ldi		$a3,#XON
                        	.0004:
FFFFFFFFFFFC055B.0 000096941 		call  Putch ;SerialPutChar
R2 operation needs two source operands. (1306)
R2 operation needs two source operandsFFFFFFFFFFFC055F.8 0A007DF02 		sub.	$t2,$t2,#1
FFFFFFFFFFFC0564.0 FFFFC3E4F 		bne	  $cr0,.0004
                        	.0002:
                        	;  ldi   $a0,#25             ; Map OS vars
                        	;  brk #240
                        	;  mov   $gp,$a1
                        	  ; Request that the idle task announce itself.
                        	;  ldi   $a0,#9              ; SendMsg
                        	;  ldwu  $a1,IdleTaskMbx[$gp]
                        	;  beqz  $a1,.noMbx
                        	;  ldi   $a2,#MT_ANNOUNCE
                        	;  ldi   $a3,#0
                        	;  ldi   $a4,#0
                        	;  brk #240
                        	.noMbx:
FFFFFFFFFFFC0568.8 FFFFF0450 		ldi		$a0,#msgStart				; spit out a startup message
FFFFFFFFFFFC056D.0 241401404 
FFFFFFFFFFFC0571.8 0004C5941 		call  PutString
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		brk #240
FFFFFFFFFFFC0576.0 01FDB1541 		call  DumpReadyQueue
FFFFFFFFFFFC057A.8 0001CF441 		jmp		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#9							; peekchar function
                        	;	brk #240
                        	;	mov   $v0,$v1
                        	;	bltz	$v1,.0003
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#8							; getchar function
                        	;	brk #240
                        	;	mov		$a3,$v1
                        	;	mov   $a0,$a3
                        	;	call PutHexByte
                        	;	bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	; This task runs only if nothing else can run. It must run at the machine
                        	; operating mode.
                        	; Search for ready tasks and add them back into the ready queue.
                        	;------------------------------------------------------------------------------
                        	;  align 	code
                        	IdleTask:
FFFFFFFFFFFC057F.0 000601404 	  ldi   $a0,#6                ; alloc mailbox
FFFFFFFFFFFC0583.8 000001504 	  ldi   $a1,#0                ; app #0
FFFFFFFFFFFC0588.0 000210000 	  brk   #240
  stw   $a1,IdleTaskMbx[$gp]  ; save mailbox handle off
FFFFFFFFFFFC058C.8 000000150 
FFFFFFFFFFFC0591.0 181571070 
                        	.loop2:
FFFFFFFFFFFC0595.8 400000304 	  ldi   $t0,#$4000
FFFFFFFFFFFC059A.0 000100404 	  ldi   $t1,#1
                        	.loop:
FFFFFFFFFFFC059E.8 000B01404 	  ldi   $a0,#11               ; PeekMsg
FFFFFFFFFFFC05A3.0 000000150 	  ldwu  $a1,IdleTaskMbx[$gp]
FFFFFFFFFFFC05A7.8 1C1071564 
FFFFFFFFFFFC05AC.0 0C1801604 	  ldi   $a2,#IdleTaskMsgD1
FFFFFFFFFFFC05B0.8 0C2001704 	  ldi   $a3,#IdleTaskMsgD2
FFFFFFFFFFFC05B5.0 0C2801804 	  ldi   $a4,#IdleTaskMsgD3
FFFFFFFFFFFC05B9.8 000101904 	  ldi   $a5,#1                ; remove from queue if present
                        	;  brk #240
                        	;  bnez  $a0,.noMsg
                        	;  ldt   $a0,IdleTaskMsgD1
                        	;  xor   $t1,$a0,#MT_ANNOUNCE
                        	;  bnez  $t1,.noAnnounce
                        	;  ldi   $a0,#msgIdleAnnounce
                        	;  call PutString
                        	.noAnnounce:
                        	.noMsg:
FFFFFFFFFFFC05BE.0 001101404 	  ldi   $a0,#17               ; run as OS
FFFFFFFFFFFC05C2.8 FFFFF0150 	  ldi   $a1,#.IdleCode
FFFFFFFFFFFC05C7.0 0BD601504 
FFFFFFFFFFFC05CB.8 00000D634 	  mov   $a2,$t0
FFFFFFFFFFFC05D0.0 000210000 	  brk   #240
  add   $t0,$t0,#PAGESZ
FFFFFFFFFFFC05D4.8 10000C304 
FFFFFFFFFFFC05D9.0 004000050 	  sne   $t3,$t0,#MEMSZ*PAGESZ
FFFFFFFFFFFC05DD.8 00000C627 
FFFFFFFFFFFC05E2.0 FFC01B14F 	  bne   $t3,#0,.loop
FFFFFFFFFFFC05E6.8 FFFFD7841 		jmp		.loop2
                        	  ; This section of code runs as part of the OS
                        	  ; Don't callany functions though as there's no stack available
                        	.IdleCode:
FFFFFFFFFFFC05EB.0 200058360 	  ldt   $t0,OBJMagic[$a2]
FFFFFFFFFFFC05EF.8 0040A8850 	  sne   $t3,$t0,#TCB_MAGIC
FFFFFFFFFFFC05F4.0 43420C627 
FFFFFFFFFFFC05F8.8 004018D4F 	  bne   $t3,#0,.nxtObj
FFFFFFFFFFFC05FD.0 02E014664 	  ldbu  $t3,TCBStatus[$t2]    ; get status
FFFFFFFFFFFC0601.8 000118608 	  and  	$t3,$t3,#TS_READY
FFFFFFFFFFFC0606.0 004018A4F 	  bne   $t3,#0,.nxtObj
                        	  ; The task was ready, but not found in the ready queue. So add it
FFFFFFFFFFFC060A.8 040C59402 	  lsr   $a0,$a2,#LOG_PGSZ
                        	  
FFFFFFFFFFFC060F.0 00100400F 	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	
FFFFFFFFFFFC0613.8 020A50302 		asl   $t0,$a0,#LOG_TCBSZ
FFFFFFFFFFFC0618.0 02E00C464 		ldbu	$t1,TCBStatus[$t0]	; set status to ready
FFFFFFFFFFFC061C.8 000110409 		or		$t1,$t1,#TS_READY
FFFFFFFFFFFC0621.0 05840E070 		stb		$t1,TCBStatus[$t0]
FFFFFFFFFFFC0625.8 02E10C460 		ldb		$t1,TCBPriority[$t0]
FFFFFFFFFFFC062A.0 10045007A 		pushq	$a0,$t1
                        	
FFFFFFFFFFFC062E.8 00100400F 	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
                        	.nxtObj:
FFFFFFFFFFFC0633.0 000001404 	  ldi   $a0,#E_Ok
FFFFFFFFFFFC0637.8 01FD52C41 	  jmp   OSExit
                        	
                        	msgIdleAnnounce:
                        	  db  "Idle task running.",CR,0

                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	;  align 	code
FFFFFFFFFFFC063C.0 000000000 		align	64
                        	_Delay2s:
                        	ifdef TEST
                        	  ldi     $a1,#10
                        	else
FFFFFFFFFFFC0640.0 00005B850 		ldi			$a1,#3000000
FFFFFFFFFFFC0644.8 C6C001504 
                        	endif
                        	.0001:
FFFFFFFFFFFC0649.0 441055602 		srl			$a2,$a1,#16
FFFFFFFFFFFC064D.8 FFFF22050 		stb			$a2,LEDS
FFFFFFFFFFFC0652.0 001600070 
FFFFFFFFFFFC0656.8 FFFF55504 		sub 		$a1,$a1,#1
FFFFFFFFFFFC065B.0 FF9503C48 		bgt		  $a1,#0,.0001
FFFFFFFFFFFC065F.8 000004042 		ret

                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		$a0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	Getch:
FFFFFFFFFFFC0664.0 FFF079E04 		sub		$sp,$sp,#16
FFFFFFFFFFFC0668.8 301578870 		sto		$a1,8[$sp]
FFFFFFFFFFFC066D.0 000501504 		ldi   $a1,#5  ;CURIN
FFFFFFFFFFFC0671.8 000119541 		call  fgetc
FFFFFFFFFFFC0676.0 300879560 		ldo		$a1,8[$sp]
FFFFFFFFFFFC067A.8 001079E04 		add   $sp,$sp,#16
FFFFFFFFFFFC067F.0 000004042 		ret

                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = character to put
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	_putch:
FFFFFFFFFFFC0683.8 000070841 	  bra   dbg_Putch
                        	  ; align cache
                        	Putch:
FFFFFFFFFFFC0688.0 00006E441 	  bra   dbg_Putch
FFFFFFFFFFFC068C.8 FFE879E04 		sub		$sp,$sp,#24
FFFFFFFFFFFC0691.0 301778870 		sto		$a3,8[$sp]
FFFFFFFFFFFC0695.8 301579070 		sto		$a1,16[$sp]
FFFFFFFFFFFC069A.0 000051734 		mov		$a3,$a0
FFFFFFFFFFFC069E.8 000501504 		ldi		$a1,#5  ;CUROUT    ; serial port
FFFFFFFFFFFC06A3.0 0000C1941 		call	fputc
FFFFFFFFFFFC06A7.8 300879760 		ldo		$a3,8[$sp]
FFFFFFFFFFFC06AC.0 301079560 		ldo		$a1,16[$sp]
FFFFFFFFFFFC06B0.8 001879E04 		add   $sp,$sp,#24
FFFFFFFFFFFC06B5.0 000004042 		ret

                        	  ; align cache
                        	calcScreenPos:
FFFFFFFFFFFC06B9.8 FFFE80050 	  ldbu  $t0,_cursorY
FFFFFFFFFFFC06BE.0 000900364 
FFFFFFFFFFFC06C2.8 004018A4B 	  bgeu  $t3,#29,.0001
                        	.0002:
FFFFFFFFFFFC06C7.0 00380C415 	  mulf  $t1,$t0,#56
FFFFFFFFFFFC06CB.8 FFFE80050 	  ldbu  $t0,_cursorX
FFFFFFFFFFFC06D0.0 000800364 
FFFFFFFFFFFC06D4.8 00400CA4B 	  bgeu  $t0,#56,.0003
                        	.0004:
FFFFFFFFFFFC06D9.0 080310402 	  add   $t1,$t1,$t0
FFFFFFFFFFFC06DD.8 340310402 	  sll   $t1,$t1,#3
FFFFFFFFFFFC06E2.0 FFFF00050 	  add   $t2,$t1,#TEXTSCR
FFFFFFFFFFFC06E6.8 000010504 
FFFFFFFFFFFC06EB.0 000004042 	  ret
; This is cool in ANY1. Storing a smalll constant to memory does not require
                        	; the use of a source register. This allows the LDI and the STB to proceed
                        	; in parallel. The store does not need to wait for a register.
                        	.0001:
FFFFFFFFFFFC06EF.8 001C00304 	  ldi   $t0,#28
FFFFFFFFFFFC06F4.0 FFFE80050 	  stb   #28,_cursorY
FFFFFFFFFFFC06F8.8 004000970 
FFFFFFFFFFFC06FD.0 FFFFE5041 	  bra   .0002
                        	.0003:
FFFFFFFFFFFC0701.8 003700304 	  ldi   $t0,#55
FFFFFFFFFFFC0706.0 FFFE80050 	  stb   $t0,_cursorX
FFFFFFFFFFFC070A.8 000300870 
FFFFFFFFFFFC070F.0 FFFFE5041 	  bra   .0004
                        	
                        	  ; align cache
                        	incScreenPos:
FFFFFFFFFFFC0713.8 FFFE80050 	  ldbu  $t0,_cursorX
FFFFFFFFFFFC0718.0 000800364 
FFFFFFFFFFFC071C.8 00010C304 	  add   $t0,$t0,#1
FFFFFFFFFFFC0721.0 00400CC4A 	  bltu  $t0,#56,.0001
FFFFFFFFFFFC0725.8 FFFE80050 	  stb   #0,_cursorX
FFFFFFFFFFFC072A.0 004000870 
FFFFFFFFFFFC072E.8 FFFE80050 	  ldbu  $t0,_cursorY
FFFFFFFFFFFC0733.0 000900364 
FFFFFFFFFFFC0737.8 00010C304 	  add   $t0,$t0,#1
FFFFFFFFFFFC073C.0 00400C34A 	  bltu  $t0,#29,.0002
FFFFFFFFFFFC0740.8 00003F141 	  call  dbg_ScrollUp
FFFFFFFFFFFC0745.0 000004042 	  ret
.0002:
FFFFFFFFFFFC0749.8 FFFE80050 	  stb   $t0,_cursorY
FFFFFFFFFFFC074E.0 000300970 
FFFFFFFFFFFC0752.8 000004042 	  ret
.0001:
FFFFFFFFFFFC0757.0 FFFE80050 	  stb   $t0,_cursorX
FFFFFFFFFFFC075B.8 000300870 
FFFFFFFFFFFC0760.0 000004042 	  ret
  
                        	  ; align cache
                        	dbg_Putch:
FFFFFFFFFFFC0764.8 00405114E 	  beq  	$a0,#CR,.cr
FFFFFFFFFFFC0769.0 00405074E 	  beq  	$a0,#LNFD,.lf
FFFFFFFFFFFC076D.8 FFFE80050 	  ldo   $t3,_DBGAttr
FFFFFFFFFFFC0772.0 300000660 
FFFFFFFFFFFC0776.8 020650602 	  or    $t3,$a0,$t3
FFFFFFFFFFFC077B.0 FFFF9F541 	  call  calcScreenPos
FFFFFFFFFFFC077F.8 300614070 	  sto   $t3,[$t2]
FFFFFFFFFFFC0784.0 FFFFC7C41 	  bra   incScreenPos
                        	 .lf:
FFFFFFFFFFFC0788.8 FFFE80050 	  stb   #0,_cursorX
FFFFFFFFFFFC078D.0 004000870 
FFFFFFFFFFFC0791.8 FFFE80050 	  ldbu  $a0,_cursorY
FFFFFFFFFFFC0796.0 000901464 
FFFFFFFFFFFC079A.8 000151404 	  add   $a0,$a0,#1
FFFFFFFFFFFC079F.0 00405074B 	  bgeu  $a0,#29,dbg_ScrollUp
FFFFFFFFFFFC07A3.8 FFFE80050 	  stb   $a0,_cursorY
FFFFFFFFFFFC07A8.0 001400970 
FFFFFFFFFFFC07AC.8 000004042 	  ret
.cr:
FFFFFFFFFFFC07B1.0 FFFE80050 	  stb   #0,_cursorX
FFFFFFFFFFFC07B5.8 004000870 
FFFFFFFFFFFC07BA.0 000004042 	  ret

                        	  ; align cache
                        	dbg_ScrollUp:
FFFFFFFFFFFC07BE.8 FFFF00050 	  ldi   $t0,#TEXTSCR
FFFFFFFFFFFC07C3.0 000000304 
                        	ifdef TEST
                        	  ldi   $t1,#6
                        	else
FFFFFFFFFFFC07C7.8 062000404 	  ldi   $t1,#56*28
                        	endif
                        	.0001:
FFFFFFFFFFFC07CC.0 31C00C560 	  ldo   $t2,56*8[$t0]
FFFFFFFFFFFC07D0.8 FFFF10404 	  sub  	$t1,$t1,#1      ; placed here eliminates pipeline bubble
FFFFFFFFFFFC07D5.0 30050C070 	  sto   $t2,[$t0]
FFFFFFFFFFFC07D9.8 00080C304 	  add   $t0,$t0,#8
FFFFFFFFFFFC07DE.0 FFC013C4F 	  bne   $t1,#0,.0001
                        	
                        	  ; align cache
                        	dbg_BlankLastLine:
FFFFFFFFFFFC07E2.8 FFFF00050 	  ldi   $t0,#TEXTSCR+56*28
FFFFFFFFFFFC07E7.0 062000304 
FFFFFFFFFFFC07EB.8 003700404 	  ldi   $t1,#55
FFFFFFFFFFFC07F0.0 000000504 	  ldi   $t2,_DBGAttr
  or    $t2,$t2,#' '
FFFFFFFFFFFC07F4.8 002014509 
                        	.0001:
FFFFFFFFFFFC07F9.0 000010058 	  sto   $t2,[$t0+$t1*8]
FFFFFFFFFFFC07FD.8 36050C071 
FFFFFFFFFFFC0802.0 FFFF10404 	  sub  	$t1,$t1,#1
FFFFFFFFFFFC0806.8 FF8403D4A 	  bgtu  $t1,#0,.0001
FFFFFFFFFFFC080B.0 000004042 	  ret

                        	  ; align cache
                        	dbg_HomeCursor:
FFFFFFFFFFFC080F.8 FFFE80050 	  stb   #0,_cursorX
FFFFFFFFFFFC0814.0 004000870 
FFFFFFFFFFFC0818.8 FFFE80050 	  stb   #0,_cursorY
FFFFFFFFFFFC081D.0 004000970 
FFFFFFFFFFFC0821.8 000004042 	  ret
  
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   EOF if error occurred, otherwise character to put
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	fputc:
FFFFFFFFFFFC0826.0 FFE079E04 		sub	$sp,$sp,#32
FFFFFFFFFFFC082A.8 301579070 		sto		$a1,16[$sp]
FFFFFFFFFFFC082F.0 301679870 		sto		$a2,24[$sp]
FFFFFFFFFFFC0833.8 000001A00 		seq   $a6,#'B'
	bf    .noBypass
FFFFFFFFFFFC0838.0 01FC58141 		call  SerialPutChar
FFFFFFFFFFFC083C.8 000026441 		jmp   .xit
                        	.noBypass:
                        		; If the device is a UI device there may be multiple owning jobs. It doesn't
                        		; do any good to check for ownership. Instead the I/O focus is checked to
                        		; see if it's present.
FFFFFFFFFFFC0841.0 01FC54541 		call  GetUIFlag
FFFFFFFFFFFC0845.8 16005700C 		tst   $cr0,$a1
FFFFFFFFFFFC084A.0 00000008F 
FFFFFFFFFFFC084E.8 007FC044E 		beq   $cr0,.checkOwner
FFFFFFFFFFFC0853.0 301079560 	  ldo   $a1,16[$sp]
FFFFFFFFFFFC0857.8 01FC49941 		call  WaitForIOFocus
FFFFFFFFFFFC085C.0 00000B441 		jmp   .0001
                        	.checkOwner:
FFFFFFFFFFFC0860.8 01FC45941 	  call  CheckDevOwner
FFFFFFFFFFFC0865.0 16005300C 	  tst   $cr0,$a0
FFFFFFFFFFFC0869.8 00000008F 
FFFFFFFFFFFC086E.0 007FC0A4F 	  bne   $cr0,.notOwner
                        	.0001:
FFFFFFFFFFFC0872.8 301079560 	  ldo   $a1,16[$sp]
FFFFFFFFFFFC0877.0 001A01404 		ldi		$a0,#26							; FMTK_IO
FFFFFFFFFFFC087B.8 000D01604 		ldi		$a2,#13							; putchar function
FFFFFFFFFFFC0880.0 000210000 		brk   #240
	mov   $a0,$a3
FFFFFFFFFFFC0884.8 00005D434 
                        	.xit:
FFFFFFFFFFFC0889.0 301079560 		ldo		$a1,16[$sp]
FFFFFFFFFFFC088D.8 301879660 		ldo		$a2,24[$sp]
FFFFFFFFFFFC0892.0 002079E04 		add   $sp,$sp,#32
FFFFFFFFFFFC0896.8 000004042 		ret
.notOwner:
FFFFFFFFFFFC089B.0 001A01404 	  ldi   $a0,#EOF
FFFFFFFFFFFC089F.8 FFFFF4C41 	  jmp   .xit
                        	 
                        	;------------------------------------------------------------------------------
                        	; fgetc - get a character from an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		4 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device getchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		a0 character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	fgetc:
FFFFFFFFFFFC08A4.0 FFE079E04 		sub	$sp,$sp,#32
FFFFFFFFFFFC08A8.8 301579070 		sto		$a1,16[$sp]
FFFFFFFFFFFC08AD.0 301679870 		sto		$a2,24[$sp]
FFFFFFFFFFFC08B1.8 01FC1C141 		call  GetUIFlag
FFFFFFFFFFFC08B6.0 16005400C 		tst   $a1
FFFFFFFFFFFC08BA.8 00000008F 
FFFFFFFFFFFC08BF.0 007FFC44E 		beq   .checkOwner
FFFFFFFFFFFC08C3.8 201079560 		ldt		$a1,16[$sp]
FFFFFFFFFFFC08C8.0 01FC11541 		call  WaitForIOFocus
FFFFFFFFFFFC08CC.8 00000D841 		jmp   .0001
                        	.checkOwner:
FFFFFFFFFFFC08D1.0 201079560 		ldt		$a1,16[$sp]
FFFFFFFFFFFC08D5.8 01FC0B141 	  call  CheckDevOwner
FFFFFFFFFFFC08DA.0 16005000C 	  tst   $a0
FFFFFFFFFFFC08DE.8 00000008F 
FFFFFFFFFFFC08E3.0 007FFCA4F 	  bne   .notOwner
                        	.0001:
FFFFFFFFFFFC08E7.8 001A01404 		ldi		$a0,#26							; FMTK_IO
FFFFFFFFFFFC08EC.0 201079560 		ldt		$a1,16[$sp]
FFFFFFFFFFFC08F0.8 000801604 		ldi		$a2,#8							; getchar function
FFFFFFFFFFFC08F5.0 000210000 		brk   #240
	mov   $a0,$a1
FFFFFFFFFFFC08F9.8 000055434 
                        	.0002:
FFFFFFFFFFFC08FE.0 301079560 		ldo		$a1,16[$sp]
FFFFFFFFFFFC0902.8 301879660 		ldo		$a2,24[$sp]
FFFFFFFFFFFC0907.0 002079E04 		add   $sp,$sp,#32
FFFFFFFFFFFC090B.8 000004042 		ret
.notOwner:
FFFFFFFFFFFC0910.0 FFFF01404 	  ldi   $a0,#-1
FFFFFFFFFFFC0914.8 FFFFF4C41 	  jmp   .0002
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFFFFFFFFFC0919.0 000A01404 			ldi		$a0,#10
FFFFFFFFFFFC091D.8 000601604 			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	  ; align cache
                        	Monitor:
                        	.getFocus:
                        	;	ldi   $a0,#20       ; has IO focus
                        	;	brk #240
                        	;	bnez  $v1,.hasFocus
                        	;	ldi   $a0,#21       ; switch focus
                        	;	brk #240
                        	;	bra   .getFocus
                        	.hasFocus:
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFFFFFFFFFC0922.0 000000B04 		ldi		  $s1,#0					; s1 = input pointer
FFFFFFFFFFFC0926.8 0002CDD41 		call    PutInlineString
                        		db      CR,LNFD,'>',0
.0001:
FFFFFFFFFFFC092B.0 FFFE9C941 		call	    Getch						; wait until character pressed
FFFFFFFFFFFC092F.8 16005000C 		tst     $a0        ; test return value
FFFFFFFFFFFC0934.0 00000008F 
FFFFFFFFFFFC0938.8 FFFFFFD48 		bmi	    .0001
FFFFFFFFFFFC093D.0 000001400 		seq     $a0,#LNFD  ; process line feed
	seq.or  $a0,#CR    ; and carriage return
                        		bt	    .procLine
FFFFFFFFFFFC0941.8 000001400 		seq		  $a0,#BS
	bt	    .doBackspace
FFFFFFFFFFFC0946.0 000001400 		seq		  $a0,#DEL
	bt	    .doDelete
FFFFFFFFFFFC094A.8 02142C070 		stb		  $a0,INBUF[$s1]
FFFFFFFFFFFC094F.0 00012CB04 		add		  $s1,$s1,#1
FFFFFFFFFFFC0953.8 FFFE9A541 		call    Putch
FFFFFFFFFFFC0958.0 FFFFE9841 		jmp		  .0001
                        	.doDelete:
FFFFFFFFFFFC095C.8 00002CC34 		mov		  $s2,$s1
FFFFFFFFFFFC0961.0 000130C04 		add		  $s2,$s2,#1
                        	.0002:
FFFFFFFFFFFC0965.8 010030360 		ldb		  $t0,INBUF[$s2]
FFFFFFFFFFFC096A.0 018333F70 		stb		  $t0,INBUF-1[$s2]
FFFFFFFFFFFC096E.8 000130C04 		add		  $s2,$s2,#1
FFFFFFFFFFFC0973.0 010030304 		add		  $t0,$s2,#INBUF
FFFFFFFFFFFC0977.8 007F00328 		slt		  $t0,#INBUF+$7F
                        		bt		  .0002
FFFFFFFFFFFC097C.0 020030070 		stb		  $x0,INBUF[$s2]
FFFFFFFFFFFC0980.8 FFFFD5441 		jmp		  .0001
                        	.doBackspace:
FFFFFFFFFFFC0985.0 16002C00C 	  tst     $s1
FFFFFFFFFFFC0989.8 00000008F 
FFFFFFFFFFFC098E.0 FFFFFEA4E 		beq		  .0001		        ; can't backspace anymore
FFFFFFFFFFFC0992.8 FFFE7AD41 		call    Putch           ; show the backspace
FFFFFFFFFFFC0997.0 FFFF2CB04 		sub		  $s1,$s1,#1
FFFFFFFFFFFC099B.8 00002CC34 		mov		  $s2,$s1
                        	.0003:
FFFFFFFFFFFC09A0.0 010130360 		ldb		  $t0,INBUF+1[$s2]
FFFFFFFFFFFC09A4.8 020330070 		stb		  $t0,INBUF[$s2]
FFFFFFFFFFFC09A9.0 000130C04 		add		  $s2,$s2,#1
FFFFFFFFFFFC09AD.8 010030304 		add		  $t0,$s2,#INBUF
FFFFFFFFFFFC09B2.0 007F00328 		slt		  $t0,#INBUF+$7F
                        		bt		  .0003
FFFFFFFFFFFC09B6.8 020030070 		stb		  $x0,INBUF[$s2]
FFFFFFFFFFFC09BB.0 FFFFB8041 		jmp		  .0001
                        	.procLine:
FFFFFFFFFFFC09BF.8 02002C070 		stb		  $x0,INBUF[$s1]
FFFFFFFFFFFC09C4.0 000000B04 		ldi		  $s1,#0
                        	.skip:
FFFFFFFFFFFC09C8.8 01002C360 		ldb.	  $t0,INBUF[$s1]
FFFFFFFFFFFC09CD.0 00FFFC84E 		beq		  .0005
FFFFFFFFFFFC09D1.8 000000300 		seq		  $t0,#'>'
	bf		  .0004
                        	.skip2:
FFFFFFFFFFFC09D6.0 00012CB04 		add		  $s1,$s1,#1
FFFFFFFFFFFC09DA.8 FFFFF7041 		jmp		  .skip
                        	.0004:
FFFFFFFFFFFC09DF.0 000000300 		seq		  $t0,#' '
	seq.or  $t0,#'\t'
                        		bt		  .skip2
FFFFFFFFFFFC09E3.8 000000300 		seq     $t0,#'X'  ; exit from monitor
	bf      .notX
FFFFFFFFFFFC09E8.0 000001404 		ldi     $a0,#E_Ok
FFFFFFFFFFFC09EC.8 01FB78441 		jmp     OSExit
                        	.notX:
FFFFFFFFFFFC09F1.0 000000300 		seq		  $t0,#'M'
	bt	    doMem
FFFFFFFFFFFC09F5.8 000000300 		seq     $t0,#'V'
	bt      doVMem
FFFFFFFFFFFC09FA.0 000000300 		seq     $t0,#'P'
	bt      doPStat
FFFFFFFFFFFC09FE.8 000000300 		seq		  $t0,#'B'
	bt		  .0006
FFFFFFFFFFFC0A03.0 00020C541 		call    GetDecNum
FFFFFFFFFFFC0A07.8 16005000C 		tst     $a0
FFFFFFFFFFFC0A0C.0 00000008F 
FFFFFFFFFFFC0A10.8 007FFC24F 		bne     .basSize
FFFFFFFFFFFC0A15.0 7D0001404 		ldi     $a0,#32000
                        	.basSize:
FFFFFFFFFFFC0A19.8 000C01404 		ldi		  $a0,#12					; Start App
FFFFFFFFFFFC0A1E.0 000000050 		ldi     $a1,#TBASR
FFFFFFFFFFFC0A22.8 F00000051 
FFFFFFFFFFFC0A27.0 01EE01504 
FFFFFFFFFFFC0A2B.8 000210000 		brk     #240
	mov		  $s1,$a1					; save v1
FFFFFFFFFFFC0A30.0 000054B34 
FFFFFFFFFFFC0A34.8 FFFFF0450 		ldi		  $a0,#msgCRLF
FFFFFFFFFFFC0A39.0 241401404 
FFFFFFFFFFFC0A3D.8 00025F941 		call    PutString
FFFFFFFFFFFC0A42.0 00002D434 		mov		  $a0,$s1					; get back v1
FFFFFFFFFFFC0A46.8 000219D41 		call    PutHexByte
FFFFFFFFFFFC0A4B.0 FFFFF0450 		ldi		  $a0,#msgTaskStart
FFFFFFFFFFFC0A4F.8 241401404 
FFFFFFFFFFFC0A54.0 000254541 		call    PutString
FFFFFFFFFFFC0A58.8 01FB40141 		call    DumpReadyQueue
                        		; The monitor is running in machine mode. A return instruction is used to
                        		; switch to user mode. The return address must be set to the desired user
                        		; code address.
                        		
FFFFFFFFFFFC0A5D.0 00100400F 	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	; disable interrupts
FFFFFFFFFFFC0A61.8 000000050 		ldi     $t0,#CSTART       ; pick start of Tiny Basic
FFFFFFFFFFFC0A66.0 F00000051 
FFFFFFFFFFFC0A6A.8 01F200304 
FFFFFFFFFFFC0A6F.0 00D04C00F 		csrrw   $x0,#$341,$t0     ; set as return address
FFFFFFFFFFFC0A73.8 000002250 		ldi     $t0,#$00011111    ; bits to select register set #1
FFFFFFFFFFFC0A78.0 111100304 
FFFFFFFFFFFC0A7C.8 10048C00F 		csrrw   $x0,#CSR_REGSET,$t0     ; select register set #1 (will decrement to zero then on mret)
FFFFFFFFFFFC0A81.0 000000045 		rte                     ; will begin running Tiny Basic in user mode
	;ldi		$a0,#5					; Reschedule task
                        		;ldi		$a1,#1					; sleep(0)
                        		;brk #240
FFFFFFFFFFFC0A85.8 FFFF4E441 		jmp		  Monitor
                        	.0006:
FFFFFFFFFFFC0A8A.0 000000300 		seq		  $t0,#'D'
	bf		  .0007
FFFFFFFFFFFC0A8E.8 01012C360 		ldb		  $t0,INBUF+1[$s1]
FFFFFFFFFFFC0A93.0 000000300 		seq		  $t0,#'T'
	bf		  .noT
FFFFFFFFFFFC0A97.8 01FB31541 		call    DumpTimeoutList
FFFFFFFFFFFC0A9C.0 FFFF43041 		jmp		  Monitor
                        	.noT:
FFFFFFFFFFFC0AA0.8 01FB1C141 		call	  DumpReadyQueue
                        		;ldi		$a0,#15
                        		;brk #240
FFFFFFFFFFFC0AA5.0 FFFF3E841 		jmp		  Monitor
                        	.0007:
FFFFFFFFFFFC0AA9.8 000000300 		seq		  $t0,#'E'
	bt		  EditMem
FFFFFFFFFFFC0AAE.0 000000300 		seq		  $t0,#'F'
	bf		  .0009
FFFFFFFFFFFC0AB2.8 01012C360 		ldb     $t0,INBUF+1[$s1]
FFFFFFFFFFFC0AB7.0 000000327 		sne     $t0,#'I'
	bt      .notFind
FFFFFFFFFFFC0ABB.8 00012CB04 		add     $s1,$s1,#1
FFFFFFFFFFFC0AC0.0 000112841 		jmp     Find
                        	.notFind:
FFFFFFFFFFFC0AC4.8 0000F5441 		jmp		  FillMem
                        	.0009:
FFFFFFFFFFFC0AC9.0 000000327 		sne		  $t0,#'S'
	bt		  .0010
FFFFFFFFFFFC0ACD.8 000501404 		ldi		  $a0,#5					; sleep(0)
FFFFFFFFFFFC0AD2.0 000101504 		ldi		  $a1,#1
FFFFFFFFFFFC0AD6.8 000210000 		brk     #240
	jmp		  Monitor
FFFFFFFFFFFC0ADB.0 FFFF23841 
                        	.0010:
FFFFFFFFFFFC0ADF.8 000000327 		sne		  $t0,#'K'
	bt		  .0011
FFFFFFFFFFFC0AE4.0 000165D41 		call    GetHexNum
FFFFFFFFFFFC0AE8.8 000051534 		mov		  $a1,$a0					; a0 = pid
FFFFFFFFFFFC0AED.0 000301404 		ldi		  $a0,#3					; kill task
FFFFFFFFFFFC0AF1.8 000210000 		brk     #240
	jmp		  Monitor
FFFFFFFFFFFC0AF6.0 FFFF16041 
                        	.0011:
FFFFFFFFFFFC0AFA.8 000000427 		sne		  $t1,#'?'
	bt		  .0012
FFFFFFFFFFFC0AFF.0 FFFFF0450 		ldi		  $a0,#msgMonHelp
FFFFFFFFFFFC0B03.8 241401404 
FFFFFFFFFFFC0B08.0 0001FA541 		call    PutString
FFFFFFFFFFFC0B0C.8 FFFF0AC41 		jmp		  Monitor
                        	.0012:
                        	.0005:
FFFFFFFFFFFC0B11.0 FFFF08841 		jmp		  Monitor
                        	
                        	  ; align cache
                        	doMem:
FFFFFFFFFFFC0B15.8 FFF879E04 		sub	$sp,$sp,#8
FFFFFFFFFFFC0B1A.0 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0B1E.8 01002C360 		ldb		$t0,INBUF[$s1]
FFFFFFFFFFFC0B23.0 000000327 		sne   $t0,#'O'
	bt    .0001
FFFFFFFFFFFC0B27.8 00012CB04 		add		$s1,$s1,#1
                        	.0001:
FFFFFFFFFFFC0B2C.0 300B78070 		sto		$s1,[$sp]
FFFFFFFFFFFC0B30.8 000D01404 		ldi		$a0,#CR
FFFFFFFFFFFC0B35.0 FFFDA9941 		call  Putch
FFFFFFFFFFFC0B39.8 010001404 		ldi		$a0,#INBUF
FFFFFFFFFFFC0B3E.0 0001DF541 		call  PutString
FFFFFFFFFFFC0B42.8 300078B60 		ldo		$s1,[$sp]
FFFFFFFFFFFC0B47.0 000879E04 		add		$sp,$sp,#8
FFFFFFFFFFFC0B4B.8 000132141 		call  GetHexNum
FFFFFFFFFFFC0B50.0 000050D34 		mov		$s3,$a0
FFFFFFFFFFFC0B54.8 000050F34 		mov   $s5,$a0
FFFFFFFFFFFC0B59.0 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0B5D.8 000129141 		call	  GetHexNum
FFFFFFFFFFFC0B62.0 080D50E02 		add		$s4,$a0,$s3
                        	.loop2:
FFFFFFFFFFFC0B66.8 FFFD7ED41 		call	Getch						; check for ctrl-c
FFFFFFFFFFFC0B6B.0 000001400 		seq		$a0,#3
	bt		Monitor
FFFFFFFFFFFC0B6F.8 000D01404 		ldi		$a0,#CR
FFFFFFFFFFFC0B74.0 FFFD8A141 		call	Putch
FFFFFFFFFFFC0B78.8 000035434 		mov		$a0,$s3
FFFFFFFFFFFC0B7D.0 01FAC2541 		call	PutHexWord
FFFFFFFFFFFC0B81.8 003A01404 		ldi		$a0,#':'
FFFFFFFFFFFC0B86.0 FFFD81141 		call	Putch
FFFFFFFFFFFC0B8A.8 000700C04 		ldi		$s2,#7
                        	.loop:
FFFFFFFFFFFC0B8F.0 002001404 		ldi		$a0,#' '
FFFFFFFFFFFC0B93.8 FFFD7A541 		call	Putch
FFFFFFFFFFFC0B98.0 16000F00C 		tst   $cr0,$t0
FFFFFFFFFFFC0B9C.8 00000008F 
FFFFFFFFFFFC0BA1.0 007FC064F 		bne   $cr0,.userMem
FFFFFFFFFFFC0BA5.8 002101404 		ldi   $a0,#33         ; Fetch memory word
FFFFFFFFFFFC0BAA.0 000035534 		mov   $a1,$s3
FFFFFFFFFFFC0BAE.8 000210000 		brk   #240
	mov   $a0,$a1
FFFFFFFFFFFC0BB3.0 000055434 
FFFFFFFFFFFC0BB7.8 000004841 		jmp   .0002
                        	.userMem
FFFFFFFFFFFC0BBC.0 000035460 		ldb		$a0,[$s3]
                        	.0002:
FFFFFFFFFFFC0BC0.8 00015CD41 		call	PutHexByte
FFFFFFFFFFFC0BC5.0 000134D04 		add		$s3,$s3,#1
R2 operation needs two source operands. (2197)
R2 operation needs two source operandsFFFFFFFFFFFC0BC9.8 0A007DF02 		sub.	$s2,$s2,#1
FFFFFFFFFFFC0BCE.0 FFFFFF249 		bge		.loop
FFFFFFFFFFFC0BD2.8 000038D2C 		sltu  $s3,$s4
	bt	  .loop2
FFFFFFFFFFFC0BD7.0 000175941 		call  PutInlineString
FFFFFFFFFFFC0BDB.8 00003CD34 		db    ' ',' ',0
	mov   $s3,$s5
                        	.0004:
FFFFFFFFFFFC0BE0.0 000035464 		ldbu  $a0,[$s3]
FFFFFFFFFFFC0BE4.8 000001428 		slt   $a0,#$20
	bt    .unprintable
FFFFFFFFFFFC0BE9.0 FFFD4F941 		call  Putch
FFFFFFFFFFFC0BED.8 000006C41 		jmp   .0003
                        	.unprintable:
FFFFFFFFFFFC0BF2.0 002E01404 	  ldi   $a0,#'.'
FFFFFFFFFFFC0BF6.8 FFFD48D41 	  call  Putch
                        	.0003:
FFFFFFFFFFFC0BFB.0 000134D04 	  add   $s3,$s3,#1
FFFFFFFFFFFC0BFF.8 000038D2C 	  sltu  $s3,$s4
  bt    .0004
FFFFFFFFFFFC0C04.0 000D01404 	  ldi   $a0,#CR
FFFFFFFFFFFC0C08.8 FFFD3FD41 	  call  Putch
FFFFFFFFFFFC0C0D.0 FFFE8A841 		jmp		Monitor		
                        	
                        	  ; align cache
                        	EditMem:
FFFFFFFFFFFC0C11.8 00010400F 		csrrs $x0,#CSR_UIE,#1        ; enable gc interrupt
FFFFFFFFFFFC0C16.0 0000CCD41 		call	  GetHexNum			; get address to edit
FFFFFFFFFFFC0C1A.8 000050D34 		mov		$s3,$a0
FFFFFFFFFFFC0C1F.0 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0C23.8 0000C6141 		call	  GetHexNum			; get value to set
FFFFFFFFFFFC0C28.0 000D50070 		stb		$s3,[$a0]			; update mem
FFFFFFFFFFFC0C2C.8 FFFE7AC41 		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >V 0
                        	; Displays the virtual memory map for the specified app.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	doVMem:
FFFFFFFFFFFC0C31.0 00012CB04 	  add   $s1,$s1,#1
FFFFFFFFFFFC0C35.8 0000F3141 	  call  GetDecNum
FFFFFFFFFFFC0C3A.0 000000404 	  ldi   $t1,#0
FFFFFFFFFFFC0C3E.8 021050302 	  asl   $t0,$a0,#16
                        	.0001:
R2 operation needs two source operands. (2260)
R2 operation needs two source operandsFFFFFFFFFFFC0C43.0 00007DF02 	  and.  $a0,$t1,#3
FFFFFFFFFFFC0C47.8 007FFC24F 	  bne   .notLF
FFFFFFFFFFFC0C4C.0 00013B141 	  call  PutInlineString
                        	  db    CR,LNFD,0
.notLF:
FFFFFFFFFFFC0C50.8 00000D434 	  mov   $a0,$t0
FFFFFFFFFFFC0C55.0 01FA56541 	  call  PutHexWord
FFFFFFFFFFFC0C59.8 003A01404 	  ldi   $a0,#':'
FFFFFFFFFFFC0C5E.0 FFFD15141 	  call  Putch
FFFFFFFFFFFC0C62.8 380301402 	  mvmap $a0,$x0,$t0
FFFFFFFFFFFC0C67.0 01FA50141 	  call  PutHexHalf
FFFFFFFFFFFC0C6B.8 002001404 	  ldi   $a0,#' '
FFFFFFFFFFFC0C70.0 FFFD0C141 	  call  Putch
FFFFFFFFFFFC0C74.8 00010C304 	  add   $t0,$t0,#1
FFFFFFFFFFFC0C79.0 000110404 	  add   $t1,$t1,#1
FFFFFFFFFFFC0C7D.8 000000428 	  slt   $t1,#256
  bt    .0001
FFFFFFFFFFFC0C82.0 FFFE50041 	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >P
                        	; Display the PAM bits status.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	doPStat:
FFFFFFFFFFFC0C86.8 00011DD41 	  call  PutInlineString
FFFFFFFFFFFC0C8B.0 000000404 	  db    CR,LNFD,0
  ldi   $t1,#0        ; $a1 = bit number
                        	.0001:
FFFFFFFFFFFC0C8F.8 002001404 	  ldi   $a0,#32       ; Get PAM bit pair
FFFFFFFFFFFC0C94.0 000210000 	  brk   #240
  add   $a0,$a1,#'0'
FFFFFFFFFFFC0C98.8 003055404 
FFFFFFFFFFFC0C9D.0 FFFCF5941 	  call  Putch
FFFFFFFFFFFC0CA1.8 000110404 	  add   $t1,$t1,#1
FFFFFFFFFFFC0CA6.0 000000428 	  slt   $t1,#MEMSZ
  bne   .0001
FFFFFFFFFFFC0CAA.8 FFFE3BC41 	  jmp   Monitor
                        	 
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	FillMem:
FFFFFFFFFFFC0CAF.0 000080541 		call	GetHexNum			; get address
FFFFFFFFFFFC0CB3.8 000050D34 		mov		$s3,$a0
FFFFFFFFFFFC0CB8.0 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0CBC.8 000079941 		call	GetHexNum			; get length
FFFFFFFFFFFC0CC1.0 000050E34 		mov		$s4,$a0
FFFFFFFFFFFC0CC5.8 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0CCA.0 000072D41 		call	GetHexNum			; get byte to use
                        	.0001:
R2 operation needs two source operands. (2339)
R2 operation needs two source operandsFFFFFFFFFFFC0CCE.8 0A007DF02 		sub.	$s4,$s4,#1
FFFFFFFFFFFC0CD3.0 000038058 		stb		$a0,[$s3+$s4]
FFFFFFFFFFFC0CD7.8 001434071 
FFFFFFFFFFFC0CDC.0 FFFFFFD48 		bgt		.0001
FFFFFFFFFFFC0CE0.8 FFFE20C41 		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; FI Hello
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	Find:
FFFFFFFFFFFC0CE5.0 000D01404 	  ldi   $a0,#CR
FFFFFFFFFFFC0CE9.8 FFFCCF541 	  call  Putch
FFFFFFFFFFFC0CEE.0 000A01404 	  ldi   $a0,#LNFD
FFFFFFFFFFFC0CF2.8 FFFCCAD41 	  call  Putch
FFFFFFFFFFFC0CF7.0 000051141 	  call  SkipSpaces
FFFFFFFFFFFC0CFB.8 00002CC34 	  mov   $s2,$s1
                        	.fwe:
FFFFFFFFFFFC0D00.0 010030364 	  ldbu.   $t0,INBUF[$s2]
FFFFFFFFFFFC0D04.8 0003FFF0D 	  seq.or  $t0,#' '
FFFFFFFFFFFC0D09.0 0003FFF0D 	  seq.or  $t0,#CR    ; cmp power!
                        	  bt      .endOfWord
FFFFFFFFFFFC0D0D.8 000130C04 	  add     $s2,$s2,#1
FFFFFFFFFFFC0D12.0 FFFFF7041 	  jmp     .fwe
                        	.endOfWord:
FFFFFFFFFFFC0D16.8 020030070 	  stb   $x0,INBUF[$s2]
FFFFFFFFFFFC0D1B.0 00002CC34 	  mov   $s2,$s1
FFFFFFFFFFFC0D1F.8 000001404 	  ldi   $a0,#0
FFFFFFFFFFFC0D24.0 000001504 	  ldi   $a1,#0
                        	.loop:
FFFFFFFFFFFC0D28.8 FFFC9DD41 		call	Getch						; check for ctrl-c
FFFFFFFFFFFC0D2D.0 000001400 		seq   $a0,#3
	bt	  Monitor
                        	.0001:
FFFFFFFFFFFC0D31.8 000050364 	  ldbu  $t0,[$a0]
FFFFFFFFFFFC0D36.0 010030464 	  ldbu. $t1,INBUF[$s2]
FFFFFFFFFFFC0D3A.8 007FFCD4E 	  beq   .found
FFFFFFFFFFFC0D3F.0 000010300 	  seq   $t0,$t1
  bf    .next
FFFFFFFFFFFC0D43.8 000151404 	  add   $a0,$a0,#1
FFFFFFFFFFFC0D48.0 000130C04 	  add   $s2,$s2,#1
FFFFFFFFFFFC0D4C.8 FFFFEE041 	  jmp   .loop
                        	.next:
FFFFFFFFFFFC0D51.0 00002CC34 	  mov   $s2,$s1         ; start over again with $s2
FFFFFFFFFFFC0D55.8 000155404 	  add   $a0,$a1,#1      ; start over again with $a0, but increment by one
FFFFFFFFFFFC0D5A.0 000010050 	  ldi   $t2,#$80000     ; 512k
FFFFFFFFFFFC0D5E.8 000000504 
FFFFFFFFFFFC0D63.0 000051534 	  mov   $a1,$a0         ; remember new starting pos.
FFFFFFFFFFFC0D67.8 08055000D 	  slt   $cr0,$a0,$t2
FFFFFFFFFFFC0D6C.0 FFFFC314F 	  bne   $cr0,.loop
FFFFFFFFFFFC0D70.8 000009041 	  jmp   .notFound
                        	.found:
FFFFFFFFFFFC0D75.0 000075141 	  call  PutHexTetra
FFFFFFFFFFFC0D79.8 0000A4541 	  call  PutInlineString
FFFFFFFFFFFC0D7E.0 FFFFE9841 	  db    CR,LNFD,0
  jmp   .next
                        	.notFound:
FFFFFFFFFFFC0D82.8 000D01404 	  ldi   $a0,#CR
FFFFFFFFFFFC0D87.0 FFFC80941 	  call  Putch
FFFFFFFFFFFC0D8B.8 000A01404 	  ldi   $a0,#LNFD
FFFFFFFFFFFC0D90.0 FFFC7C141 	  call  Putch
FFFFFFFFFFFC0D94.8 FFFDC6C41 	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	SkipSpaces:
                        	.skip2:
FFFFFFFFFFFC0D99.0 01002C360 		ldb		  $t0,INBUF[$s1]
FFFFFFFFFFFC0D9D.8 000000300 		seq		  $t0,#' '   ; space or
	seq.or  $t0,#'\t'  ; tab - compare power use here
                        		bf	    .done
FFFFFFFFFFFC0DA2.0 00012CB04 		add 		$s1,$s1,#1
FFFFFFFFFFFC0DA6.8 FFFFF9441 		bra	  	.skip2
                        	.done
FFFFFFFFFFFC0DAB.0 000004042 	  ret

                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	GetHexNum:
FFFFFFFFFFFC0DAF.8 000001404 		ldi		$a0,#0							; a0 = num
FFFFFFFFFFFC0DB4.0 FFFFF2941 		call   	SkipSpaces
                        	.next:
FFFFFFFFFFFC0DB8.8 01002C360 		ldb		  $t0,INBUF[$s1]
FFFFFFFFFFFC0DBD.0 000000329 		sge     $t0,#'0'
	sle.and	$t0,#'9'
                        		bt		  .isDigit
FFFFFFFFFFFC0DC1.8 000000329 		sge		  $t0,#'A'
	sle.and $t0,#'F'
                        		bt		  .isHexUpper
FFFFFFFFFFFC0DC6.0 000000329 		sge		  $t0,#'a'
	sle.and	$t0,#'f'
                        		bt		.isHexLower
                        	.0001:
FFFFFFFFFFFC0DCA.8 000004042 		ret
.isHexUpper:
FFFFFFFFFFFC0DCF.0 020451402 		asl		$a0,$a0,#4
FFFFFFFFFFFC0DD3.8 FFBF0C304 		sub		$t0,$t0,#'A'
FFFFFFFFFFFC0DD8.0 000A0C304 		add		$t0,$t0,#10
FFFFFFFFFFFC0DDC.8 020351402 		or		$a0,$a0,$t0
FFFFFFFFFFFC0DE1.0 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0DE5.8 FFFFE9841 		jmp		.next
                        	.isHexLower:
FFFFFFFFFFFC0DEA.0 020451402 		asl		$a0,$a0,#4
FFFFFFFFFFFC0DEE.8 FF9F0C304 		sub		$t0,$t0,#'a'
FFFFFFFFFFFC0DF3.0 000A0C304 		add		$t0,$t0,#10
FFFFFFFFFFFC0DF7.8 020351402 		or		$a0,$a0,$t0
FFFFFFFFFFFC0DFC.0 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0E00.8 FFFFDC041 		jmp		.next
                        	.isDigit:
FFFFFFFFFFFC0E05.0 020451402 		asl		$a0,$a0,#4
FFFFFFFFFFFC0E09.8 FFD00C304 		sub		$t0,$t0,#'0'
FFFFFFFFFFFC0E0E.0 020351402 		or		$a0,$a0,$t0
FFFFFFFFFFFC0E12.8 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0E17.0 FFFFD0C41 		jmp		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a decimal number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	GetDecNum:
FFFFFFFFFFFC0E1B.8 000001404 		ldi		$a0,#0							; a0 = num
FFFFFFFFFFFC0E20.0 FFFFBC941 		call 	  SkipSpaces
                        	.next:
FFFFFFFFFFFC0E24.8 01002C360 		ldb		  $t0,INBUF[$s1]
FFFFFFFFFFFC0E29.0 000000329 		sge     $t0,#'0'
	sle.and $t0,#'9'
                        		bt		  .isDigit
                        	.0001:
FFFFFFFFFFFC0E2D.8 000004042 		ret
.isDigit:
FFFFFFFFFFFC0E32.0 020150502 		asl		$t2,$a0,#1    ; multiply by 10
FFFFFFFFFFFC0E36.8 020351402 		asl   $a0,$a0,#3    ; * 8
FFFFFFFFFFFC0E3B.0 080551402 		add   $a0,$a0,$t2   ; + *2
FFFFFFFFFFFC0E3F.8 FFD00C304 		sub		$t0,$t0,#'0'
FFFFFFFFFFFC0E44.0 080351402 		add		$a0,$a0,$t0
FFFFFFFFFFFC0E48.8 00012CB04 		add		$s1,$s1,#1
FFFFFFFFFFFC0E4D.0 FFFFEBC41 		jmp		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output an octabyte as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains octabyte value to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	PutHexOcta:
FFFFFFFFFFFC0E51.8 082051402 		ror		$a0,$a0,#32
FFFFFFFFFFFC0E56.0 000004941 		call	PutHexTetra
FFFFFFFFFFFC0E5A.8 062051402 		rol   $a0,$a0,#32
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains word to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexTetra:
FFFFFFFFFFFC0E5F.0 081051402 		ror		$a0,$a0,#16
FFFFFFFFFFFC0E63.8 000004941 		call	PutHexWyde
FFFFFFFFFFFC0E68.0 061051402 		rol		$a0,$a0,#16
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexWyde:
FFFFFFFFFFFC0E6C.8 080851402 		ror		$a0,$a0,#8
FFFFFFFFFFFC0E71.0 000004941 		call	PutHexByte
FFFFFFFFFFFC0E75.8 060851402 		rol		$a0,$a0,#8
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexByte:
FFFFFFFFFFFC0E7A.0 080451402 		ror		$a0,$a0,#4		; put the high order nybble first
FFFFFFFFFFFC0E7E.8 000004941 		call	PutHexNybble
FFFFFFFFFFFC0E83.0 060451402 		rol		$a0,$a0,#4		; restore a0
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains nybble to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutHexNybble:
FFFFFFFFFFFC0E87.8 FFF079E04 		sub	$sp,$sp,#16
FFFFFFFFFFFC0E8C.0 301478070 		sto		$a0,0[$sp]
FFFFFFFFFFFC0E90.8 300378870 		sto   $t0,8[$sp]
FFFFFFFFFFFC0E95.0 000F51408 		and		$a0,$a0,#15		; strip off high order bits
FFFFFFFFFFFC0E99.8 000001428 		slt   $a0,#10
	bt		.lt10
FFFFFFFFFFFC0E9E.0 FFF651404 		sub		$a0,$a0,#10
FFFFFFFFFFFC0EA2.8 001151404 		add		$a0,$a0,#'A'-'0'
                        	.lt10:
FFFFFFFFFFFC0EA7.0 003051404 		add		$a0,$a0,#'0'
FFFFFFFFFFFC0EAB.8 FFFBEE541 		call	Putch
                        	.0001:
FFFFFFFFFFFC0EB0.0 300079460 		ldo		$a0,0[$sp]
FFFFFFFFFFFC0EB4.8 300878360 		ldo   $t0,8[$sp]
FFFFFFFFFFFC0EB9.0 001079E04 		add   $sp,$sp,#16
FFFFFFFFFFFC0EBD.8 000004042 		ret

                        	;------------------------------------------------------------------------------
                        	; PutInlineString
                        	;   Put a string of characters to output device. The string parameter is
                        	; located as an inline parameter.
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	PutInlineString:
FFFFFFFFFFFC0EC2.0 300078460 	  ldo   $t1,[$sp]         ; pop return address
FFFFFFFFFFFC0EC6.8 000879E04 	  add   $sp,$sp,#8
FFFFFFFFFFFC0ECB.0 FFF879E04 		sub		$sp,$sp,#8				
FFFFFFFFFFFC0ECF.8 301478070 		sto		$a0,[$sp]				  ; save a0
FFFFFFFFFFFC0ED4.0 000410404 		add		$t1,$t1,#4  			; t1 = pointer to string
                        	.0001:
FFFFFFFFFFFC0ED8.8 000011460 		ldb		$a0,[$t1]
FFFFFFFFFFFC0EDD.0 000110404 		add		$t1,$t1,#1				; advance pointer to next byte
FFFFFFFFFFFC0EE1.8 00405034E 		beq 	$a0,#0,.done      ; branch if done
FFFFFFFFFFFC0EE6.0 FFFBD1141 		call	Putch							; output character
FFFFFFFFFFFC0EEA.8 FFFFF7041 		bra		.0001
                        	.done:
FFFFFFFFFFFC0EEF.0 300079460 		ldo		$a0,[$sp]				  ; restore a0
FFFFFFFFFFFC0EF3.8 000879E04 		add   $sp,$sp,#8
FFFFFFFFFFFC0EF8.0 000000042 	  jmp   [$t1]
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	  ; align cache
                        	PutString:
FFFFFFFFFFFC0EFC.8 FFF079E04 		sub		$sp,$sp,#16
FFFFFFFFFFFC0F01.0 301478070 		sto		$a0,[$sp]				  ; save argument
FFFFFFFFFFFC0F05.8 300B78870 		sto   $s1,8[$sp]        ; and reg var
FFFFFFFFFFFC0F0A.0 000050B34 		mov		$s1,$a0						; t1 = pointer to string
                        	.0001:
FFFFFFFFFFFC0F0E.8 00002D460 		ldb		$a0,[$s1]
FFFFFFFFFFFC0F13.0 00012CB04 		add		$s1,$s1,#1				; advance pointer to next byte
FFFFFFFFFFFC0F17.8 00405034E 		beq 	$a0,#0,.done     	; branch if done
FFFFFFFFFFFC0F1C.0 FFFBB6141 		call	Putch							; output character
FFFFFFFFFFFC0F20.8 FFFFF7041 		bra		.0001
                        	.done:
FFFFFFFFFFFC0F25.0 300079460 		ldo		$a0,[$sp]				  ; restore argument
FFFFFFFFFFFC0F29.8 300878B60 		ldo   $s1,8[$sp]
FFFFFFFFFFFC0F2E.0 001079E04 		add   $sp,$sp,#16
FFFFFFFFFFFC0F32.8 000004042 		ret

                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	  ; align cache
                        	DumpTraceQueue:
FFFFFFFFFFFC0F37.0 005801A04 		ldi     $a6,#'X'        ; bypass='B' in fputc routine
                        	.dmpTrace:
FFFFFFFFFFFC0F3B.8 000D01404 		ldi     $a0,#CR
FFFFFFFFFFFC0F40.0 FFFBA4141 		call    Putch
FFFFFFFFFFFC0F44.8 000E01504 		ldi     $a1,#14         ; processor trace queue status
FFFFFFFFFFFC0F49.0 14005547A 		peekq.  $a0,$a1
FFFFFFFFFFFC0F4D.8 007FFC548 		bmi     .dmpTraceEmpty  ; emptied out?
FFFFFFFFFFFC0F52.0 000F01504 		ldi     $a1,#15         ; processor trace queue data
FFFFFFFFFFFC0F56.8 000003FAA 		popq.   $a0,$a1
FFFFFFFFFFFC0F5B.0 FFFF7B541 		call    PutHexOcta
FFFFFFFFFFFC0F5F.8 FFFFEE041 		jmp     .dmpTrace
                        	.dmpTraceEmpty:
FFFFFFFFFFFC0F64.0 000D01404 		ldi     $a0,#CR
FFFFFFFFFFFC0F68.8 FFFB8FD41 		call    Putch
                        	.inf:
FFFFFFFFFFFC0F6D.0 000000041 	  jmp     .inf
FFFFFFFFFFFC0F71.8 000004042 	  ret

                        	;------------------------------------------------------------------------------
                        	; Exception processing code staret here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;
                        	; On incoming the register file has been set to the interrupt register file
                        	; or the machine mode register file.
                        	;------------------------------------------------------------------------------
FFFFFFFFFFFC0F76.0 000000000 	  align 16
FFFFFFFFFFFC0F7A.8 000000000 
FFFFFFFFFFFC0F7F.0 000000000 
                        	; Top of stack for different register sets
                        	StackTbl:
FFFFFFFFFFFC0F80.0 000000000 	  dw    $0
FFFFFFFFFFFC0F84.8 000000000 
FFFFFFFFFFFC0F84.0 000000000 	  dw    $0
FFFFFFFFFFFC0F88.8 000000000 
FFFFFFFFFFFC0F88.0 000000000 	  dw    $0
FFFFFFFFFFFC0F8C.8 000000000 
FFFFFFFFFFFC0F8C.0 000000000 	  dw    $0
FFFFFFFFFFFC0F90.8 000000000 
FFFFFFFFFFFC0F90.0 000000000 	  dw    $0
FFFFFFFFFFFC0F94.8 000000000 
FFFFFFFFFFFC0F94.0 000000000 	  dw    $0
FFFFFFFFFFFC0F98.8 000000000 
FFFFFFFFFFFC0F98.0 000000000 	  dw    $0
FFFFFFFFFFFC0F9C.8 000000000 
FFFFFFFFFFFC0F9C.0 000000000 	  dw    $0
FFFFFFFFFFFC0FA0.8 000000000 
FFFFFFFFFFFC0FA0.0 000000000 	  dw    $0
FFFFFFFFFFFC0FA4.8 000000000 
FFFFFFFFFFFC0FA4.0 000000000 	  dw    $0
FFFFFFFFFFFC0FA8.8 000000000 
FFFFFFFFFFFC0FA8.0 000000000 	  dw    $0
FFFFFFFFFFFC0FAC.8 000000000 
FFFFFFFFFFFC0FAC.0 000000000 	  dw    $0
FFFFFFFFFFFC0FB0.8 FC0000000 
FFFFFFFFFFFC0FB0.0 00007F3FC 	  dw    $7F400-4
FFFFFFFFFFFC0FB4.8 FC0000000 
FFFFFFFFFFFC0FB4.0 00007F7FC 	  dw    $7F800-4
FFFFFFFFFFFC0FB8.8 FC0000000 
FFFFFFFFFFFC0FB8.0 00007FBFC 	  dw    $7FC00-4
FFFFFFFFFFFC0FBC.8 FC0000000 
FFFFFFFFFFFC0FBC.0 00007FFFC 	  dw    $80000-4
FFFFFFFFFFFC0FC0.8 0F0000000 
                        	
                        	.file "any1_rom.r64",1236
                        		code
                        		align	16
                        	IRQRout:
FFFFFFFFFFFC0FC0.0 00D08030F 		csrrw	$t0,#$342,$x0			; get cause code
FFFFFFFFFFFC0FC4.8 16000C00C 		tst   $t0
FFFFFFFFFFFC0FC9.0 00000008F 
FFFFFFFFFFFC0FCD.8 007FFD348 		bmi	  .isIRQ		        ; irq or brk #240?
FFFFFFFFFFFC0FD2.0 000000300 		seq   $t0,#2            ; illegal instruction?
	bt    .illegal
FFFFFFFFFFFC0FD6.8 01FFFFF50 		and   $t2,$t0,#$FFFFFFFC
FFFFFFFFFFFC0FDB.0 FFFC0C508 
FFFFFFFFFFFC0FDF.8 000000500 		seq   $t2,#8
	bt    .brk
                        		; Some other cause
                        	.illegal:
FFFFFFFFFFFC0FE4.0 000000850 	  stt   $t0,$4018
FFFFFFFFFFFC0FE8.8 200301870 
FFFFFFFFFFFC0FED.0 10280400F 		csrrc $x0,#CSR_TRACECTRL,#1 ; turn off tracing
FFFFFFFFFFFC0FF1.8 FFFFF0350 		ldi   $t0,#DumpTraceQueue
FFFFFFFFFFFC0FF6.0 1E6E00304 
FFFFFFFFFFFC0FFA.8 00120C00F 		csrrw $x0,#CSR_MEPC,$t0
FFFFFFFFFFFC0FFF.0 000000045 		rte
.soc:
FFFFFFFFFFFC1003.8 000000041 	  jmp   .soc
                        	.brk:
                        	  ; We reset the stack pointer at each callto the OS in case an error causes
                        	  ; it to be messed up.
FFFFFFFFFFFC1008.0 0010C030F 	  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
FFFFFFFFFFFC100C.8 000F0C308 	  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
FFFFFFFFFFFC1011.0 02020C502 	  asl   $t2,$t0,#2        ; $t2 = table index
FFFFFFFFFFFC1015.8 FFFFF0350 		ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFFFFFFFFFC101A.0 2F0015E60 
FFFFFFFFFFFC101E.8 01F87E841 		jmp		OSECALL					  ; goto operating system calldispatcher
                        	.isIRQ:
FFFFFFFFFFFC1023.0 0010C030F 	  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
FFFFFFFFFFFC1027.8 000F0C308 	  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
FFFFFFFFFFFC102C.0 02020C502 	  asl   $t2,$t0,#2        ; $t2 = table index
FFFFFFFFFFFC1030.8 FFFFF0350 		ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFFFFFFFFFC1035.0 2F0015E60 
FFFFFFFFFFFC1039.8 00D08030F 		csrrw	$t0,#$342,$x0			; get cause code
                        	
FFFFFFFFFFFC103E.0 000000250 	  ldt   $t1,IRQFlag     ; update IRQ flag for Tiny Basic
FFFFFFFFFFFC1042.8 209000460 
FFFFFFFFFFFC1047.0 000110404 	  add   $t1,$t1,#1
FFFFFFFFFFFC104B.8 000000250 	  stt   $t1,IRQFlag
FFFFFFFFFFFC1050.0 210401070 
FFFFFFFFFFFC1054.8 00FF0C308 	  and   $t0,$t0,#$FF
FFFFFFFFFFFC1059.0 000000250 	  stt   $t0,IRQCause    ; update cause code for Tiny Basic
FFFFFFFFFFFC105D.8 210301870 
R2 operation needs two source operands. (2955)
R2 operation needs two source operandsFFFFFFFFFFFC1062.0 0A007DF02 	  sub.  $t1,$t0,#1
FFFFFFFFFFFC1066.8 1C747C05A 	  beq   $cr0,.softwareIrq
FFFFFFFFFFFC106B.0 A3FFC304E 
R2 operation needs two source operands. (2958)
R2 operation needs two source operandsFFFFFFFFFFFC106F.8 0A007DF02 	  sub.  $t1,$t1,#1
FFFFFFFFFFFC1074.0 1C747C05A 	  beq   $cr0,.timerIrq
FFFFFFFFFFFC1078.8 A3FFC2D4E 
R2 operation needs two source operands. (2961)
R2 operation needs two source operandsFFFFFFFFFFFC107D.0 0A007DF02 	  sub.  $t1,$t1,#1      ; garbage collect interrupt?
FFFFFFFFFFFC1081.8 1C747C05A 	  beq   $cr0,.gcIrq
FFFFFFFFFFFC1086.0 A3FFC2A4E 
FFFFFFFFFFFC108A.8 001F0C708 		and		$t4,$t0,#31			; interrupting device # is low order 5 bits of cause code
FFFFFFFFFFFC108F.0 000500604 		ldi   $t3,#5          ; try 5 times
                        	.devAgain:
FFFFFFFFFFFC1093.8 00001C834 		mov   $t5,$t4
FFFFFFFFFFFC1098.0 020720802 		asl		$t5,$t5,#7				; 128 bytes per device func table
FFFFFFFFFFFC109C.8 205820804 		add		$t5,$t5,#DVF_Base+22*4	; load IRQ routine vector from device func table
FFFFFFFFFFFC10A1.0 300020860 		ldo.	$t5,[$t5]
FFFFFFFFFFFC10A5.8 1C747C05A 		beq	  $cr0,.noIRQ	    ; make sure there's an address to go to
FFFFFFFFFFFC10AA.0 A3FFC224E 
FFFFFFFFFFFC10AE.8 000023234 		mov   $cn,$t5
FFFFFFFFFFFC10B3.0 000000042 		jmp		[$cn]						; jump to the IRQ routine
                        	.noIRQ:
R2 operation needs two source operands. (2987)
R2 operation needs two source operandsFFFFFFFFFFFC10B7.8 0A007DF02 	  sub.  $t3,$t3,#1
FFFFFFFFFFFC10BC.0 007FC024F 	  bne   $cr0,.InitDev
                        	.softwareIrq:
                        	.timerIrq:
FFFFFFFFFFFC10C0.8 00003CC41 	  jmp   ERETx2
                        		; The device function tables may have been zeroed out, try initializing them.
                        		; The following uses $a0-$a1, $t0-$t2
                        	.InitDev:
FFFFFFFFFFFC10C5.0 000000700 		seq   $t4,#5
	bf    .notSerial
FFFFFFFFFFFC10C9.8 000501404 		ldi		$a0,#5							; serial device
FFFFFFFFFFFC10CE.0 000000050 		ldi		$a1,#SerialFuncTbl
FFFFFFFFFFFC10D2.8 F00000051 
FFFFFFFFFFFC10D7.0 024301504 
FFFFFFFFFFFC10DB.8 01F823541 		jal	  CopyDevFuncTbl
FFFFFFFFFFFC10E0.0 000501404 		ldi		$a0,#5							; serial device
FFFFFFFFFFFC10E4.8 000000050 		ldi   $a1,#SerialDCB
FFFFFFFFFFFC10E9.0 F00000051 
FFFFFFFFFFFC10ED.8 024501504 
FFFFFFFFFFFC10F2.0 01F818941 		jal   CopyDevDCB
FFFFFFFFFFFC10F6.8 01F816841 		jmp   .devAgain
                        	.notSerial:
FFFFFFFFFFFC10FB.0 000F01404 		ldi		$a0,#15							; VIA device
FFFFFFFFFFFC10FF.8 000050700 		seq   $t4,$a0
	bf    .notVia
FFFFFFFFFFFC1104.0 000000050 		ldi		$a1,#ViaFuncTbl
FFFFFFFFFFFC1108.8 F00000051 
FFFFFFFFFFFC110D.0 024901504 
FFFFFFFFFFFC1111.8 01F808541 		jal	  CopyDevFuncTbl
FFFFFFFFFFFC1116.0 000F01404 		ldi		$a0,#15							; VIA device
FFFFFFFFFFFC111A.8 000000050 		ldi		$a1,#ViaDCB
FFFFFFFFFFFC111F.0 F00000051 
FFFFFFFFFFFC1123.8 024A01504 
FFFFFFFFFFFC1128.0 01F7FD941 		jal	  CopyDevDCB
FFFFFFFFFFFC112C.8 01F7FB841 		jmp   .devAgain
                        	.notVia:
FFFFFFFFFFFC1131.0 000004841 	  jmp   ERETx2
                        	.gcIrq:
                        	;	ldi		$sp,#$7F800-4		; setup interrupt mode stack pointer
FFFFFFFFFFFC1135.8 01F7F8941 	  call gcIncrement
                        	ERETx2:
                        	;  mDI
                        	;  csrrc $x0,#$7C0,#31   ; select machine regs only
                        	;  csrrw $t0,#$7C0,$x0   ; get register sets
                        	;  srl   $t0,$t0,#5      ; extract register set selection
                        	;  sll   $t0,$t0,#3
                        	;  ldt   $t1,MEPC0[$t0]  ; get it
                        	;  csrrw $x0,#$341,$t1   ; set mepc
                        	  
FFFFFFFFFFFC113A.0 00100400F 	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFFFFFFFFFC113E.8 000000079 	nop
FFFFFFFFFFFC1143.0 000000079 	  nop
FFFFFFFFFFFC1147.8 0010C030F 	  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
FFFFFFFFFFFC114C.0 000F0C308 	  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
FFFFFFFFFFFC1150.8 02020C502 	  asl   $t2,$t0,#2        ; $t2 = table index
FFFFFFFFFFFC1155.0 FFFFF0350 		ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFFFFFFFFFC1159.8 2F0015E60 
FFFFFFFFFFFC115E.0 000000045 		rte

                        		; In case the pipeline runs ahead into the following table which will
                        		; result in illegal instructions.
FFFFFFFFFFFC1162.8 000000079 		nop
FFFFFFFFFFFC1167.0 000000079 		nop
FFFFFFFFFFFC116B.8 000000079 	  nop
                        	
                        	  ; align cache
                        	DBGRout:
FFFFFFFFFFFC1170.0 00000300D 	  rex   #3,x0
  rte
	nop
FFFFFFFFFFFC1174.8 000000079 
FFFFFFFFFFFC1179.0 000000079 		nop
FFFFFFFFFFFC117D.8 000000079 	  nop
                        	
                        	; Application startup record for system
                        	SystemASR:
FFFFFFFFFFFC1182.0 000000000 	  db    0     ; page size (can't change on this system)
  db    2     ; priority normal
  db    12    ; register set for startup task
  db    0     ; memory map #0
  dw    0     ; processor affinity
FFFFFFFFFFFC1186.8 000000000 
FFFFFFFFFFFC1186.0 000000000 	  dw    0     ; code size (0 = in ROM, don't move)
FFFFFFFFFFFC118A.8 000000000 
FFFFFFFFFFFC118A.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC118E.8 000000000 
FFFFFFFFFFFC118E.0 000000000 	  dw    0     ; data size (preinitialized data)
FFFFFFFFFFFC1192.8 000000000 
FFFFFFFFFFFC1192.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC1196.8 000000000 
FFFFFFFFFFFC1196.0 000000000 	  dw    0     ; uninitialized data size
FFFFFFFFFFFC119A.8 000000000 
FFFFFFFFFFFC119A.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC119E.8 000000000 
FFFFFFFFFFFC119E.0 000000000 	  dw    0     ; Heap size
FFFFFFFFFFFC11A2.8 000000000 
FFFFFFFFFFFC11A2.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC11A6.8 000000000 
FFFFFFFFFFFC11A6.0 000000400 	  dw    1024  ; stack size
FFFFFFFFFFFC11AA.8 000000000 
FFFFFFFFFFFC11AA.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC11AE.8 FE0000000 
FFFFFFFFFFFC11AE.0 FFFF80AFE 	  dw    IdleTask  ; pointer to code
FFFFFFFFFFFC11B2.8 00FFFFFFF 
FFFFFFFFFFFC11B2.0 000000000 	  dw    0       ; reserved
FFFFFFFFFFFC11B6.8 000000000 
FFFFFFFFFFFC11B6.0 000000000 	  dw    0     ; pointer to data
FFFFFFFFFFFC11BA.8 000000000 
FFFFFFFFFFFC11BA.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC11BE.8 000000000 
FFFFFFFFFFFC11BE.0 000000000 	  dw    0     ; ui data
FFFFFFFFFFFC11C2.8 000000000 
FFFFFFFFFFFC11C2.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC11C6.8 000000000 
                        	
                        	; Application startup record for Tiny Basic
                        	TinyBasicASR:
FFFFFFFFFFFC11C6.0 000000000 	  db    0     ; page size (can't change on this system)
  db    2     ; priority normal
  db    0     ; register set
  db    1     ; memory map
  dw    0     ; processor affinity
FFFFFFFFFFFC11CA.8 000000000 
FFFFFFFFFFFC11CA.0 000000000 	  dw    0     ; code size (0 = in ROM, don't move)
FFFFFFFFFFFC11CE.8 000000000 
FFFFFFFFFFFC11CE.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC11D2.8 000000000 
FFFFFFFFFFFC11D2.0 000000000 	  dw    0     ; data size (preinitialized data)
FFFFFFFFFFFC11D6.8 000000000 
FFFFFFFFFFFC11D6.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC11DA.8 000000000 
FFFFFFFFFFFC11DA.0 000008000 	  dw    32768 ; uninitialized data size
FFFFFFFFFFFC11DE.8 000000000 
FFFFFFFFFFFC11DE.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC11E2.8 000000000 
FFFFFFFFFFFC11E2.0 000000000 	  dw    0     ; Heap size
FFFFFFFFFFFC11E6.8 000000000 
FFFFFFFFFFFC11E6.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC11EA.8 000000000 
FFFFFFFFFFFC11EA.0 000000800 	  dw    2048  ; stack size
FFFFFFFFFFFC11EE.8 000000000 
FFFFFFFFFFFC11EE.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC11F2.8 F20000000 
FFFFFFFFFFFC11F2.0 0000001F2 	  dw    CSTART  ; pointer to code
FFFFFFFFFFFC11F6.8 008000000 
FFFFFFFFFFFC11F6.0 000000000 	  dw    0       ; reserved
FFFFFFFFFFFC11FA.8 000000000 
FFFFFFFFFFFC11FA.0 000000000 	  dw    0     ; pointer to data
FFFFFFFFFFFC11FE.8 000000000 
FFFFFFFFFFFC11FE.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC1202.8 000000000 
FFFFFFFFFFFC1202.0 000000000 	  dw    0     ; ui data
FFFFFFFFFFFC1206.8 000000000 
FFFFFFFFFFFC1206.0 000000000 	  dw    0     ; reserved
FFFFFFFFFFFC120A.8 000000000 
                        	    
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
                        			db		"Femtiki System Starting.",10
msgMonHelp:
                        			db		"Monitor Commands",10
		db		"B - start tiny basic",10
		db		"D - dump ready que",10
		db		"E - edit memory",10
		db		"F - fill memory",10
		db    "FI <string>- find string in memory",10
		db		"K <tid> - kill task", 10
		db		"M <start> <length>	- dump memory",10
		db    "P - display PAM",10
		db		"S - switch task",10
		db    "V <mid> dump virtual memory map",10
		db		0
		; align cache
                        	msgTaskStart:
                        			db		" task started."
msgCRLF:
                        			db		13,10,0
flt50:
FFFFFFFFFFFC120A.0 000000000 		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFFFFFFFFFC120E.8 000000000 
FFFFFFFFFFFC1213.0 000000000 
FFFFFFFFFFFC1217.8 000000000 
FFFFFFFFFFFC121C.0 000000000 
FFFFFFFFFFFC1220.8 049000000 
FFFFFFFFFFFC1225.0 000000040 
FFFFFFFFFFFC1229.8 000000000 
                        	flt20:
FFFFFFFFFFFC121A.0 000000000 		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFFFFFFFFFC121E.8 000000000 
FFFFFFFFFFFC1223.0 000000000 
FFFFFFFFFFFC1227.8 000000000 
FFFFFFFFFFFC122C.0 000000000 
FFFFFFFFFFFC1230.8 034000000 
FFFFFFFFFFFC1235.0 000000040 
FFFFFFFFFFFC1239.8 000000000 
                        	flt10:
FFFFFFFFFFFC122A.0 000000000 		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFFFFFFFFFC122E.8 000000000 
FFFFFFFFFFFC1233.0 000000000 
FFFFFFFFFFFC1237.8 000000000 
FFFFFFFFFFFC123C.0 000000000 
FFFFFFFFFFFC1240.8 024000000 
FFFFFFFFFFFC1245.0 000000040 
FFFFFFFFFFFC1249.8 000000000 
                        	
                        	;.include "fltToString.r64"
                        	;.include "bios-mem.r64"
                        	;.include "bios-pam.r64"
                        	;.include "bios-tlb.r64"
                        	;.include "ramtest.r64"
                        	
                        	;.include "../fmtk/msg.r64"
                        	;.include "../fmtk/tcb.r64"
                        	;.include "../fmtk/task.r64"
                        	;.include "../fmtk/io.r64"
                        	;.include "../fmtk/iofocus.r64"
                        	;.include "../fmtk/serial.r64"
                        	;.include "../fmtk/source/drivers/pti_driver.r64"
                        	;.include "../fmtk/app.r64"
                        	;.include "../fmtk/Finalizer.r64"
                        	;.include "../fmtk/gcIncremental.r64"
                        	;.include "../fmtk/source/kernel/fmtk.r64"
                        	;.include "../fmtk/source/kernel/FMTKc.r64"
                        	;.include "../fmtk/source/kernel/SetupDevices.r64"
                        	;.include "../fmtk/source/kernel/pic.r64"
                        	;.include "../fmtk/source/kernel/DBGConsole.r64"
                        	;.include "../fmtk/source/fmtk.l64"
                        	;.include "../fmtk/finalizer.r64"
                        	;.include "../fmtk/gcIncremental.r64"
                        	;.include "TinyBasic.r64"
                        	;.include "../cc64libc/source/rtf64/io.r64"
                        	;.include "../cc64libc/source/cc64libc.l64"
                        	;.include "../c_standard_lib-master/c_standard_lib-master/c_standard_lib.l64"
                        	.file "any1_rom.r64",1
                        	.file "any1_rom.r64",1
                        	
                        		rodata
                        		align 8
                        	__rodata_start:
                        	
                        		rodata
                        		align 8
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8
                        	end_init_data:
                        	_end_init_data:

rodata start: FFFFFFFFFFF84000
data start:                0
bss start:                0

598 symbols
  Symbol Name                              seg     address bits references
  CR                                        const  000006.1 0 5
  CSR_MEPC                                  const  001824.0 0 15
  CSR_MSEMA                                 const  001860.1 0 15
  CSR_PMSTACK                               const  001820.0 0 15
  CSR_REGSET                                const  002809.0 0 16
  CSR_RSSTACK                               const  001821.1 0 15
  CSR_TASKID                                const  000808.0 0 14
  CSR_TRACECTRL                             const  003850.0 0 16
  CSTART                                     code  c0000000000000f9.0 0 32
  CURIN                                     const  0001b8.0 0 11
  CUROUT                                    const  0001b8.1 0 11
  CheckDevOwner                              code  c0000000000000eb.1 0 32
  DBGATTR                                   const  1fffff060df8000.0 0 59
  DBGRout                                    code  fffffffffffc1170.0 0 18
  DVF_Base                                  const  001000.0 0 15
  DumpReadyQueue                             code  c0000000000000d8.1 0 32
  DumpTimeoutList                            code  c0000000000000fa.0 0 32
  DumpTraceQueue                             code  fffffffffffc0f37.0 0 18
  DumpTraceQueue.dmpTrace                    code  fffffffffffc0f3b.1 0 18
  DumpTraceQueue.dmpTraceEmpty               code  fffffffffffc0f64.0 0 18
  DumpTraceQueue.inf                         code  fffffffffffc0f6d.0 0 18
  EOF                                       const  00000d.0 0 6
  E_Ok                                      const  000000.0 0 1
  FillMem                                    code  fffffffffffc0caf.0 0 18
  FillMem.0001                               code  fffffffffffc0cce.1 0 18
  Finalizer                                  code  c0000000000000d5.0 0 32
  Find                                       code  fffffffffffc0ce5.0 0 18
  Find.found                                 code  fffffffffffc0d75.0 0 18
  Find.fwe                                   code  fffffffffffc0d00.0 0 18
  Find.loop                                  code  fffffffffffc0d28.1 0 18
  Find.next                                  code  fffffffffffc0d51.0 0 18
  Find.notFound                              code  fffffffffffc0d82.1 0 18
  GetDecNum.next                             code  fffffffffffc0e24.1 0 18
  GetHexNum                                  code  fffffffffffc0daf.1 0 18
  GetHexNum.next                             code  fffffffffffc0db8.1 0 18
  GetUIFlag                                  code  c0000000000000e9.1 0 32
  Getch                                      code  fffffffffffc0664.0 0 18
  INBUF                                     const  000080.0 0 10
  IRQCause                                  const  00084c.0 0 14
  IRQFlag                                   const  000848.0 0 14
  IRQRout                                    code  fffffffffffc0fc0.0 0 18
  IRQRout.gcIrq                              code  c00000000000011d.0 0 32
  IRQRout.isIRQ                              code  fffffffffffc1023.0 0 18
  IRQRout.noIRQ                              code  c00000000000011e.0 0 32
  IRQRout.soc                                code  fffffffffffc1003.1 0 18
  IRQRout.softwareIrq                        code  c00000000000011c.0 0 32
  IRQRout.timerIrq                           code  c00000000000011c.1 0 32
  IdleTask                                   code  fffffffffffc057f.0 0 18
  IdleTask.IdleCode                          code  fffffffffffc05eb.0 0 18
  IdleTask.loop                              code  fffffffffffc059e.1 0 18
  IdleTask.loop2                             code  fffffffffffc0595.1 0 18
  IdleTask.nxtObj                            code  fffffffffffc0633.0 0 18
  IdleTaskMbx                               const  000608.0 0 13
  IdleTaskMsgD1                             const  00060c.0 0 13
  IdleTaskMsgD2                             const  000610.0 0 13
  IdleTaskMsgD3                             const  000614.0 0 13
  LEDS                                      const  ffffffffffc88000.0 0 24
  LNFD                                      const  000005.0 0 5
  LOG_PGSZ                                  const  000006.0 0 5
  LOG_TCBSZ                                 const  000005.0 0 5
  MBX_BLOCKPTR_BUFSZ                        const  000004.0 0 5
  MEMSZ                                     const  010000.0 0 19
  MEPC1                                     const  0001ac.0 0 11
  MMUInit                                    code  c0000000000000d0.0 0 32
  MachineStart                               code  fffffffffffc0300.0 0 18
  MachineStart.0001                          code  fffffffffffc0367.1 0 18
  MbxBlockPtr                               const  000850.0 0 14
  Monitor                                    code  fffffffffffc0922.0 0 18
  Monitor.0001                               code  fffffffffffc092b.0 0 18
  Monitor.0005                               code  fffffffffffc0b11.0 0 18
  Monitor.basSize                            code  fffffffffffc0a19.1 0 18
  Monitor.skip                               code  fffffffffffc09c8.1 0 18
  OBJMagic                                  const  000000.0 0 1
  OSECALL                                    code  c00000000000011b.1 0 32
  OSExit                                     code  c0000000000000dd.0 0 32
  OSOCall                                    code  c0000000000000d2.1 0 32
  PAGESZ                                    const  000800.0 0 14
  PutHexByte                                 code  fffffffffffc0e7a.0 0 18
  PutHexNybble                               code  fffffffffffc0e87.1 0 18
  PutHexOcta                                 code  fffffffffffc0e51.1 0 18
  PutHexTetra                                code  fffffffffffc0e5f.0 0 18
  PutHexWyde                                 code  fffffffffffc0e6c.1 0 18
  PutInlineString                            code  fffffffffffc0ec2.0 0 18
  PutInlineString.0001                       code  fffffffffffc0ed8.1 0 18
  PutInlineString.done                       code  fffffffffffc0eef.0 0 18
  PutString.0001                             code  fffffffffffc0f0e.1 0 18
  PutString.done                             code  fffffffffffc0f25.0 0 18
  Putch                                      code  fffffffffffc0688.0 0 18
  ROMBASE                                   const  fffffffffffe0000.0 0 20
  SCRATCHMEM                                const  ffffffffffa00000.0 0 25
  SerialPutChar                              code  c0000000000000e8.0 0 32
  SkipSpaces                                 code  fffffffffffc0d99.0 0 18
  SkipSpaces.skip2                           code  fffffffffffc0d99.0 0 18
  StackTbl                                   code  fffffffffffc0f80.0 0 18
  SystemASR                                  code  fffffffffffc1182.0 0 18
  TBASR                                      code  c0000000000000f7.0 0 32
  TCBPriority                               const  000170.1 0 11
  TCBStatus                                 const  000170.0 0 11
  TCB_MAGIC                                 const  102a21a1.0 0 31
  TS_READY                                  const  000000.1 0 2
  TinyBasicASR                               code  fffffffffffc11c6.0 0 18
  UserStart                                  code  fffffffffffc047a.0 0 18
  UserStart2                                 code  fffffffffffc0483.0 0 18
  UserStart2.appBad                          code  fffffffffffc0495.0 0 18
  WaitForIOFocus                             code  c0000000000000ea.1 0 32
  _DBGAttr                                  const  ffffffffffa00000.0 0 25
  _Delay2s                                   code  fffffffffffc0640.0 0 18
  _Delay2s.0001                              code  fffffffffffc0649.0 0 18
  _FMTKInit                                  code  c0000000000000d0.1 0 32
  _InitPIC                                   code  c0000000000000d1.0 0 32
  _cursorX                                  const  ffffffffffa00004.0 0 25
  _cursorY                                  const  ffffffffffa00004.1 0 25
  _pti_init                                  code  c0000000000000cf.0 0 32
  _pti_read_block                            code  c0000000000000cf.1 0 32
  calcScreenPos                              code  fffffffffffc06b9.1 0 18
  calcScreenPos.0001                         code  fffffffffffc06ef.1 0 18
  calcScreenPos.0002                         code  fffffffffffc06c7.0 0 18
  calcScreenPos.0003                         code  fffffffffffc0701.1 0 18
  calcScreenPos.0004                         code  fffffffffffc06d9.0 0 18
  dbg_HomeCursor                             code  fffffffffffc080f.1 0 18
  dbg_Putch                                  code  fffffffffffc0764.1 0 18
  dbg_Putch.cr                               code  fffffffffffc07b1.0 0 18
  dbg_Putch.lf                               code  fffffffffffc0788.1 0 18
  dbg_ScrollUp                               code  fffffffffffc07be.1 0 18
  dbg_ScrollUp.0001                          code  fffffffffffc07cc.0 0 18
  fgetc                                      code  fffffffffffc08a4.0 0 18
  fgetc.0001                                 code  fffffffffffc08e7.1 0 18
  fgetc.0002                                 code  fffffffffffc08fe.0 0 18
  fgetc.checkOwner                           code  fffffffffffc08d1.0 0 18
  fgetc.notOwner                             code  fffffffffffc0910.0 0 18
  fputc                                      code  fffffffffffc0826.0 0 18
  fputc.0001                                 code  fffffffffffc0872.1 0 18
  fputc.checkOwner                           code  fffffffffffc0860.1 0 18
  fputc.notOwner                             code  fffffffffffc089b.0 0 18
  fputc.xit                                  code  fffffffffffc0889.0 0 18
  incScreenPos                               code  fffffffffffc0713.1 0 18
  incScreenPos.0001                          code  fffffffffffc0757.0 0 18
  incScreenPos.0002                          code  fffffffffffc0749.1 0 18
  msgCRLF                                    code  fffffffffffc120a.0 0 18
  msgMonHelp                                 code  fffffffffffc120a.0 0 18
  msgTaskStart                               code  fffffffffffc120a.0 0 18
  x0                                         code  c000000000000127.0 0 32

Undefined Symbols
  CSTART                                     code  80000000000001f2 32 2
  CheckDevOwner                              code  80000000000001d7 32 2
  DumpReadyQueue                             code  80000000000001b1 32 3
  DumpTimeoutList                            code  80000000000001f4 32 1
  Finalizer                                  code  80000000000001aa 32 1
  GetUIFlag                                  code  80000000000001d3 32 2
  IRQRout.gcIrq                              code  800000000000023a 32 1
  IRQRout.noIRQ                              code  800000000000023c 32 1
  IRQRout.softwareIrq                        code  8000000000000238 32 1
  IRQRout.timerIrq                           code  8000000000000239 32 1
  MMUInit                                    code  80000000000001a0 32 1
  OSECALL                                    code  8000000000000237 32 1
  OSExit                                     code  80000000000001ba 32 2
  OSOCall                                    code  80000000000001a5 32 1
  SerialPutChar                              code  80000000000001d0 32 1
  TBASR                                      code  80000000000001ee 32 1
  WaitForIOFocus                             code  80000000000001d5 32 2
  _FMTKInit                                  code  80000000000001a1 32 1
  _InitPIC                                   code  80000000000001a2 32 1
  _pti_init                                  code  800000000000019e 32 1
  _pti_read_block                            code  800000000000019f 32 1
  x0                                         code  800000000000024e 32 1

  Macro Name
0 compressable instructions
The top 1024 are:
Comp  Opcode  Count

Instruction Statistics
Loads:         0 (0.000000%)
Stores:        0 (0.000000%)
  Indexed:     0 (0.000000%)
Pushes:        0 (0.000000%)
Compares:      0 (0.000000%)
Branches:     33 (4.039168%)
BEQZ/NEZ:	     0 (0.000000%)
  BEQI:		     0 (0.000000%)
  BNEI:		     0 (0.000000%)
  BBc:		     0 (0.000000%)
  BLcc:		     0 (0.000000%)
Calls:		    21 (2.570379%)
Returns:	     4 (0.489596%)
Adds:	       202 (24.724602%)
Subs:	         0 (0.000000%)
Ands:	         9 (1.101591%)
Ors:	         2 (0.244798%)
Xors:	         0 (0.000000%)
Bits:	         0 (0.000000%)
Tsts:	         0 (0.000000%)
Lshifts:       0 (0.000000%)
shifts:	       0 (0.000000%)
Luis:	         0 (0.000000%)
Moves:	       0 (0.000000%)
CMoves:	       0 (0.000000%)
Sets:	        18 (2.203182%)
  Mops:        0 (0.000000%)
Ptrdif:        0 (0.000000%)
Bitfield:      0 (0.000000%)
Csr:		      25 (3.059976%)
Floatops:      0 (0.000000%)
others:      528 (64.626683%)
Total:       817

number of bytes: 3676.500000
number of instructions: 817
number of compressed instructions: 0
4.500000 bytes (36 bits) per instruction
Compression ratio: 0.000000%
Number of long branches: 0
