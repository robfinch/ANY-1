.include "../fmtk/const.r64"
.include "../fmtk/types.r64"
.include "../fmtk/config.r64"
.include "../fmtk/device.r64"
.include "../fmtk/macro.r64"
.include "../fmtk/globals.r64"

TEST  equ   1

CTRLC				equ		$03
CTRLT       equ   $14
BS					equ		$08
LNFD  			equ		$0A
CR					equ		$0D
XON					equ		$11
XOFF				equ		$13
EOF         equ   $1A
DEL					equ		$7F
VIA					equ		$FFFFFFFFFF910000
VIA_PA			equ		$04
VIA_DDRA		equ		$0C
VIA_T1CL		equ		$10
VIA_T1CH		equ		$14
VIA_T2CL    equ   $20
VIA_T2CH    equ   $24
VIA_ACR			equ		$2C
VIA_PCR			equ		$30
VIA_IFR			equ		$34
VIA_IER			equ		$38
VIA_PARAW		equ		$3C
UART				equ		$FFFFFFFFFF930000
UART_TRB		equ		$00
UART_STAT		equ		$04
UART_CMD		equ		$08

CSR_UIE     	equ   $004
CSR_DCAUSE		equ		$4006
CSR_DSCRATCH	equ		$4041
CSR_DSTUFF0		equ		$4042
CSR_DSTUFF1		equ		$4043
CSR_DESTEP		equ		$4046
CSR_DEIP			equ		$4048
CSR_DGDT			equ		$4051
CSR_DSP				equ		$4060
FLT_WD				equ		$36

CODEBASE	equ		$00000005
;RODATABASE	equ	$FFFF003C
RODATABASE	equ	$0000003C
IOBASE		equ		$FF800036
STACKBASE	equ		$00000006
DATABASE	equ		$00000006

SEMAPHORES	equ	$FF8D0000
ROMADDR		equ		$FFFC0000*2
TEXTSCR		equ		$0100000000000000
KEYBD			equ		$01000000000E0000
LEDS			equ		$0100000000110000
BUTTONS		equ		$0100000000110000
xbLEDS		equ		$0100000000DC0600
xbBridge1 equ   $0100000000DCF010
SCRATCHPAD	equ		$00000000FF400000	; 0100000001_00000000000000
SCRATCHMEM	equ		$00000000FF400000

;	section	scratchpad	at	$FFFFFFFFFF400000
OS_STACK		equ		SCRATCHPAD+$A000
;DBGATTR   equ   $0000FFFF000F0000   ; white on blue, priority $40
DBGATTR   equ   %000000_111111111111111111111_000001100000110111111_0000000000000000
_DBGAttr  equ		SCRATCHPAD
_cursorX  equ		_DBGAttr + 8
_cursorY  equ		_cursorX + 1

	code	18 bits
;------------------------------------------------------------------------------
; Exception vector table.
;------------------------------------------------------------------------------
{+
	org		ROMADDR
start:
_rombase:
_ExceptionTable():
	bra		DBGRout
	org 	ROMADDR+$60*2				; machine mode exception
	bra		DBGRout
	org 	ROMADDR+$80*2				; debug mode exception
	bra		DBGRout
	org		ROMADDR+$F2*2			; non-maskable interrupt
	bra		MachineStart    ; cannot use a jump here, takes too much room

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
	org		ROMADDR+$100*2
	bra		IRQRout
	org 	ROMADDR+$1C0*2		; machine mode exception
	bra		IRQRout
	org		ROMADDR+$1F2*2		; non-maskable interrupt
	bra		MachineStart    ; cannot use a jump here, takes too much room

	org		ROMADDR+$200*2
	bra		IRQRout
	org 	ROMADDR+$2C0*2		; machine mode exception
	bra		IRQRout
	org		ROMADDR+$2F2*2		; non-maskable interrupt
	bra		MachineStart    ; cannot use a jump here, takes too much room
..
;------------------------------------------------------------------------------
; Reset starting address.
; CS:IP is set to point here on reset.
;------------------------------------------------------------------------------
	org		ROMADDR+$300*2
MachineStart .proc
  ; Map 16kB GDT area
	ldi			$t0,#$8000000000000C00	; entry number = $000, way = 3, write = true
	ldi			$t1,#$008E000000000000
	tlbrw		$x0,$t0,$t1
	ldi			$t0,#$8000000000000C04	; entry number = $004, way = 3, write = true
	ldi			$t1,#$008E000000000004
	tlbrw		$x0,$t0,$t1
	; Setup segments, codeseg already set at reset.
	; set data segment
	csrrd	$a2,#CSR_DGDT
	and		$a2,$a2,#-256
	ldi		$a1,#$000000000000003E	; 0MB boundary
	sto		$a1,0000*16[$a2]
	ldi		$a1,#$FFFFFFFFFFFFFFC4	; All - debug mode only
	sto		$a1,0000*16+8[$a2]
	ldi		$a0,#000
	ldi		$a1,#$80000
	mtsel	[$a0],$a1
	; set stack segment
	ldi		$a1,#$FF40C03E	; last 4kB of scratchpad
	sto		$a1,003*16[$a2]
	ldi		$a1,#$0000000000000FC4	; 4kB
	sto		$a1,003*16+8[$a2]
	ldi		$a0,#003						; App#3 SS
	ldi		$a1,#$80003					; App#3 SS
	mtsel	[$a0],$a1
	; set io segment
	ldi		$a1,#IOBASE
	sto		$a1,004*16[$a2]
	ldi		$a1,#$00000000007FFFC4	; 8MB
	sto		$a1,004*16+8[$a2]
	ldi		$a0,#004
	ldi		$a1,#$80004
	mtsel	[$a0],$a1
	; set read-only segment
	ldi		$a1,#RODATABASE					;
	sto		$a1,005*16[$a2]
;	ldi		$a1,#$000000000000FFC4	; 64kB
	ldi		$a1,#$FFFFFFFFFFFFFFC4
	sto		$a1,005*16+8[$a2]
	ldi		$a0,#005
	ldi		$a1,#$80005
	mtsel	[$a0],$a1
	sync

  ; Map 64kB scratchpad stack area into stack segment
	ldi			$t0,#$8000000000000D00	; entry number = $100, way = 3, write = true
	ldi			$t1,#$008E000FF003FD00
	tlbrw		$x0,$t0,$t1
	add			$t0,$t0,#1						; map next 16kB
	add			$t1,$t1,#1						; map next 16kB
	tlbrw		$x0,$t0,$t1
	add			$t0,$t0,#1						; map next 16kB
	add			$t1,$t1,#1						; map next 16kB
	tlbrw		$x0,$t0,$t1
	add			$t0,$t0,#1						; map next 16kB
	add			$t1,$t1,#1						; map next 16kB
	tlbrw		$x0,$t0,$t1

	; Map LEDS
	ldi			$t0,#$8000000000000E44	; entry number = $244, way = 3, write = true
	ldi			$t1,#$008E000FF003FE44
	tlbrw		$x0,$t0,$t1

	; Map text screen - first 16kB
	ldi			$t0,#$8000000000000E00	; entry number = $200, way = 3, write = true
	ldi			$t1,#$008E000FF003FE00	
	tlbrw		$x0,$t0,$t1

	; Setup debug mode stack pointer. The debug stack is set to a high order
	; address in the scratchpad memory area.
	base	$sp,$sp,#003						; but setting base this way is safer
	or		$sp,$sp,#$0FF8		  		; could also load the $sp with $00C0000000000FF8
	csrrw	$x0,#CSR_DSP,$sp				; update debug sp
	
;  ldi   $t1,#$81
;  sto   $t1,xbBridge1
	base	$x29,$x29,#003					; associate with stack segment (ss or $b003)
	base	$gp1,$gp1,#005
;	stm		[$x29],#%111111111111111111111111111111
;	stm		[$x29],#%01111
  ldi   $t0,#$AA
  stb   $t0,LEDS
  ldi   $a0,#$AA
  stb   $a0,LEDS
;	ldm		[$x29],#%01111
	lea		$a0,msgStart[$gp1]

	sub 	$sp,$sp,#16
	ldi		$t0,#$FF406000
	csrrw	$x0,#CSR_DTCBPTR,$t0				; set TCB pointer
	ldi   $a0,#10
	ldi   $a1,#0
	bal   $x1,_Delay2s
	bal   $x1,dbg_HomeCursor
	ldi		$a1,#DBGATTR		  	; set zorder $40, white text, blue background
	sto		$a1,_DBGAttr				; uses $b0 which was set to SCRATCHPAD
  ; clear debug screen
  ldo   $a0,_DBGAttr
  ldi   $t0,#TEXTSCR
ifdef TEST
  ldi   $t1,#6
else
  ldi   $t1,#56*29
endif
.0001:
  sub   $t1,$t1,#1
  sto   $a0,[$t0+$t1*8]
  bne   $t1,$x0,.0001
	ldi		$a1,#DBGATTR|$41
	sto		$a1,[$t0]
	sto		$a1,8[$t0]
	sto		$a1,16[$t0]
	sto		$a1,24[$t0]

;  ldi   $a0,#msgStart
  ;call  PutHexTetra
  lea   $a0,msgStart[$gp1]
  bal   $x1,PutString

;  call  _ramtest2
;	csrrs $x0,#CSR_TRACECTRL,#1 ; turn on tracing
  bal   $x1,_pti_init
  ldi   $a1,#$80000
  ldi   $a0,#$200000
  bal   $x1,_pti_read_block

	bal   $x1,MMUInit					; initialize MMU for address space zero.
	bal   $x1,_FMTKInit
	;call  ViaSetup
;	call  _SerialInit
	bal   $x1,_InitPIC
	ldi   $t0,#5          ; set current input and output to serial port
	stb   $t0,CURIN
	stb   $t0,CUROUT
	ldi		$t0,#0
	csrrw $x0,#CSR_MSEMA,$t0  ; turn off semaphores
	csrrw	$x0,#$181,$t0		    ; set ASID
	csrrw $x0,#CSR_TASKID,$t0 ; clear task id
	ldi		$t0,#$FFFFFFFFFFFC0000*2
	csrrw $x0,#$4034,$t0		; set tvec for debug mode
	ldi		$t0,#$FFFFFFFFFFFC0200*2
	csrrw $x0,#$4033,$t0		; set tvec for machine mode
	ldi		$t0,#UserStart
	csrrw	$x0,#$4048,$t0	  ; set mepc
	sto   $t0,MEPC1
  ldi   $a0,#1            ; start task
  ldi   $a1,#0
  ldi   $a2,#0
  ldi   $a3,#UserStart2
  ldi   $a4,#$00
  bal   $x1,OSOCall
  csrrw $x0,#CSR_TASKID,$a1
  csrrs $x0,#CSR_PMSTACK,#16 ; enable interrupts on return
	csrrc $x0,#CSR_TRACECTRL,#0 ; turn off tracing
	rte                       ; switch to user mode
.endp MachineStart

;------------------------------------------------------------------------------
; User mode code staret here
; First thing to do is start a task so that the startup code may run on the
; first task switch.
;------------------------------------------------------------------------------
;  align 	code
UserStart():
  bal  	$x1,DumpTraceQueue
  wai                   ; wait for task switch
UserStart2:
  ldi   $a0,#12         ; start app
  ldi   $a1,#SystemASR
  brk   #240
.appBad:
  bne   $a0,#0,.appBad
  mov   $s1,$a1
  ldi   $a0,#14         ; get current tid
  brk   #240            ; $a1 = task id
  ldi   $a0,#30         ; set task's app id
  mov   $a2,$s1         ; $a2 = app id
  brk   #240

  mov   $s1,$a1         ; s1 = app id
	ldi		$sp,#$A0080000*2-8  ; setup user mode stack pointer

  ldi   $a0,#12         ; start app
  ldi   $a1,#TinyBasicASR
  brk   #240
	ldi		$a0,#1          ; Start finalizer task, task #1
	mov   $a1,$s1
	ldi		$a2,#0
	ldi		$a3,#Finalizer
	ldi   $a4,#$0B        ; user mode, regset 11
	brk   #240
	ldi		$a0,#1          ; Start task for monitor, task #2
	mov   $a1,$s1
	ldi		$a2,#0
	ldi		$a3,#MonEntry
	ldi   $a4,#$0A        ; user mode, regset 10
	brk   #240
  ldi   $a0,#25         ; map OS vars
  brk   #240
  mov   $gp,$a1

UserStart3:
	ldi		$sp,#$A0080000*2-8  	; setup user mode stack pointer
	ldi		$a0,#24							; RequestIOFocus
	mov   $a1,$s1
	brk   #240
;	ldi		$sp,#$70000		      ; setup temporary user mode stack pointer
;	mov   $a0,$a1             ; $a0 = tid
;	call AllocStack
;	add   $sp,$v1,#1020       ; place stack pointer at top of allocated region
	ldi		$t0,#$08						; turn on the LED
	stt		$t0,VIA+VIA_PARAW
	ldi		$t2,#16							; send an XON just in case
	ldi		$a3,#XON
.0004:
	bal   $x1,Putch ;SerialPutChar
	sub		$t2,$t2,#1
	bne	  $t2,#0,.0004
.0002:
;  ldi   $a0,#25             ; Map OS vars
;  brk #240
;  mov   $gp,$a1
  ; Request that the idle task announce itself.
;  ldi   $a0,#9              ; SendMsg
;  ldwu  $a1,IdleTaskMbx[$gp]
;  beqz  $a1,.noMbx
;  ldi   $a2,#MT_ANNOUNCE
;  ldi   $a3,#0
;  ldi   $a4,#0
;  brk #240
.noMbx:
	ldi		$a0,#msgStart				; spit out a startup message
	bal   $x1,PutString
;		ldi		a0,#1
;		ldi		a1,#24000
;		ldi		a2,#Monitor
;		brk #240
	bal   $x1,DumpReadyQueue
	bra		MonEntry
..
		; Now a loop to recieve and echo back characters
.0003:
;	ldi		$a0,#26							; FMTK_IO
;	ldi   $a1,#5
;	ldi		$a2,#9							; peekchar function
;	brk #240
;	mov   $v0,$v1
;	bltz	$v1,.0003
;	ldi		$a0,#26							; FMTK_IO
;	ldi   $a1,#5
;	ldi		$a2,#8							; getchar function
;	brk #240
;	mov		$a3,$v1
;	mov   $a0,$a3
;	call PutHexByte
;	bra		.0003

;------------------------------------------------------------------------------
; This task runs only if nothing else can run. It must run at the machine
; operating mode.
; Search for ready tasks and add them back into the ready queue.
;------------------------------------------------------------------------------
;  align 	code
IdleTask():
  ldi   $a0,#6                ; alloc mailbox
  ldi   $a1,#0                ; app #0
  brk   #240
  stw   $a1,IdleTaskMbx[$gp]  ; save mailbox handle off
.loop2:
  ldi   $t0,#$4000
  ldi   $t1,#1
.loop:
  ldi   $a0,#11               ; PeekMsg
  ldwu  $a1,IdleTaskMbx[$gp]
  ldi   $a2,#IdleTaskMsgD1
  ldi   $a3,#IdleTaskMsgD2
  ldi   $a4,#IdleTaskMsgD3
  ldi   $a5,#1                ; remove from queue if present
;  brk #240
;  bnez  $a0,.noMsg
;  ldt   $a0,IdleTaskMsgD1
;  xor   $t1,$a0,#MT_ANNOUNCE
;  bnez  $t1,.noAnnounce
;  ldi   $a0,#msgIdleAnnounce
;  call PutString
.noAnnounce:
.noMsg:
  ldi   $a0,#17               ; run as OS
  ldi   $a1,#.IdleCode
  mov   $a2,$t0
  brk   #240
  add   $t0,$t0,#PAGESZ
  sne   $t3,$t0,#MEMSZ*PAGESZ
  bne   $t3,#0,.loop
	bra		.loop2
  ; This section of code runs as part of the OS
  ; Don't callany functions though as there's no stack available
.IdleCode:
  ldt   $t0,OBJMagic[$a2]
  sne   $t3,$t0,#TCB_MAGIC
  bne   $t3,#0,.nxtObj
  ldbu  $t3,TCBStatus[$t2]    ; get status
  and  	$t3,$t3,#TS_READY
  bne   $t3,#0,.nxtObj
  ; The task was ready, but not found in the ready queue. So add it
  srl   $a0,$a2,#LOG_PGSZ
  mDI
  mInsertIntoReadyQueue
  mEI
.nxtObj:
  ldi   $a0,#E_Ok
  bra   OSExit
..

	rodata
	align	1
msgIdleAnnounce:
  db  "Idle task running.",CR,0

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;  align 	code
	code
	align		16
_Delay2s .proc
ifdef TEST
  ldi     $a1,#10
else
	ldi			$a1,#3000000
endif
.0001:
	srl			$a2,$a1,#16
	stb			$a2,LEDS
	sub 		$a1,$a1,#1
	bgeu	  $a1,#1,.0001
	ret
.endp _Delay2s

;------------------------------------------------------------------------------
; Get a character from input device. Checks for a CTRL-T which indicates to
; switch the I/O focus.
;
; Parameters:
;		none
; Returns:
;		$a0 = character, -1 if none available
;------------------------------------------------------------------------------
	align		16
Getch():
	sub		$sp,$sp,#16
	sto		$x1,[$sp]
	sto		$a1,8[$sp]
	ldi   $a1,#5  ;CURIN
	bal		$x1,fgetc
	ldo		$a1,8[$sp]
	ldo		$x1,[$sp]
	add   $sp,$sp,#16
	ret
..

;------------------------------------------------------------------------------
; Parameters:
;   $a0 = character to put
;------------------------------------------------------------------------------
  align	16
_putch .proc
  bra   dbg_Putch
.endp _putch

	align		16
Putch .proc
  bra   dbg_Putch
	sub		$sp,$sp,#24
	sto		$x1,[$sp]
	sto		$a3,8[$sp]
	sto		$a1,16[$sp]
	mov		$a3,$a0
	ldi		$a1,#5  ;CUROUT    ; serial port
	bal		$x1,fputc
	ldo		$x1,[$sp]
	ldo		$a3,8[$sp]
	ldo		$a1,16[$sp]
	add   $sp,$sp,#24
	ret
.endp Putch

	align		16
calcScreenPos .proc
  ldbu  $t0,_cursorY
  bgeu  $t3,#29,.0001
.0002:
  mulf  $t1,$t0,#56
  ldbu  $t0,_cursorX
  bgeu  $t0,#56,.0003
.0004:
  add   $t1,$t1,$t0
  sll   $t1,$t1,#3			; 8 bytes
  add   $t2,$t1,#TEXTSCR
  ret
; This is cool in ANY1. Storing a smalll constant to memory does not require
; the use of a source register. This allows the LDI and the STB to proceed
; in parallel. The store does not need to wait for a register.
.0001:
  ldi   $t0,#28
  stb   #28,_cursorY
  bra   .0002
.0003:
  ldi   $t0,#55
  stb   $t0,_cursorX
  bra   .0004
.endp calcScreenPos

	align		16
incScreenPos .proc
  ldbu  $t0,_cursorX
  add   $t0,$t0,#1
  bltu  $t0,#56,.0001
  stb   #0,_cursorX
  ldbu  $t0,_cursorY
  add   $t0,$t0,#1
  bltu  $t0,#29,.0002
  push	$x1
  bal		$x1,dbg_ScrollUp
  pop		$x1
  ret
.0002:
  stb   $t0,_cursorY
  ret
.0001:
  stb   $t0,_cursorX
  ret
.endp incScreenPos
  
	align		16
dbg_Putch .proc
	push	$x1
  beq  	$a0,#CR,.cr
  beq  	$a0,#LNFD,.lf
  ldo   $t3,_DBGAttr
  or    $t3,$a0,$t3
  bal		$x1,calcScreenPos
  sto   $t3,[$t2]
  bal		$x1,incScreenPos
.xit:
	pop		$x1
  ret
 .lf:
  stb   #0,_cursorX
  ldbu  $a0,_cursorY
  add   $a0,$a0,#1
  bgeu  $a0,#29,dbg_ScrollUp
  stb   $a0,_cursorY
  bra		.xit
.cr:
  stb   #0,_cursorX
  bra		.xit
.endp dbg_Putch

	align		16
dbg_ScrollUp .proc
	push	$x1
  ldi   $t0,#TEXTSCR
ifdef TEST
  ldi   $t1,#6
else
  ldi   $t1,#56*28
endif
.0001:
  ldo   $t2,56*8[$t0]
  sub  	$t1,$t1,#1      ; placed here eliminates pipeline bubble
  sto   $t2,[$t0]
  add   $t0,$t0,#8
  bne   $t1,#0,.0001
  bal		$x1,dbg_BlankLastLine
  pop		$x1
	ret
.endp dbg_ScrollUp

	align		16
dbg_BlankLastLine .proc
  ldi   $t0,#TEXTSCR+56*28
  ldi   $t1,#55
  ldi   $t2,_DBGAttr
  or    $t2,$t2,#' '
.0001:
  sto   $t2,[$t0+$t1*8]
  sub  	$t1,$t1,#1
  bgeu  $t1,#1,.0001
  ret
.endp dbg_BlankLastLine

  align	16
dbg_HomeCursor .proc
  stb   $x0,_cursorX
  stb   $x0,_cursorY
  ret
.endp dbg_HomeCursor
  
;------------------------------------------------------------------------------
; fputc - put a character to an I/O device. If the task doesn't have the I/O
; focus then it is rescheduled, allowing another task to run.
;
; Stack Space:
;		6 words
; Register Usage:
;		a0 = FMTK_IO specify
;		a2 = device putchar function
; Parameters:
;		a1 = I/O channel
;		a3 = character to put
; Modifies:
;		none
; Returns:
;   EOF if error occurred, otherwise character to put
;------------------------------------------------------------------------------
  align	16
fputc():
	sub		$sp,$sp,#32
	sto		$x1,[$sp]
	sto		$a1,16[$sp]
	sto		$a2,24[$sp]
	seq   $t0,$a6,#'B'
	beq   $t0,#0,.noBypass
	bal		$x1,SerialPutChar
	bra   .xit
.noBypass:
	; If the device is a UI device there may be multiple owning jobs. It doesn't
	; do any good to check for ownership. Instead the I/O focus is checked to
	; see if it's present.
	bal		$x1,GetUIFlag
	bne   $a1,#0,.checkOwner
  ldo   $a1,16[$sp]
	bal		$x1,WaitForIOFocus
	bra   .0001
.checkOwner:
  bal		$x1,CheckDevOwner
  bne   $a0,#0,.notOwner
.0001:
  ldo   $a1,16[$sp]
	ldi		$a0,#26							; FMTK_IO
	ldi		$a2,#13							; putchar function
	brk   #240
	mov   $a0,$a3
.xit:
	ldo		$x1,[$sp]
	ldo		$a1,16[$sp]
	ldo		$a2,24[$sp]
	add   $sp,$sp,#32
	ret
.notOwner:
  ldi   $a0,#EOF
  bra   .xit
..
 
;------------------------------------------------------------------------------
; fgetc - get a character from an I/O device. If the task doesn't have the I/O
; focus then it is rescheduled, allowing another task to run.
;
; Stack Space:
;		4 words
; Register Usage:
;		a0 = FMTK_IO specify
;		a2 = device getchar function
; Parameters:
;		a1 = I/O channel
; Modifies:
;		none
; Returns:
;		a0 character, -1 if none available
;------------------------------------------------------------------------------
  align	16
fgetc():
	sub		$sp,$sp,#32
	sto		$x1,[$sp]
	sto		$a1,16[$sp]
	sto		$a2,24[$sp]
	bal		$x1,GetUIFlag
	beq   $a1,#0,.checkOwner
	ldo		$a1,16[$sp]
	bal		$x1,WaitForIOFocus
	bra   .0001
.checkOwner:
	ldo		$a1,16[$sp]
  bal		$x1,CheckDevOwner
  bne   $a0,#0,.notOwner
.0001:
	ldi		$a0,#26							; FMTK_IO
	ldo		$a1,16[$sp]
	ldi		$a2,#8							; getchar function
	brk   #240
	mov   $a0,$a1
.0002:
	ldo		$x1,[$sp]
	ldo		$a1,16[$sp]
	ldo		$a2,24[$sp]
	add   $sp,$sp,#32
	ret
.notOwner:
  ldi   $a0,#-1
  bra   .0002
..

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
  align		16
MonEntry():
;		flw			$f2,fltTen
;		fsw			$f2,f2Save
;		flw			$f1,fltTen
;		fsw			$f1,f1Save
;		fadd		$f18,$f2,$f1
;		fsw			$f18,f18Save
		ldi		$a0,#10
		ldi		$a2,#6
;		call	fltToString
;		ldi		$a0,#STRTMP
;		call	PutString

  ; align cache
..
Monitor():
.getFocus:
;	ldi   $a0,#20       ; has IO focus
;	brk #240
;	bnez  $v1,.hasFocus
;	ldi   $a0,#21       ; switch focus
;	brk #240
;	bra   .getFocus
.hasFocus:
;		call	DumpReadyList
;		call	DumpTimeoutList
	ldi		  $s1,#0					; s1 = input pointer
	ldi			$a0,#msgPrompt
	bal   	$x1,PutString
.0001:
	bal   	$x1,Getch						; wait until character pressed
	blt	    $a0,#0,.0001	; test return value
	beq			$a0,#LNFD,.procLine	; process line feed
	beq			$a0,#CR,.procLine	; and carriage return
	beq	    $a0,#BS,.doBackspace
	ldi			$t0,#DEL
	beq		  $a0,$t0,.doDelete
	stb		  $a0,INBUF[$s1]
	add		  $s1,$s1,#1
	bal  		$x1,Putch
	bra		  .0001
.doDelete:
	mov		  $s2,$s1
	add		  $s2,$s2,#1
.0002:
	ldb		  $t0,INBUF[$s2]
	stb		  $t0,INBUF-1[$s2]
	add		  $s2,$s2,#1
	add		  $t0,$s2,#INBUF
	slt		  $t1,$t0,#INBUF+$7F
	bne		  $t1,#0,.0002
	stb		  #0,INBUF[$s2]
	bra		  .0001
.doBackspace:
	beq		  $s1,#0,.0001    ; can't backspace anymore
	bal   	$x1,Putch       ; show the backspace
	sub		  $s1,$s1,#1
	mov		  $s2,$s1
.0003:
	ldb		  $t0,INBUF+1[$s2]
	stb		  $t0,INBUF[$s2]
	add		  $s2,$s2,#1
	add		  $t0,$s2,#INBUF
	slt		  $t1,$t0,#INBUF+$7F
	bne		  $t1,#0,.0003
	stb		  #0,INBUF[$s2]
	bra		  .0001
.procLine:
	stb		  #0,INBUF[$s1]
	ldi		  $s1,#0
.skip:
	ldb	  	$t0,INBUF[$s1]
	beq		  $t0,#0,.0005
	ldi			$t1,#'>'
	bne		  $t0,$t1,.0004
.skip2:
	add		  $s1,$s1,#1
	bra		  .skip
.0004:
	ldi			$t1,#' '
	beq			$t0,$t1,.skip2
	ldi			$t1,#'\t'
	beq			$t0,$t1,.skip2
	ldi			$t1,#'x'
	bne     $t0,$t1,.notX
	ldi     $a0,#E_Ok
	bra     OSExit
.notX:
	ldi			$t1,#'M'
	beq			$t0,$t1,doMem
	ldi			$t1,#'V'
	beq     $t0,$t1,doVMem
	ldi			$t1,#'P'
	beq     $t0,$t1,doPState
	ldi			$t1,#'B'
	beq		  $t0,$t1,.0006
	bal   	$x1,GetDecNum
	bne     $a0,#0,.basSize
	ldi     $a0,#32000
.basSize:
	ldi		  $a0,#12					; Start App
	ldi     $a1,#TBASR
	brk     #240
	mov		  $s1,$a1					; save v1
	bal   	$x1,PutCRLF
	mov		  $a0,$s1					; get back v1
	bal   	$x1,PutHexByte
	ldi		  $a0,#msgTaskStart
	bal   	$x1,PutString
	bal   	$x1,DumpReadyQueue
	; The monitor is running in machine mode. A return instruction is used to
	; switch to user mode. The return address must be set to the desired user
	; code address.
	mDI                     ; disable interrupts
	ldi     $t0,#CSTART       ; pick start of Tiny Basic
	csrrw   $x0,#$341,$t0     ; set as return address
	ldi     $t0,#$00011111    ; bits to select register set #1
	csrrw   $x0,#CSR_REGSET,$t0     ; select register set #1 (will decrement to zero then on mret)
	rte                     ; will begin running Tiny Basic in user mode
	;ldi		$a0,#5					; Reschedule task
	;ldi		$a1,#1					; sleep(0)
	;brk #240
	bra		  Monitor
.0006:
	ldi			$t1,#'D'
	bne		  $t0,$t1,.0007
	ldb		  $t0,INBUF+1[$s1]
	ldi			$t1,#'T'
	bne		  $t0,$t1,.noT
	bal   	$x1,DumpTimeoutList
	bra		  Monitor
.noT:
	bal   	$x1,DumpReadyQueue
	;ldi		$a0,#15
	;brk #240
	bra		  Monitor
.0007:
	ldi			$t1,#'E'
	beq		  $t0,$t1,EditMem
	ldi			$t1,#'F'
	bne		  $t0,$t1,.0009
	ldb     $t0,INBUF+1[$s1]
	ldi			$t1,#'I'
	bne			$t0,$t1,.notFind
	add     $s1,$s1,#1
	bra     Find
.notFind:
	bra		  FillMem
.0009:
	ldi			$t1,#'S'
	bne		  $t0,$t1,.0010
	ldi		  $a0,#5					; sleep(0)
	ldi		  $a1,#1
	brk     #240
	bra		  Monitor
.0010:
	ldi			$t1,#'K'
	bne		  $t0,$t1,.0011
	bal     $x1,GetHexNum
	mov		  $a1,$a0					; a0 = pid
	ldi		  $a0,#3					; kill task
	brk     #240
	bra		  Monitor
.0011:
	ldi			$t1,#'?'
	bne		  $t0,$t1,.0012
	ldi		  $a0,#msgMonHelp
	bal    	$x1,PutString
	bra		  Monitor
.0012:
.0005:
	bra		  Monitor
..

  align	16
doMem():
	sub		$sp,$sp,#8
	add		$s1,$s1,#1
	ldb		$t0,INBUF[$s1]
	sne   $t0,#'O'
	bt    .0001
	add		$s1,$s1,#1
.0001:
	sto		$s1,[$sp]
	ldi		$a0,#CR
	bal   $x1,Putch
	ldi		$a0,#INBUF
	bal   $x1,PutString
	ldo		$s1,[$sp]
	add		$sp,$sp,#8
	bal   $x1,GetHexNum
	mov		$s3,$a0
	mov   $s5,$a0
	add		$s1,$s1,#1
	bal   $x1,GetHexNum
	add		$s4,$a0,$s3
.loop2:
	bal   $x1,Getch						; check for ctrl-c
	beq		$a0,#3,Monitor
	ldi		$a0,#CR
	bal   $x1,Putch
	mov		$a0,$s3
	bal   $x1,PutHexWord
	ldi		$a0,#':'
	bal   $x1,Putch
	ldi		$s2,#7
.loop:
	ldi		$a0,#' '
	bal   $x1,Putch
	bne   $t0,$x0,.userMem
	ldi   $a0,#33         ; Fetch memory word
	mov   $a1,$s3
	brk   #240
	mov   $a0,$a1
	bra   .0002
.userMem
	ldb		$a0,[$s3]
.0002:
	bal   $x1,PutHexByte
	add		$s3,$s3,#1
	sub		$s2,$s2,#1
	bge		$s2,$x0,.loop
	bltu  $s3,$s4,loop2
;	call  PutInlineString
;	db    ' ',' ',0
	mov   $s3,$s5
.0004:
	ldbu  $a0,[$s3]
	bltu  $a0,#$20,.unprintable
	bal   $x1,Putch
	bra   .0003
.unprintable:
  ldi   $a0,#'.'
  bal   $x1,Putch
.0003:
  add   $s3,$s3,#1
  bltu  $s3,$s4,.0004
  ldi   $a0,#CR
  bal   $x1,Putch
	bra		Monitor		
..

  align	16
EditMem():
;	csrrs $x0,#CSR_UIE,#1        ; enable gc interrupt
	bal   $x1,GetHexNum			; get address to edit
	mov		$s3,$a0
	add		$s1,$s1,#1
	bal   $x1,GetHexNum			; get value to set
	stb		$s3,[$a0]			; update mem
	bra		Monitor
..

;------------------------------------------------------------------------------
; >V 0
; Displays the virtual memory map for the specified app.
;------------------------------------------------------------------------------

  align	16
doVMem():
  add   $s1,$s1,#1
  bal   $x1,GetDecNum
  ldi   $t1,#0
  sll   $t0,$a0,#16
.0001:
  and  	$a0,$t1,#3
  bne   $a0,$x0,.notLF
  bal   $x1,PutCRLF
.notLF:
  mov   $a0,$t0
  bal   $x1,PutHexWord
  ldi   $a0,#':'
  bal   $x1,Putch
  mvmap $a0,$x0,$t0
  bal   $x1,PutHexHalf
  ldi   $a0,#' '
  bal   $x1,Putch
  add   $t0,$t0,#1
  add   $t1,$t1,#1
  slt   $a0,$t1,#256
  bne   $a0,$x0,.0001
  bra   Monitor
..

;------------------------------------------------------------------------------
; >P
; Display the PAM bits status.
;------------------------------------------------------------------------------

  align	16
doPStat():
  bal   $x1,PutCRLF
  ldi   $t1,#0        ; $a1 = bit number
.0001:
  ldi   $a0,#32       ; Get PAM bit pair
  brk   #240
  add   $a0,$a1,#'0'
  bal   $x1,Putch
  add   $t1,$t1,#1
  slt   $a0,$t1,#MEMSZ
  bne   $a0,#0,.0001
  bra   Monitor
..
 
;------------------------------------------------------------------------------
;	>F 1000 800 EE
; Fills memory beginning at address $1000 for $800 bytes with the value $EE
;------------------------------------------------------------------------------

  align	16
FillMem:
	bal   $x1,GetHexNum			; get address
	mov		$s3,$a0
	add		$s1,$s1,#1
	bal   $x1,GetHexNum			; get length
	mov		$s4,$a0
	add		$s1,$s1,#1
	bal   $x1,GetHexNum			; get byte to use
.0001:
	sub		$s4,$s4,#1
	stb		$a0,[$s3+$s4]
	bgeu	$s4,#1,.0001
	bra		Monitor
..

;------------------------------------------------------------------------------
; FI Hello
;------------------------------------------------------------------------------

  align	16
Find():
  bal   $x1,PutCRLF
  bal   $x1,SkipSpaces
  mov   $s2,$s1
.fwe:
  ldbu  $t0,INBUF[$s2]
  seq		$t1,$t0,#' '
  seq		$t2,$t0,#CR
  or		$t1,$t1,$t2
  bne		$t1,$x0,.endOfWord
  add   $s2,$s2,#1
  bra   .fwe
.endOfWord:
  stb   $x0,INBUF[$s2]
  mov   $s2,$s1
  ldi   $a0,#0
  ldi   $a1,#0
.loop:
	bal		$x1,Getch						; check for ctrl-c
	beq	  $a0,#3,Monitor
.0001:
  ldbu  $t0,[$a0]
  ldbu 	$t1,INBUF[$s2]
  beq   $t1,$x0,.found
  seq   $t1,$t0,$t1
  beq   $t1,$x0,.next
  add   $a0,$a0,#1
  add   $s2,$s2,#1
  bra   .loop
.next:
  mov   $s2,$s1         ; start over again with $s2
  add   $a0,$a1,#1      ; start over again with $a0, but increment by one byte
  ldi   $t2,#$80000     ; 512k
  mov   $a1,$a0         ; remember new starting pos.
  slt   $t1,$a0,$t2
  bne   $t1,$t0,.loop
  bra   .notFound
.found:
  bal   $x1,PutHexTetra
  bal   $x1,PutCRLF
  bra   .next
.notFound:
  bal   $x1,PutCRLF
  bra   Monitor
..

;------------------------------------------------------------------------------
; Skip over spaces and tabs in the input buffer.
;------------------------------------------------------------------------------

  align	16
SkipSpaces():
.skip2:
	ldb		$t0,INBUF[$s1]
	seq		$t1,$t0,#' '  ; space or
	seq		$t2,$t0,#'\t'	; tab
	or		$t1,$t1,$t2
	beq		$t1,$x0,.done
	add 	$s1,$s1,#1
	bra	  .skip2
.done
  ret
..

;------------------------------------------------------------------------------
; Get a hex number from the input buffer.
;------------------------------------------------------------------------------

  align	16
GetHexNum():
	sub		$sp,$sp,#8
	sto		$x1,[$sp]
	ldi		$a0,#0							; a0 = num
	bal   $x1,SkipSpaces
.next:
	ldb		$t0,INBUF[$s1]
	bltu	$t0,#'0',.0001
	bltu	$t0,#'9'+1,.isDigit
	bltu	$t0,#'A',.0001
	bltu	$t0,#'F'+1,.isHexUpper
	ldi		$t1,#'a'
	bltu	$t0,$t1,.0001
	ldi		$t1,#'f'+1
	bltu	$t0,$t1,.isHexLower
.0001:
	ldo		$x1,[$sp]
	add		$sp,$sp,#8
	ret
.isHexUpper:
	sll		$a0,$a0,#4
	sub		$t0,$t0,#'A'
	add		$t0,$t0,#10
	or		$a0,$a0,$t0
	add		$s1,$s1,#1
	bra		.next
.isHexLower:
	sll		$a0,$a0,#4
	sub		$t0,$t0,#'a'
	add		$t0,$t0,#10
	or		$a0,$a0,$t0
	add		$s1,$s1,#1
	bra		.next
.isDigit:
	sll		$a0,$a0,#4
	sub		$t0,$t0,#'0'
	or		$a0,$a0,$t0
	add		$s1,$s1,#1
	bra		.next
..

;------------------------------------------------------------------------------
; Get a decimal number from the input buffer.
;------------------------------------------------------------------------------
  align		16
GetDecNum():
	sub			$sp,$sp,#8
	sto			$x1,[$sp]
	ldi			$a0,#0							; a0 = num
	bal 	  $x1,SkipSpaces
.next:
	ldb		  $t0,INBUF[$s1]
	bltu		$t0,#'0',.0001
	bltu		$t0,#'9'+1,.isDigit
.0001:
	ldo			$x1,[$sp]
	add			$sp,$sp,#8
	ret
.isDigit:
	; mulf is not used to allow the number to be larger than 40 bits
	sll		$t2,$a0,#1    ; multiply by 10
	sll   $a0,$a0,#3    ; * 8
	add   $a0,$a0,$t2   ; + *2
	sub		$t0,$t0,#'0'
	add		$a0,$a0,$t0
	add		$s1,$s1,#1
	bra		.next
..

;------------------------------------------------------------------------------
; Output an octabyte as a hex string.
;
; Parameters:
;   a0 = contains octabyte value to output
; Registers Affected:
;   none
; Returns:
;   none
;------------------------------------------------------------------------------

  align	16
PutHexOcta():
	enter	#32
	ror		$a0,$a0,#32
	bal		$x1,PutHexTetra
	rol   $a0,$a0,#32
	bal		$x1,PutHexTetra
	leave	#32
..

;------------------------------------------------------------------------------
; Output a word as a hex string.
;
; Parameters:
;   a0 = contains word to output
; Registers Affected:
;   none
; Returns:
;   none
;------------------------------------------------------------------------------

  align	16
PutHexTetra():
	enter	#32
	ror		$a0,$a0,#16
	bal		$x1,PutHexWyde
	rol		$a0,$a0,#16
	bal		$x1,PutHexWyde
	leave	#32
..

;------------------------------------------------------------------------------
; Output a half-word (16 bits) as a hex string.
;------------------------------------------------------------------------------

	align	16
PutHexWyde():
	enter	#32
	ror		$a0,$a0,#8
	bal		$x1,PutHexByte
	rol		$a0,$a0,#8
	bal		$x1,PutHexByte
	leave	#32
..

;------------------------------------------------------------------------------
; Output a byte as a hex string.
;------------------------------------------------------------------------------

	align	16
PutHexByte():
	enter	#32
	ror		$a0,$a0,#4		; put the high order nybble first
	bal		$x1,PutHexNybble
	rol		$a0,$a0,#4		; restore a0
	bal		$x1,PutHexNybble
	leave	#32
..

;------------------------------------------------------------------------------
; Output a nybble as a hex string.
;
; Parameters:
;   a0 = contains nybble to output
; Registers Affected:
;   none
; Returns:
;   none
;------------------------------------------------------------------------------

  align	16
PutHexNybble():
	enter	#48
	sto		$a0,0[$sp]
	sto   $t0,8[$sp]
	and		$a0,$a0,#15		; strip off high order bits
	blt		$a0,#10,.lt10
	sub		$a0,$a0,#10
	add		$a0,$a0,#'A'-'0'
.lt10:
	add		$a0,$a0,#'0'
	bal		$x1,Putch
.0001:
	ldo		$a0,0[$sp]
	ldo   $t0,8[$sp]
	leave	#32
..

;------------------------------------------------------------------------------
; PutInlineString
;   Put a string of characters to output device. The string parameter is
; located as an inline parameter.
;------------------------------------------------------------------------------
	align	16
PutInlineStringCA():			; chunk addressing
  ldo   $t1,[$sp]         ; pop return address
  sub		$sp,$sp,#16				; make room for save area
	sto		$a0,[$sp]				  ; save a0
	sto		$s1,8[$sp]				; and s1
	sto		$s2,16[$sp]
	mov		$s1,$t1						; s1 = pointer to string
	mov		$s2,$t1						; s2 = pointer to string
.0001:
	ldb		$a0,[$s1]
	add		$s1,$s1,#2				; advance pointer to next byte
	beq 	$a0,#0,.done      ; branch if done
	call	Putch							; output character, assume $tx destroyed
	bra		.0001
.done:
	sub		$s2,$s1,$s2				; get count of nybbles
	rem		$s2,$s2,#9				; figure mod 9
	beq		$s2,#0,.remz
	subf	$s2,$s2,#9				; number of nybbles to add 9-mod
.remz:
	add		$t1,$s1,$s2				; $t1 = return address
	ldo		$a0,[$sp]				  ; restore a0
	ldo		$s1,8[$sp]				; restore $s1,$s2
	ldo		$s2,16[$sp]
	add   $sp,$sp,#24				; pop save area and return address
  jmp   [$t1]
..

	align	16
PutInlineString():
  ldo   $t1,[$sp]         ; pop return address
  sub		$sp,$sp,#16				; make room for save area
	sto		$a0,[$sp]				  ; save a0
	sto		$s1,16[$sp]				; and s1
	mov		$s1,$t1						; s1 = pointer to string
.0001:
	ldb		$a0,[$s1]
	add		$s1,$s1,#2				; advance pointer to next byte
	beq 	$a0,#0,.done      ; branch if done
	call	Putch							; output character, assume $tx destroyed
	bra		.0001
.done:
	mov		$t1,$s1						; $t1 = return address
	ldo		$a0,[$sp]				  ; restore a0
	ldo		$s1,16[$sp]				; restore $s1
	add   $sp,$sp,#32				; pop save area and return address
  jmp   [$t1]
..

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------

	align	16
PutCRLF .proc
	enter	#0
	ldi		$a0,#CR
	bal		$x1,Putch
	ldi		$a0,#LNFD
	bal		$x1,Putch
	leave	#0
.endp PutCRLF

;------------------------------------------------------------------------------
; PutString
;    Put a string of characters to the serial transmitter. Calls the 
; Putch routine, so this routine also blocks if the transmitter is not
; empty.
;
; Parameters:
;		$a0 = pointer to null terminated string to put
; Modifies:
;		$t0,$t1,$t2,$t3
; Stack Space:
;		2 words
;------------------------------------------------------------------------------
  align	16
PutString .proc
	enter	#16
	sto		$a0,[$sp]				  ; save argument
	sto   $s1,8[$sp]        ; and reg var
	mov		$s1,$a0						; s1 = pointer to string
.0001:
	ldb		$a0,[$s1]
	add		$s1,$s1,#1				; advance pointer to next byte
	beq 	$a0,#0,.done     	; branch if done
	bal		$x1,Putch					; output character
	bra		.0001
.done:
	ldo		$a0,[$sp]				  ; restore argument
	ldo   $s1,8[$sp]
	leave	#0
.endp PutString

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
	align		16
DumpTraceQueue():
	ldi     $a6,#'X'        ; bypass='B' in fputc routine
.dmpTrace:
	ldi     $a0,#CR
	bal			$x1,Putch
	ldi     $a1,#14         ; processor trace queue status
	peekq  	$a0,$a1
	blt     $a0,$x0,.dmpTraceEmpty  ; emptied out?
	ldi     $a1,#15         ; processor trace queue data
	popq   	$a0,$a1
	bal			$x1,PutHexOcta
	bra     .dmpTrace
.dmpTraceEmpty:
	ldi     $a0,#CR
	bal			$x1,Putch
.inf:
  bra     .inf
  ret
..

;------------------------------------------------------------------------------
; Exception processing code starts here.
;------------------------------------------------------------------------------
	code
	align	16
IRQRout .proc
	csrrw	$t0,#CSR_DCAUSE,$x0		; get cause code
	bbs	  $t0,#15,.isIRQ	      ; irq or brk #240?
	beq		$t0,#2,.unimp					; unimplemented instruction?
	cmp		$t2,$t0,#240
	beqz	$t2,.brk
	; Some other cause
.unimp:
  sto   $t0,$4018
	csrrc $x0,#CSR_TRACECTRL,#1 ; turn off tracing
	ldi   $t0,#DumpTraceQueue
	csrrw $x0,#CSR_MEPC,$t0
	bra		DBGxit
.soc:
  bra   .soc
.brk:
	bra		OSECALL					  ; goto operating system call dispatcher
.isIRQ:
	csrrw	$t0,#CSR_DCAUSE,$x0			; get cause code
  ldt   $t1,IRQFlag     ; update IRQ flag for Tiny Basic
  add   $t1,$t1,#1
  stt   $t1,IRQFlag
  and   $t0,$t0,#$FF
  stt   $t0,IRQCause    ; update cause code for Tiny Basic
  sub  	$t1,$t0,#1
  beq   $t1,$x0,.softwareIrq
  sub  	$t1,$t1,#1
  beq   $t1,$x0,.timerIrq
  sub  	$t1,$t1,#1      ; garbage collect interrupt?
  beq   $t1,$x0,.gcIrq
	and		$t4,$t0,#31			; interrupting device # is low order 5 bits of cause code
	mov   $t5,$t4
	mulf	$t5,$t5,#DCB_Size	; 128 bytes per device
	add		$t5,$t5,#DCB_Base
	ldi		$a0,#22								; IRQ function
	lea		$a6,DCB_pCmdProc[$t5]	; point $a6 to target descriptor
	jal		$x2,_FAR_CALL					; jump to the IRQ routine
.softwareIrq:
.timerIrq:
  bra   DBGxit
.gcIrq:
;	ldi		$sp,#$7F800-4		; setup interrupt mode stack pointer
  bal 	$x1,gcIncrement
  bra		DBGxit
ERETx2:
;  mDI
;  csrrc $x0,#$7C0,#31   ; select machine regs only
;  csrrw $t0,#$7C0,$x0   ; get register sets
;  srl   $t0,$t0,#5      ; extract register set selection
;  sll   $t0,$t0,#3
;  ldt   $t1,MEPC0[$t0]  ; get it
;  csrrw $x0,#$341,$t1   ; set mepc
  mDI
  nop
  nop
  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
  asl   $t2,$t0,#2        ; $t2 = table index
	ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
	rte

	; In case the pipeline runs ahead into the following table which will
	; result in illegal instructions.
	nop
	nop
  nop
.endp IRQRout

  align	16
DBGRout .proc
	csrrw	$x0,#CSR_DSCRATCH,$x31	; save x31 in scratch
	csrrd	$x31,#CSR_DSP						; get pointer to stack
	sub		$x31,$x31,#416					; allocate register storage area
	csrrw	$x0,#CSR_DSP,$x31
	sto		$x1,8[$x31]
	csrrd	$x1,#CSR_EIP						; save ECS:EIP
	sto		$x1,256[$x31]
	csrrd	$x1,#CSR_ECS
	sto		$x1,264[$x31]
	csrrd	$x1,#CSR_ECSBND
	sto		$x1,272[$x31]
	csrrd	$x1,#CSR_DSCRATCH				; get back original x31
	sto		$x1,248[$x31]						; and save it
	mEI														; allow higher priority interrupts
	sto		$x2,16[$x31]
	sto		$x3,24[$x31]
	sto		$x4,32[$x31]
	sto		$x5,40[$x31]
	sto		$x6,48[$x31]
	sto		$x7,56[$x31]
	sto		$x8,64[$x31]
	sto		$x9,72[$x31]
	sto		$x10,80[$x31]
	sto		$x11,88[$x31]
	sto		$x12,96[$x31]
	sto		$x13,104[$x31]
	sto		$x14,112[$x31]
	sto		$x15,120[$x31]
	sto		$x16,128[$x31]
	sto		$x17,136[$x31]
	sto		$x18,144[$x31]
	sto   $x19,152[$x31]
	sto		$x20,160[$x31]
	sto		$x21,168[$x31]
	sto		$x22,176[$x31]
	sto		$x23,184[$x31]
	sto		$x24,192[$x31]
	sto		$x25,200[$x31]
	sto		$x26,208[$x31]
	sto		$x27,216[$x31]
	sto		$x28,224[$x31]
	sto		$x29,232[$x31]
	sto		$x30,240[$x31]
	; Save base and bound registers
/*
	mfbase	$t2,$b0
	sto			$t2,288[$x31]
	mfbnd		$t2,$b0
	sto			$t2,296[$x31]
	mfbase	$t2,$b1
	sto			$t2,304[$x31]
	mfbnd		$t2,$b1
	sto			$t2,312[$x31]
	mfbase	$t2,$b2
	sto			$t2,320[$x31]
	mfbnd		$t2,$b2
	sto			$t2,328[$x31]
	mfbase	$t2,$b3
	sto			$t2,336[$x31]
	mfbnd		$t2,$b3
	sto			$t2,344[$x31]
	mfbase	$t2,$b4
	sto			$t2,352[$x31]
	mfbnd		$t2,$b4
	sto			$t2,360[$x31]
	mfbase	$t2,$b5
	sto			$t2,368[$x31]
	mfbnd		$t2,$b5
	sto			$t2,376[$x31]
	mfbase	$t2,$b6
	sto			$t2,384[$x31]
	mfbnd		$t2,$b6
	sto			$t2,392[$x31]
	mfbase	$t2,$b7
	sto			$t2,400[$x31]
	mfbnd		$t2,$b7
	sto			$t2,408[$x31]
*/
	csrrd	$t0,#CSR_DCAUSE
	seq		$t1,$t0,#FLT_WD
	bne		$t1,$x0,DBGxit
  bra		IRQRout
  rex   #3,$x0
DBGxit:
	csrrd		$x31,#CSR_DSP
	; Restore base and bound registers
/*
	ldo			$t2,288[$x31]
	mtbase	$b0,$t2
	ldo			$t2,296[$x31]
	mtbnd		$b0,$t2
	ldo			$t2,304[$x31]
	mtbase	$b1,$t2
	ldo			$t2,312[$x31]
	mtbnd		$b1,$t2
	ldo			$t2,320[$x31]
	mtbase	$b2,$t2
	ldo			$t2,328[$x31]
	mtbnd		$b2,$t2
	ldo			$t2,336[$x31]
	mtbase	$b3,$t2
	ldo			$t2,344[$x31]
	mtbnd		$b3,$t2
	ldo			$t2,352[$x31]
	mtbase	$b4,$t2
	ldo			$t2,360[$x31]
	mtbnd		$b4,$t2
	ldo			$t2,368[$x31]
	mtbase	$b5,$t2
	ldo			$t2,376[$x31]
	mtbnd		$b5,$t2
	ldo			$t2,384[$x31]
	mtbase	$b6,$t2
	ldo			$t2,392[$x31]
	mtbnd		$b6,$t2
*/
	; Base/bound $b7 is going to be loaded with ECS:EIP on rte
	; not much point in restoring it here.

	ldo		$x1,272[$x31]							; restore ECS:EIP
	csrrw	$x0,#CSR_DECSBND,$x1
	ldo		$x1,264[$x31]
	csrrw	$x0,#CSR_DECS,$x1
	ldo		$x1,256[$x31]
	csrrw	$x0,#CSR_DEIP,$x1
	ldo		$x1,8[$x31]
	ldo		$x2,16[$x31]
	ldo		$x3,24[$x31]
	ldo		$x4,32[$x31]
	ldo		$x5,40[$x31]
	ldo		$x6,48[$x31]
	ldo		$x7,56[$x31]
	ldo		$x8,64[$x31]
	ldo		$x9,72[$x31]
	ldo		$x10,80[$x31]
	ldo		$x11,88[$x31]
	ldo		$x12,96[$x31]
	ldo		$x13,104[$x31]
	ldo		$x14,112[$x31]
	ldo		$x15,120[$x31]
	ldo		$x16,128[$x31]
	ldo		$x17,136[$x31]
	ldo		$x18,144[$x31]
	ldo   $x19,152[$x31]
	ldo		$x20,160[$x31]
	ldo		$x21,168[$x31]
	ldo		$x22,176[$x31]
	ldo		$x23,184[$x31]
	ldo		$x24,192[$x31]
	ldo		$x25,200[$x31]
	ldo		$x26,208[$x31]
	ldo		$x27,216[$x31]
	ldo		$x28,224[$x31]
	ldo		$x29,232[$x31]
	ldo		$x30,240[$x31]
	mDI
	add		$x31,$x31,#416			; deallocate stack
	csrrw	$x0,#CSR_DSP,$x31
	ldo		$x31,-168[$x31]
  rte
	nop
	nop
  nop
.endp DBGRout

	align	16
FCC_STDLIB_init .proc
	; set FCC_STDLIB data segment
	ldi		$a1,#$0000000000004006	; 16kB boundary
	ldi		$a0,#0020
	mtbase	[$a0],$a1
	; set Read-only segment
	ldi		$a1,#$FFFFFFFFFFFC0004
	ldi		$a0,#0025
	mtbase	[$a0],$a1
	sync
	ldi		$gp,#0
	ldi		$a0,#0020
	base	$gp,$gp,$a0
	ldi		$gp1,#0
	ldi		$a0,#0025
	base	$gp1,$gp1,$a0
	sync
	ret
.endp FCC_STDLIB_init

END_OF_BOOT:

	rodata
;	org		$0000
	align	2
; Application startup record for system
SystemASR:
  db    0     ; page size (can't change on this system)
  db    2     ; priority normal
  db    12    ; register set for startup task
  db    0     ; memory map #0
  dw    0     ; processor affinity
  dw    0     ; code size (0 = in ROM, don't move)
  dw    0     ; reserved
  dw    0     ; data size (preinitialized data)
  dw    0     ; reserved
  dw    0     ; uninitialized data size
  dw    0     ; reserved
  dw    0     ; Heap size
  dw    0     ; reserved
  dw    1024  ; stack size
  dw    0     ; reserved
  dw    IdleTask  ; pointer to code
  dw    0       ; reserved
  dw    0     ; pointer to data
  dw    0     ; reserved
  dw    0     ; ui data
  dw    0     ; reserved

; Application startup record for Tiny Basic
TinyBasicASR:
  db    0     ; page size (can't change on this system)
  db    2     ; priority normal
  db    0     ; register set
  db    1     ; memory map
  dw    0     ; processor affinity
  dw    0     ; code size (0 = in ROM, don't move)
  dw    0     ; reserved
  dw    0     ; data size (preinitialized data)
  dw    0     ; reserved
  dw    32768 ; uninitialized data size
  dw    0     ; reserved
  dw    0     ; Heap size
  dw    0     ; reserved
  dw    2048  ; stack size
  dw    0     ; reserved
  dw    CSTART  ; pointer to code
  dw    0       ; reserved
  dw    0     ; pointer to data
  dw    0     ; reserved
  dw    0     ; ui data
  dw    0     ; reserved
    
;------------------------------------------------------------------------------
; Message strings
;------------------------------------------------------------------------------

msgStart:
		db		"Femtiki System Starting.",10
msgMonHelp:
		db		"Monitor Commands",10
		db		"B - start tiny basic",10
		db		"D - dump ready que",10
		db		"E - edit memory",10
		db		"F - fill memory",10
		db    "FI <string>- find string in memory",10
		db		"K <tid> - kill task", 10
		db		"M <start> <length>	- dump memory",10
		db    "P - display PAM",10
		db		"S - switch task",10
		db    "V <mid> dump virtual memory map",10
		db		0
		; align cache
msgTaskStart:
		db		" task started."
msgCRLF:
		db		13,10,0
msgPrompt:
	db      CR,LNFD,'>',0
flt50:
	dw	0x00000000,0x00000000,0x00000000,0x40049000
flt20:
	dw	0x00000000,0x00000000,0x00000000,0x40034000
flt10:
	dw	0x00000000,0x00000000,0x00000000,0x40024000
	end _rombase

;.include "fltToString.r64"
.include "bios-mem.r64"
.include "bios-pam.r64"
;.include "bios-tlb.r64"
;.include "ramtest.r64"

.include "../fmtk/msg.r64"
.include "../fmtk/tcb.r64"
;.include "../fmtk/task.r64"
.include "../fmtk/io.r64"
;.include "../fmtk/iofocus.r64"
;.include "../fmtk/serial.r64"
;.include "../fmtk/source/drivers/pti_driver.r64"
;.include "../fmtk/app.r64"
;.include "../fmtk/Finalizer.r64"
;.include "../fmtk/gcIncremental.r64"
;.include "../fmtk/source/kernel/fmtk.r64"
;.include "../fmtk/source/kernel/FMTKc.r64"
;.include "../fmtk/source/kernel/SetupDevices.r64"
;.include "../fmtk/source/kernel/pic.r64"
;.include "../fmtk/source/kernel/DBGConsole.r64"
.include "../fmtk/source/fmtk.l64"
;.include "../fmtk/finalizer.r64"
;.include "../fmtk/gcIncremental.r64"
;.include "TinyBasic.r64"
;.include "../cc64libc/source/ANY1/io.r64"
.include "../cc64libc/source/cc64libc.l64"
;.include "../c_standard_lib-master/c_standard_lib-master/c_standard_lib.l64"
